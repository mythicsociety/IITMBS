<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L4.7: Pronoun Resolution Procedure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .sidebar-link.active {
            background-color: #e0f2fe; /* sky-100 */
            color: #0c4a6e; /* sky-900 */
            font-weight: 600;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* slate-300 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* slate-400 */
        }
        .quiz-option.correct {
            background-color: #dcfce7; /* green-100 */
            border-color: #22c55e; /* green-500 */
        }
        .quiz-option.incorrect {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
        }
        .feedback {
            display: none;
            padding: 0.75rem;
            margin-top: 0.75rem;
            border-radius: 0.5rem;
        }
        .feedback.correct {
            display: block;
            background-color: #f0fdf4; /* green-50 */
            color: #15803d; /* green-800 */
        }
        .feedback.incorrect {
            display: block;
            background-color: #fef2f2; /* red-50 */
            color: #b91c1c; /* red-800 */
        }
        .code-block {
            background-color: #0f172a; /* slate-900 */
            color: #e2e8f0; /* slate-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .code-keyword { color: #7dd3fc; } /* sky-300 */
        .code-variable { color: #f8fafc; } /* slate-50 */
        .code-proc { color: #a5b4fc; } /* indigo-300 */
        .word {
            transition: all 0.3s ease-in-out;
            padding: 2px 4px;
            border-radius: 4px;
        }
        .word.pronoun {
            background-color: #e0f2fe; /* sky-100 */
            font-weight: bold;
        }
        .word.searching {
            background-color: #fef9c3; /* yellow-100 */
        }
        .word.match {
            background-color: #dcfce7; /* green-100 */
            font-weight: bold;
            outline: 2px solid #22c55e;
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Mobile Header with Hamburger Menu -->
    <header class="bg-white/80 backdrop-blur-lg shadow-sm sticky top-0 z-40 lg:hidden flex items-center justify-between p-4">
        <h1 class="text-lg font-bold text-sky-800">Learning Guide</h1>
        <button id="hamburger-btn" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 B 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
        </button>
    </header>

    <div class="flex">
        <!-- Sidebar Navigation -->
        <aside id="sidebar" class="bg-white w-64 fixed inset-y-0 left-0 transform -translate-x-full lg:translate-x-0 lg:sticky lg:top-0 h-screen transition-transform duration-300 ease-in-out z-50 shadow-lg lg:shadow-none border-r border-slate-200">
            <div class="p-6">
                <h2 class="text-xl font-bold text-sky-800 mb-6">L4.7: Pronoun Resolution</h2>
                <nav>
                    <ul id="nav-links" class="space-y-2">
                        <li><a href="#intro" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">Introduction</a></li>
                        <li><a href="#challenge" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">The Challenge</a></li>
                        <li><a href="#algorithm" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">The Backward Search Algorithm</a></li>
                        <li><a href="#procedure" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">The `FindMatch` Procedure</a></li>
                        <li><a href="#interactive-sim" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">Interactive Resolver</a></li>
                        <li><a href="#quiz" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">Knowledge Check</a></li>
                    </ul>
                </nav>
            </aside>

        <!-- Main Content -->
        <main id="main-content" class="flex-1 p-6 md:p-10 lg:p-12 bg-slate-50 min-h-screen lg:h-screen lg:overflow-y-auto">
            <div class="max-w-4xl mx-auto">

                <!-- Introduction Section -->
                <section id="intro" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">Connecting the Dots 🔗</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        We've used our paragraph dataset for many tasks, but now we'll tackle a problem from the field of natural language processing: <strong>pronoun resolution</strong>. This is the task of figuring out which noun a pronoun (like "he", "she", "it", or "they") refers to.
                    </p>
                    <p class="text-lg text-slate-700">
                        This is something humans do automatically, but for a computer, it requires a specific, logical procedure. We'll design a procedure to solve a simplified version of this problem.
                    </p>
                </section>

                <!-- The Challenge Section -->
                <section id="challenge" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">The Challenge: Who is "He"?</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        Consider this sentence from our text:
                    </p>
                    <div class="bg-white p-4 rounded-lg shadow italic text-center">
                        "...Swaminathan was reluctant to open his eyes. <strong>He</strong> considered Monday specially unpleasant..."
                    </div>
                    <p class="text-lg text-slate-700 mt-4">
                        We instantly know that "He" refers to Swaminathan. How can we teach a computer to make this same connection? We need an algorithm that can look at the context of the pronoun.
                    </p>
                </section>

                <!-- The Algorithm Section -->
                <section id="algorithm" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">The Backward Search Algorithm</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        A simple and often effective heuristic (a rule of thumb) for pronoun resolution is to find the <strong>nearest preceding noun</strong> that matches the pronoun's properties (like gender).
                    </p>
                    <div class="bg-sky-100 border-l-4 border-sky-500 text-sky-800 p-4 rounded-r-lg my-6">
                        <h4 class="font-semibold">The Algorithm:</h4>
                        <ol class="list-decimal list-inside mt-2">
                            <li><strong>Identify the Pronoun:</strong> Find the pronoun you want to resolve (e.g., "He").</li>
                            <li><strong>Split the Text:</strong> Divide the text into two parts: everything *before* the pronoun and everything *after* it.</li>
                            <li><strong>Iterate Backward:</strong> Starting from the word immediately before the pronoun, iterate backward through the "before" text.</li>
                            <li><strong>Check Each Word:</strong> For each word, check if it is a noun (or more specifically, a personal noun/name).</li>
                            <li><strong>Find the First Match:</strong> The first noun you encounter is your answer. Stop the search and return that noun.</li>
                        </ol>
                    </div>
                </section>
                
                <!-- The Procedure Section -->
                <section id="procedure" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">The `FindMatch` Procedure</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        This logic can be encapsulated in a procedure. This is a good example of a procedure where we must be careful about <strong>side effects</strong>. The procedure should analyze the text without changing the order of the words.
                    </p>
                    <div class="code-block">
<span class="code-keyword">Procedure</span> <span class="code-proc">FindMatch</span>(<span class="code-variable">before_text</span>, <span class="code-variable">pronoun</span>) {
  <span class="code-comment">// Iterate backward through the 'before_text' list</span>
  <span class="code-keyword">for each</span> word <span class="code-keyword">in reverse order of</span> before_text {
    <span class="code-comment">// A real system would check gender, etc.</span>
    <span class="code-keyword">if</span> (word.PartOfSpeech == "Noun") {
      <span class="code-keyword">return</span>(word) <span class="code-comment">// Found the match, return it and stop.</span>
    }
  }
  <span class="code-keyword">return</span>("Not Found") <span class="code-comment">// No matching noun found</span>
}
                    </div>
                </section>

                <!-- Interactive Simulator Section -->
                <section id="interactive-sim" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">⚙️ Interactive Pronoun Resolver</h2>
                    <p class="text-lg text-slate-700 mb-6">
                        Click "Resolve Pronoun" to see the backward search algorithm in action. The simulator will highlight the pronoun, then step backward through the preceding words until it finds the first noun.
                    </p>
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <div class="flex justify-center space-x-4 mb-4">
                            <button id="start-sim-btn" class="px-6 py-2 bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:bg-sky-700">Resolve Pronoun</button>
                            <button id="reset-sim-btn" class="px-6 py-2 bg-slate-500 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600">Reset</button>
                        </div>
                        <div id="sim-status" class="text-center font-semibold text-lg h-8 mb-4 text-slate-700">Press the button to start.</div>
                        <div id="sentence-container" class="text-2xl p-4 bg-slate-100 rounded-lg text-center leading-relaxed">
                        </div>
                    </div>
                </section>
                
                <!-- Quiz Section -->
                <section id="quiz">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">🧠 Knowledge Check</h2>
                    <p class="text-lg text-slate-700 mb-8">
                        Test your understanding of the pronoun resolution procedure.
                    </p>
                    <div id="quiz-container" class="space-y-8"></div>
                </section>

            </div>
        </main>
    </div>

    <script>
        // --- Sidebar and Scroll Logic ---
        const hamburgerBtn = document.getElementById('hamburger-btn');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('main-content');
        const navLinks = document.getElementById('nav-links');

        hamburgerBtn.addEventListener('click', () => sidebar.classList.toggle('-translate-x-full'));
        navLinks.addEventListener('click', (e) => {
            if (e.target.tagName === 'A' && window.innerWidth < 1024) {
                sidebar.classList.add('-translate-x-full');
            }
        });
        
        const sections = document.querySelectorAll('section');
        const links = document.querySelectorAll('.sidebar-link');
        mainContent.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                if (mainContent.scrollTop >= section.offsetTop - 100) {
                    current = section.getAttribute('id');
                }
            });
            links.forEach(link => {
                link.classList.toggle('active', link.getAttribute('href') === `#${current}`);
            });
        });

        // --- Interactive Simulator Logic ---
        const startSimBtn = document.getElementById('start-sim-btn');
        const resetSimBtn = document.getElementById('reset-sim-btn');
        const simStatus = document.getElementById('sim-status');
        const sentenceContainer = document.getElementById('sentence-container');
        
        const sentence = [
            { word: 'Swaminathan', type: 'Noun' }, { word: 'was', type: 'Verb' },
            { word: 'reluctant', type: 'Adjective' }, { word: 'to', type: 'Preposition' },
            { word: 'open', type: 'Verb' }, { word: 'his', type: 'Pronoun' },
            { word: 'eyes.', type: 'Noun' }, { word: 'He', type: 'Pronoun' },
            { word: 'considered', type: 'Verb' }, { word: 'Monday', type: 'Noun' }
        ];
        const pronounIndex = 7;

        function renderSentence(states = {}) {
            sentenceContainer.innerHTML = sentence.map((item, index) => {
                let className = 'word';
                if (index === pronounIndex) className += ' pronoun';
                if (states.searchingIndex === index) className += ' searching';
                if (states.matchIndex === index) className += ' match';
                return `<span id="word-${index}" class="${className}">${item.word}</span>`;
            }).join(' ');
        }

        function resetSimulator() {
            simStatus.textContent = "Press 'Resolve Pronoun' to start.";
            renderSentence();
            startSimBtn.disabled = false;
        }

        async function runSimulation() {
            startSimBtn.disabled = true;
            simStatus.textContent = `Resolving pronoun: "${sentence[pronounIndex].word}"`;
            
            for (let i = pronounIndex - 1; i >= 0; i--) {
                renderSentence({ searchingIndex: i });
                simStatus.textContent = `Checking "${sentence[i].word}"... Is it a noun?`;
                await new Promise(r => setTimeout(r, 800));
                
                if (sentence[i].type === 'Noun') {
                    simStatus.textContent = `Match found! "${sentence[pronounIndex].word}" refers to "${sentence[i].word}".`;
                    renderSentence({ matchIndex: i });
                    return;
                }
            }
            simStatus.textContent = "No matching noun found.";
        }

        startSimBtn.addEventListener('click', runSimulation);
        resetSimBtn.addEventListener('click', resetSimulator);
        resetSimulator();
        
        // --- Quiz Logic ---
        const quizContainer = document.getElementById('quiz-container');
        const quizData = [
            { question: "Does the “Paragraphwords” dataset provide the information of personal nouns/pronouns to resolve pronoun with its equivalent matching noun?", options: ["Yes", "No"], correct: ["No"], type: "single", explanation: "The dataset provides a general 'Part of Speech' like Noun or Pronoun, but does not specify if a noun is a personal name (like Swaminathan) or if a pronoun is personal (like 'he'). This extra information would be needed for a more advanced resolution algorithm." }
        ];

        function buildQuiz() {
            quizContainer.innerHTML = '';
            quizData.forEach((q, index) => {
                const optionsHtml = q.options.map(option => `
                    <label class="quiz-option block p-3 border-2 border-slate-200 rounded-lg hover:bg-sky-50 cursor-pointer transition-colors">
                        <input type="radio" name="q${index}" value="${option}" class="mr-3">
                        ${option}
                    </label>
                `).join('');
                const questionHtml = `
                    <div class="bg-white p-6 rounded-xl shadow-sm">
                        <p class="text-lg font-semibold mb-4">${index + 1}. ${q.question}</p>
                        <div class="space-y-3" id="q${index}-options">${optionsHtml}</div>
                        <div id="feedback-${index}" class="feedback"></div>
                    </div>
                `;
                quizContainer.innerHTML += questionHtml;
            });
            quizData.forEach((q, index) => {
                document.getElementById(`q${index}-options`).addEventListener('change', () => handleAnswer(q, index));
            });
        }

        function handleAnswer(questionData, questionIndex) {
            const feedbackEl = document.getElementById(`feedback-${questionIndex}`);
            const inputs = document.querySelectorAll(`input[name="q${questionIndex}"]`);
            let selectedAnswers = [];
            inputs.forEach(input => {
                if (input.checked) selectedAnswers.push(input.value);
                input.disabled = true;
            });
            let isCorrect = selectedAnswers.length === 1 && selectedAnswers[0] === questionData.correct[0];
            
            inputs.forEach(input => {
                const label = input.parentElement;
                if (questionData.correct.includes(input.value)) {
                    label.classList.add('correct');
                } else if (input.checked) {
                    label.classList.add('incorrect');
                }
            });

            feedbackEl.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${questionData.explanation}`;
            feedbackEl.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
        }

        buildQuiz();
    </script>
</body>
</html>
