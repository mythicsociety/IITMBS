<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L4.2: The Birthday Paradox (Binning Approach)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .sidebar-link.active {
            background-color: #e0f2fe; /* sky-100 */
            color: #0c4a6e; /* sky-900 */
            font-weight: 600;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* slate-300 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* slate-400 */
        }
        .quiz-option.correct {
            background-color: #dcfce7; /* green-100 */
            border-color: #22c55e; /* green-500 */
        }
        .quiz-option.incorrect {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
        }
        .feedback {
            display: none;
            padding: 0.75rem;
            margin-top: 0.75rem;
            border-radius: 0.5rem;
        }
        .feedback.correct {
            display: block;
            background-color: #f0fdf4; /* green-50 */
            color: #15803d; /* green-800 */
        }
        .feedback.incorrect {
            display: block;
            background-color: #fef2f2; /* red-50 */
            color: #b91c1c; /* red-800 */
        }
        .birthday-bin {
            min-height: 80px;
        }
        .person-card {
            transition: all 0.3s ease-in-out;
        }
        .person-card.comparing {
            transform: scale(1.1);
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
        .person-card.match {
            border-color: #22c55e; /* green-500 */
            background-color: #dcfce7; /* green-100 */
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Mobile Header with Hamburger Menu -->
    <header class="bg-white/80 backdrop-blur-lg shadow-sm sticky top-0 z-40 lg:hidden flex items-center justify-between p-4">
        <h1 class="text-lg font-bold text-sky-800">Learning Guide</h1>
        <button id="hamburger-btn" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
        </button>
    </header>

    <div class="flex">
        <!-- Sidebar Navigation -->
        <aside id="sidebar" class="bg-white w-64 fixed inset-y-0 left-0 transform -translate-x-full lg:translate-x-0 lg:sticky lg:top-0 h-screen transition-transform duration-300 ease-in-out z-50 shadow-lg lg:shadow-none border-r border-slate-200">
            <div class="p-6">
                <h2 class="text-xl font-bold text-sky-800 mb-6">L4.2: The Binning Approach</h2>
                <nav>
                    <ul id="nav-links" class="space-y-2">
                        <li><a href="#intro" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">Introduction</a></li>
                        <li><a href="#inefficiency" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">The Inefficiency Problem</a></li>
                        <li><a href="#binning" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">The Binning Strategy</a></li>
                        <li><a href="#algorithm" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">The Two-Pass Algorithm</a></li>
                        <li><a href="#interactive-sim" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">Interactive Simulator</a></li>
                        <li><a href="#quiz" class="sidebar-link block px-4 py-2 rounded-md text-slate-600 hover:bg-sky-50 transition-colors">Knowledge Check</a></li>
                    </ul>
                </nav>
            </aside>

        <!-- Main Content -->
        <main id="main-content" class="flex-1 p-6 md:p-10 lg:p-12 bg-slate-50 min-h-screen lg:h-screen lg:overflow-y-auto">
            <div class="max-w-4xl mx-auto">

                <!-- Introduction Section -->
                <section id="intro" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">Working Smarter, Not Harder</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        In the last section, we saw how nested loops provide a straightforward "naive" solution to the birthday problem. It works, but it's not very efficient, especially as the number of people grows.
                    </p>
                    <p class="text-lg text-slate-700">
                        This section introduces a much smarter strategy called <strong>binning</strong>. By pre-sorting our data into groups, we can dramatically reduce the number of comparisons we need to make, leading to a much faster algorithm.
                    </p>
                </section>

                <!-- Inefficiency Section -->
                <section id="inefficiency" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">The Inefficiency of the Naive Approach</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        The problem with comparing every person to every other person is that the number of comparisons grows quadratically. For N people, we need roughly N¬≤/2 comparisons.
                    </p>
                    <ul class="list-disc list-inside space-y-3 text-lg text-slate-700">
                        <li>For 10 people: ~50 comparisons</li>
                        <li>For 23 people: 253 comparisons</li>
                        <li>For 100 people: ~5000 comparisons!</li>
                    </ul>
                    <p class="text-lg text-slate-700 mt-4">
                        Most of these comparisons are pointless. Why compare someone born in January with someone born in December? They can't possibly share a birthday. We can use this logic to eliminate unnecessary work.
                    </p>
                </section>

                <!-- Binning Section -->
                <section id="binning" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">The Binning Strategy</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        <strong>Binning</strong> is the process of sorting data into groups (or "bins") based on a shared attribute. For the birthday problem, the most logical attribute to bin by is the month of birth.
                    </p>
                    <div class="bg-sky-100 border-l-4 border-sky-500 text-sky-800 p-4 rounded-r-lg my-6">
                        <p class="font-semibold">The Core Idea:</p>
                        <p>If two people share a birthday, they must have been born in the same month. Therefore, we only need to check for shared birthdays *within* each month's bin. We never need to compare someone from the January bin with someone from the February bin.</p>
                    </div>
                     <p class="text-lg text-slate-700">
                        Furthermore, if a bin ends up with only one person (or zero people), we know there can't be a match in that bin, so we can ignore it completely! This drastically reduces the number of comparisons.
                    </p>
                </section>
                
                <!-- The Algorithm Section -->
                <section id="algorithm" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">The Two-Pass Algorithm</h2>
                    <p class="text-lg text-slate-700 mb-4">
                        This more efficient approach requires two passes over the data:
                    </p>
                    <ol class="list-decimal list-inside space-y-4 text-lg text-slate-700">
                        <li>
                            <strong>Pass 1: Binning.</strong> We perform a single iteration through all the student cards. For each card, we look at the birth month and place the card into the corresponding bin (e.g., a "January" pile, a "February" pile, etc.). This takes N steps.
                        </li>
                        <li>
                            <strong>Pass 2: Nested Iteration on Bins.</strong> Now, we go through our 12 month bins. For each bin that contains <strong>two or more people</strong>, we run our original nested loop (pairwise comparison) *only on the people in that bin*.
                        </li>
                    </ol>
                </section>

                <!-- Interactive Simulator Section -->
                <section id="interactive-sim" class="mb-12">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">‚öôÔ∏è Binning Simulator</h2>
                    <p class="text-lg text-slate-700 mb-6">
                        This simulator demonstrates the binning approach.
                        <br><strong>Step 1:</strong> Click "Bin People" to sort the randomly generated people into their birth month bins.
                        <br><strong>Step 2:</strong> Click "Find Match" to run the efficient comparison only on the bins that need it.
                    </p>
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <div class="flex justify-center space-x-4 mb-4">
                            <button id="bin-btn" class="px-6 py-2 bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:bg-sky-700">Step 1: Bin People</button>
                            <button id="match-btn" class="px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700" disabled>Step 2: Find Match</button>
                            <button id="reset-sim-btn" class="px-6 py-2 bg-slate-500 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600">Reset</button>
                        </div>
                        <div id="sim-status" class="text-center font-semibold text-lg h-8 mb-4 text-slate-700">Press 'Bin People' to start.</div>
                        <div id="bins-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"></div>
                    </div>
                </section>
                
                <!-- Quiz Section -->
                <section id="quiz">
                    <h2 class="text-3xl font-bold text-sky-900 mb-4 border-b-2 border-sky-200 pb-2">üß† Knowledge Check</h2>
                    <p class="text-lg text-slate-700 mb-8">
                        Test your understanding of the binning strategy.
                    </p>
                    <div id="quiz-container" class="space-y-8"></div>
                </section>

            </div>
        </main>
    </div>

    <script>
        // --- Sidebar and Scroll Logic ---
        const hamburgerBtn = document.getElementById('hamburger-btn');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('main-content');
        const navLinks = document.getElementById('nav-links');

        hamburgerBtn.addEventListener('click', () => sidebar.classList.toggle('-translate-x-full'));
        navLinks.addEventListener('click', (e) => {
            if (e.target.tagName === 'A' && window.innerWidth < 1024) {
                sidebar.classList.add('-translate-x-full');
            }
        });
        
        const sections = document.querySelectorAll('section');
        const links = document.querySelectorAll('.sidebar-link');
        mainContent.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                if (mainContent.scrollTop >= section.offsetTop - 100) {
                    current = section.getAttribute('id');
                }
            });
            links.forEach(link => {
                link.classList.toggle('active', link.getAttribute('href') === `#${current}`);
            });
        });

        // --- Interactive Simulator Logic ---
        const binBtn = document.getElementById('bin-btn');
        const matchBtn = document.getElementById('match-btn');
        const resetSimBtn = document.getElementById('reset-sim-btn');
        const simStatus = document.getElementById('sim-status');
        const binsContainer = document.getElementById('bins-container');
        
        let people = [];
        let bins = {};
        const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        function createPerson(id) {
            const day = Math.floor(Math.random() * 28) + 1;
            const monthIndex = Math.floor(Math.random() * 12);
            return { id: id, birthday: `${day}-${MONTHS[monthIndex]}`, month: MONTHS[monthIndex] };
        }

        function renderBins(highlightBin = null, comparingIds = [], matchIds = []) {
            binsContainer.innerHTML = '';
            MONTHS.forEach(month => {
                const binEl = document.createElement('div');
                binEl.className = `birthday-bin p-2 rounded-lg bg-slate-100 border-2 ${highlightBin === month ? 'border-sky-500' : 'border-slate-200'}`;
                let peopleHTML = (bins[month] || []).map(p => {
                    let personClass = 'person-card p-1 text-xs rounded bg-white shadow border-2 border-transparent';
                    if (comparingIds.includes(p.id)) personClass += ' comparing';
                    if (matchIds.includes(p.id)) personClass += ' match';
                    return `<div id="person-${p.id}" class="${personClass}">${p.birthday}</div>`;
                }).join('');
                binEl.innerHTML = `<h4 class="font-bold text-center text-sm mb-2">${month}</h4><div class="flex flex-wrap gap-1">${peopleHTML}</div>`;
                binsContainer.appendChild(binEl);
            });
        }

        function resetSimulator() {
            people = Array.from({length: 25}, (_, i) => createPerson(i));
            bins = {};
            renderBins();
            simStatus.textContent = "Press 'Bin People' to start.";
            simStatus.classList.remove('text-green-700');
            binBtn.disabled = false;
            matchBtn.disabled = true;
        }

        binBtn.addEventListener('click', () => {
            binBtn.disabled = true;
            simStatus.textContent = "Binning people by month...";
            people.forEach(p => {
                if (!bins[p.month]) bins[p.month] = [];
                bins[p.month].push(p);
            });
            setTimeout(() => {
                renderBins();
                simStatus.textContent = "Binning complete. Ready to find matches.";
                matchBtn.disabled = false;
            }, 1000);
        });
        
        async function runMatching() {
            matchBtn.disabled = true;
            for (const month of MONTHS) {
                const peopleInBin = bins[month] || [];
                if (peopleInBin.length > 1) {
                    renderBins(month);
                    for (let i = 0; i < peopleInBin.length; i++) {
                        for (let j = i + 1; j < peopleInBin.length; j++) {
                            const p1 = peopleInBin[i];
                            const p2 = peopleInBin[j];
                            simStatus.textContent = `Comparing in ${month}: ${p1.birthday} vs ${p2.birthday}`;
                            renderBins(month, [p1.id, p2.id]);
                            await new Promise(r => setTimeout(r, 200));
                            if (p1.birthday === p2.birthday) {
                                simStatus.textContent = `Match found in ${month}!`;
                                simStatus.classList.add('text-green-700');
                                renderBins(month, [], [p1.id, p2.id]);
                                return;
                            }
                        }
                    }
                }
            }
            simStatus.textContent = "No matches found in any bin.";
            renderBins();
        }

        matchBtn.addEventListener('click', runMatching);
        resetSimBtn.addEventListener('click', resetSimulator);
        resetSimulator();
        
        // --- Quiz Logic ---
        const quizContainer = document.getElementById('quiz-container');
        const quizData = [
            { question: "What are possible binning strategies to find pairs of students with the same date of birth? (MSQ)", options: ["Bin by month of birth", "Bin by day of birth", "Bin by City/Town", "Bin by range of total marks"], correct: ["Bin by month of birth", "Bin by day of birth"], type: "multiple", explanation: "Binning by month or day are both valid strategies, as people must share a month (or day) to share a full birthday. City and marks are irrelevant." },
            { question: "True or False: If a bin has at most one card, then there is no need to iterate that bin.", options: ["True", "False"], correct: ["True"], type: "single", explanation: "True. A shared birthday requires at least two people. If a bin has 0 or 1 person, no comparison is needed." },
            { question: "True or False: One iteration is sufficient to bin the cards.", options: ["True", "False"], correct: ["True"], type: "single", explanation: "True. The binning process involves a single pass through all the cards, placing each one into its appropriate bin." },
            { question: "True or False: We can solve the birthday paradox problem after binning, in one iteration.", options: ["True", "False"], correct: ["False"], type: "single", explanation: "False. After the first iteration for binning, a second set of (nested) iterations is required to perform the pairwise comparisons within the populated bins." },
            { question: "What is the main advantage of binning?", options: ["It reduces the number of comparisons.", "It avoids nested iterations.", "Binning has no advantage."], correct: ["It reduces the number of comparisons."], type: "single", explanation: "Binning drastically reduces the total number of pairwise comparisons by eliminating the need to compare items from different, incompatible bins." },
            { question: "If we bin 100 people by month, and the 'May' bin contains 10 people, how many comparisons are needed just for the 'May' bin?", options: ["10", "100", "45", "90"], correct: ["45"], type: "single", explanation: "Using the formula N*(N-1)/2 for the 10 people in the May bin, we get 10 * 9 / 2 = 45 comparisons." }
        ];

        function buildQuiz() {
            quizContainer.innerHTML = '';
            quizData.forEach((q, index) => {
                const isMultiple = q.type === 'multiple';
                const inputType = isMultiple ? 'checkbox' : 'radio';
                const optionsHtml = q.options.map(option => `
                    <label class="quiz-option block p-3 border-2 border-slate-200 rounded-lg hover:bg-sky-50 cursor-pointer transition-colors">
                        <input type="${inputType}" name="q${index}" value="${option}" class="mr-3">
                        ${option}
                    </label>
                `).join('');
                const questionHtml = `
                    <div class="bg-white p-6 rounded-xl shadow-sm">
                        <p class="text-lg font-semibold mb-4">${index + 1}. ${q.question}</p>
                        <div class="space-y-3" id="q${index}-options">${optionsHtml}</div>
                        <div id="feedback-${index}" class="feedback"></div>
                    </div>
                `;
                quizContainer.innerHTML += questionHtml;
            });
            quizData.forEach((q, index) => {
                document.getElementById(`q${index}-options`).addEventListener('change', () => handleAnswer(q, index));
            });
        }

        function handleAnswer(questionData, questionIndex) {
            const feedbackEl = document.getElementById(`feedback-${questionIndex}`);
            const inputs = document.querySelectorAll(`input[name="q${questionIndex}"]`);
            let selectedAnswers = [];
            inputs.forEach(input => {
                if (input.checked) selectedAnswers.push(input.value);
                input.disabled = true;
            });
            let isCorrect;
            if (questionData.type === 'multiple') {
                 isCorrect = selectedAnswers.length === questionData.correct.length && selectedAnswers.every(val => questionData.correct.includes(val));
            } else {
                isCorrect = selectedAnswers.length === 1 && selectedAnswers[0] === questionData.correct[0];
            }
            
            inputs.forEach(input => {
                const label = input.parentElement;
                if (questionData.correct.includes(input.value)) {
                    label.classList.add('correct');
                } else if (input.checked) {
                    label.classList.add('incorrect');
                }
            });

            feedbackEl.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${questionData.explanation}`;
            feedbackEl.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
        }

        buildQuiz();
    </script>
</body>
</html>
