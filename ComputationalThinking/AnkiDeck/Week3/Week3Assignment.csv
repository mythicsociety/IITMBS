"Front";"Back";"Extra"
"In the ""Shopping Bills"" dataset, the procedure countBills counts the number of bills from Big Bazaar with total amount more than the average total bill amount. Assume that the variable Avg holds the value of the average total bill amount. Choose the correct code fragments to complete the procedure. Select all that apply.<br>Procedure countBills()<br>{<br>  Count = 0<br>  while(Pile 1 has more cards){<br>    Read the top card x from Pile 1<br>    ** Fill the code **<br>    Move card x to Pile 2<br>  }<br>  return(Count)<br>}<br>End countBills<ul><li>a) if(x.ShopName == ""BigBazaar"") {<br>  if(x.TotalBillAmount > Avg) {<br>    Count = Count + 1<br>  }<br>}</li><li>b) if(x.TotalBillAmount > Avg) {<br>  if (x.ShopName == ""BigBazaar"") {<br>    Count = Count + 1<br>  }<br>}</li><li>c) if(x.TotalBillAmount > Avg and x.ShopName == ""BigBazaar"") {<br>  Count = Count + 1<br>}</li><li>d) if (x.TotalBillAmount < Avg and x.ShopName == ""BigBazaar"") {<br> Count = Count + 1<br>}</li></ul>";"Correct: a), b), c)";"<b>Explanation:</b> The goal is to count bills that satisfy two conditions: the shop is ""BigBazaar"" AND the total bill amount is greater than the average (Avg). Options a, b, and c all correctly implement this logic. Option 'a' checks for the shop first, then the amount. Option 'b' checks for the amount first, then the shop. Option 'c' checks both conditions simultaneously using an 'and' operator.<br><b>Distractor Rationale:</b><ul><li>d) This option is incorrect because it uses a 'less than' (<) comparison for the bill amount, which is the opposite of the requirement.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. What will be the value of the variable Z at the end of the execution?<br>SumT = 0, SumM = 0, SumP = 0, SumC = 0<br>while (Pile 1 has more cards) {<br>  Read the top card x from Pile 1<br>  SumT = SumT + x.Total<br>  SumM = SumM + x.Mathematics<br>  SumP = SumP + x.Physics<br>  SumC = SumC + x.Chemistry<br>  Move card X to Pile 2<br>}<br>Z = 0<br>if ((SumM + SumP + SumC) / SumT >= 0) {<br>  Z = 1<br>}<br>if ((SumM + SumP + SumC) / SumT <= 1) {<br>  Z = -1<br>}<ul><li>a) 0</li><li>b) 1</li><li>c) -1</li><li>d) None of the above</li></ul>";"Correct: c)";"<b>Explanation:</b> In the ""Scores"" dataset, the Total marks (x.Total) for any student is the sum of their marks in Mathematics, Physics, and Chemistry. Therefore, after the first while loop, SumT will be equal to the sum of SumM, SumP, and SumC. The expression (SumM + SumP + SumC) / SumT will always evaluate to 1. The first 'if' condition (1 >= 0) is true, setting Z to 1. The second 'if' condition (1 <= 1) is also true, which then updates Z to -1.<br><b>Distractor Rationale:</b><ul><li>a) Z is initialized to 0, but it is updated by both 'if' statements.</li><li>b) Z is set to 1 by the first 'if' statement, but it is immediately updated to -1 by the second 'if' statement.</li><li>d) A correct value can be determined by tracing the code's logic.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. At the end of the execution, variable Count captures the number of students whose total marks are more than the class average (AvgT) but have scored below the subject average in at least one subject. Choose the correct code fragment to complete the pseudocode.<br>Count = 0<br>while (Table 1 has more rows) {<br>  Read the first row X from Table 1<br>  A = False, B = False, C = False, D = False<br>  if(X.Total > AvgT) { A = True }<br>  if (x.Mathematics < AvgM) { B = True }<br>  if(X.Physics < AvgP) { C = True }<br>  if(x.Chemistry < AvgC) { D = True }<br>  ** Fill the code **<br>  Move X to Table 2<br>}<ul><li>a) if (A and (B or C or D)) {<br>  Count = Count + 1<br>}</li><li>b) if((A or B) and (C or D)) {<br>  Count = Count + 1<br>}</li><li>c) if((A and B) and (C or D)) {<br>  Count = Count + 1<br>}</li><li>d) if((A and B) or (C and D)) {<br>  Count = Count + 1<br>}</li></ul>";"Correct: a)";"<b>Explanation:</b> The variable 'A' becomes True if a student's total marks are above average. Variables 'B', 'C', and 'D' become True if the student's marks in Mathematics, Physics, or Chemistry, respectively, are below average. The requirement is to count students where their total marks are above average ('A' is True) AND they are below average in at least one subject ('B' is True OR 'C' is True OR 'D' is True). The expression 'A and (B or C or D)' correctly represents this logic.<br><b>Distractor Rationale:</b><ul><li>b) This condition checks for (above average total OR below in Math) AND (below in Physics OR below in Chem), which is not the required logic.</li><li>c) This checks for (above average total AND below in Math) AND (below in Physics OR below in Chem), which is too restrictive.</li><li>d) This checks for (above average total AND below in Math) OR (below in Physics AND below in Chem), which is also incorrect.</li></ul>"
"The following pseudocode is executed using the ""Shopping bills"" dataset. What will the values of the variables A and B represent at the end of the execution?<br>SumSV = 0, CountSV = 0, SumBB = 0, CountBB = 0<br>while (Pile 1 has more cards) {<br>  Read the top card x from Pile 1<br>  if (x.ShopName == ""SV Stores"") {<br>    SumSV = SumSV + x.TotalBillAmount<br>    CountSV = CountSV + 1<br>  }<br>  if(x.ShopName == ""Big Bazaar"") {<br>    SumBB = SumBB + x.TotalBillAmount<br>    CountBB = CountBB + 1<br>  }<br>  Move card X to Pile 2<br>}<br>MSV = SumSV / CountSV<br>MBB = SumBB / CountBB<br>A = 0, B = 0<br>while (Pile 2 has more cards) {<br>  Read the top card x from Pile 2<br>  if (x.ShopName == ""SV Stores"" and x.TotalBillAmount > MSV) {<br>    A = A + 1<br>  }<br>  if (x.ShopName == ""Big Bazaar"" and x.TotalBillAmount < MBB) {<br>    B = B + 1<br>  }<br>  Move card X to Pile 1<br>}<ul><li>a) A = Number of bills from ""Big Bazaar""... B = Number of bills from ""SV Stores""...</li><li>b) A = Number of bills from ""SV Stores"" with total bill amount greater than the average total bill amount of ""SV Stores"". B = Number of bills from ""Big Bazaar"" with total bill amount less than the average total bill amount of ""Big Bazaar"".</li><li>c) A = Number of bills from ""SV Stores""... B = Number of bills from ""Big Bazaar""...</li><li>d) A = Number of bills with total bill amount greater than the average... B = Number of bills with total bill amount less than the average...</li></ul>";"Correct: b)";"<b>Explanation:</b> The first loop calculates the average bill amount for ""SV Stores"" (MSV) and ""Big Bazaar"" (MBB). The second loop iterates through the bills again. It increments 'A' for each ""SV Stores"" bill where the amount is greater than the average for ""SV Stores"" (MSV). It increments 'B' for each ""Big Bazaar"" bill where the amount is less than the average for ""Big Bazaar"" (MBB).<br><b>Distractor Rationale:</b><ul><li>a) This swaps the logic for A and B.</li><li>c) This incorrectly describes the conditions for both A and B.</li><li>d) This generalizes the logic, ignoring the specific shop names which are part of the conditions.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. Assume AvgP = 73. What will be the value of CountA at the end of the execution?<br>AvgP = 73<br>Mid2 = 1.25 * AvgP<br>Mid1 = 0.75 * AvgP<br>CountA = 0, CountB = 0, CountC = 0, CountD = 0<br>while (Pile 1 has more cards) {<br>  Read the top card x from Pile 1<br>  if(x.Gender == 'F'){<br>    if(x.Physics >= Mid2) {<br>      CountA = CountA + 1<br>    }<br>    if(x.Physics < Mid2 and x.Physics >= AvgP) {<br>      CountB = CountB + 1<br>    }<br>    if(x.Physics < AvgP and x.Physics >= Mid1) {<br>      CountC = CountC + 1<br>    }<br>    if(x.Physics < Mid1) {<br>      CountD = CountD + 1<br>    }<br>  }<br>  Move card X to Pile 2<br>}<ul><li>a) 1</li><li>b) 2</li><li>c) 3</li><li>d) 7</li></ul>";"Correct: b)";"<b>Explanation:</b> First, calculate Mid2: 1.25 * 73 = 91.25. The code iterates through the 'Scores' dataset, considering only female students (x.Gender == 'F'). The variable CountA is incremented only when a female student's Physics score is greater than or equal to 91.25. Based on the provided solution, two female students (from cards 5 and 18) meet this criterion.<br><b>Distractor Rationale:</b><ul><li>a) This count is too low.</li><li>c) This is the value for CountB.</li><li>d) This is the value for CountC.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. What will count represent at the end of execution?<br>count = 0<br>while (Table 1 has more rows) {<br>  Read the first row X in Table 1<br>  Move the row X to Table 2<br>  while (Table 1 has more rows) {<br>    Read the first row Y in Table 1<br>    count = count + compareSomething(X.Total, Y.Total)<br>    count = count + compareSomething(Y.Total, X.Total)<br>    Move the row Y to Table 3<br>  }<br>  Move all rows from Table 3 to Table 1<br>}<br>Procedure compareSomething(A, B)<br>  if(A > B) {<br>    return(-1)<br>  }<br>  else {<br>    return(1)<br>  }<br>End compareSomething<ul><li>a) Number of pairs of students who have different total marks</li><li>b) Number of pairs of students who have same total marks</li><li>c) Twice the number of pairs of students who have different total marks</li><li>d) Twice the number of pairs of students who have same total marks</li><li>e) It is always zero</li></ul>";"Correct: d)";"<b>Explanation:</b> The nested loops compare every student (X) with every other student (Y). Let's analyze the two calls to compareSomething for a pair (X, Y).<br>1. If X.Total > Y.Total: The first call returns -1, the second returns 1. The net change to count is 0.<br>2. If X.Total < Y.Total: The first call returns 1, the second returns -1. The net change to count is 0.<br>3. If X.Total == Y.Total: Both calls return 1. The net change to count is +2.<br>Therefore, count is incremented by 2 for every pair of students with the same total marks.<br><b>Distractor Rationale:</b><ul><li>a) Pairs with different marks result in a net change of 0 to the count.</li><li>b) The count is incremented by 2 for each pair with the same marks, not 1.</li><li>c) This is the opposite of the correct logic.</li><li>e) The count will only be zero if no students have the same total marks.</li></ul>"
"The following pseudocode is executed using the ""Shopping bills"" dataset to find the number of eligible bills for the lowest three total bill amounts. Choose the correct code fragment to complete the pseudocode.<br>FirstT = 10000, SecondT = 10000, ThirdT = 10000<br>while (Pile 1 has more cards) {<br>  Read the top card x from Pile 1<br>  if(x.TotalBillAmount < FirstT) { ... }<br>  if(x.TotalBillAmount > FirstT and x.TotalBillAmount < SecondT) { ... }<br>  if(x.TotalBillAmount > SecondT and x.TotalBillAmount < ThirdT) { ... }<br>  Move card X to Pile 2<br>}<br>Count = 0<br>while (Pile 2 has more cards) {<br>  Read the top card x from Pile 2<br>  ** Fill the code **<br>  Move card x to Pile 1<br>}<ul><li>a) if(x.TotalBillAmount < ThirdT) {<br>  Count = Count + 1<br>}</li><li>b) if(x.TotalBillAmount <= ThirdT) {<br>  Count = Count + 1<br>}</li><li>c) if(x.TotalBillAmount > ThirdT) {<br>  Count = Count + 1<br>}</li><li>d) if(x.TotalBillAmount >= ThirdT) {<br>  Count = Count + 1<br>}</li></ul>";"Correct: b)";"<b>Explanation:</b> The first loop correctly identifies the three lowest unique bill amounts and stores them in FirstT, SecondT, and ThirdT. The second loop needs to count all bills whose amounts are among these three lowest values. This means we need to count any bill where the TotalBillAmount is less than or equal to the third lowest amount (ThirdT). This includes the lowest, second lowest, and third lowest amounts themselves, as well as any duplicates.<br><b>Distractor Rationale:</b><ul><li>a) This misses bills that have an amount exactly equal to ThirdT.</li><li>c) This counts bills with amounts greater than the third lowest, which is the opposite of the goal.</li><li>d) This also counts bills with amounts greater than the third lowest.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. Let minTotal store the minimum total marks obtained by any student. What will the value of Flag be at the end of the execution?<br>A = 101, B = 101, C = 101, D = 101<br>Flag = False<br>while (Pile 1 has more cards) {<br>  Read the top card x from Pile 1<br>  A, B, C = doSomething(x, A, B, C)<br>  Move X to Pile 2<br>}<br>D = A + B + C<br>if((minTotal - D) >= 0) {<br>  Flag = True<br>}<br>Procedure doSomething(Y, A, B, C)<br>  if(Y.Mathematics < A) { A = Y.Mathematics }<br>  if(Y.Physics < B) { B = Y.Physics }<br>  if(Y.Chemistry < C) { C = Y.Chemistry }<br>  return([A, B, C])<br>End doSomething<ul><li>a) False</li><li>b) True</li><li>c) Cannot be determined</li></ul>";"Correct: b)";"<b>Explanation:</b> The doSomething procedure iterates through all cards and finds the minimum marks for Mathematics (A), Physics (B), and Chemistry (C) across the entire dataset. 'D' is the sum of these minimums (A+B+C). minTotal is the minimum total score achieved by any single student. The total score for any student is the sum of their marks in the three subjects. The sum of the minimums of each subject (D) must be less than or equal to the minimum of the sums (minTotal). Therefore, minTotal - D will always be greater than or equal to 0, setting Flag to True.<br><b>Distractor Rationale:</b><ul><li>a) The condition (minTotal - D) >= 0 will always be met.</li><li>c) The logic is deterministic and the outcome can be determined without the actual data.</li></ul>"
"The pseudocode is supposed to find the number of male students whose Mathematics marks are less than the average Mathematics marks of female students. Identify the line with an error.<br>1 Sum = 0, Count = 0<br>2 while(Pile 1 has more cards) {<br>3   Read the top card x in Pile 1<br>4   Sum, Count = addMarks(X, Sum, Count)<br>5   Move card X to Pile 2<br>6 }<br>7 AvgT = Sum / Count<br>8 CountM = 0<br>9 while(Pile 2 has more cards) {<br>10  Read the top card x in Pile 2<br>11  if(X.Mathematics < AvgT) {<br>12    CountM = CountM + 1<br>13  }<br>14  Move card X to Pile 1<br>15 }<br>16 Procedure addMarks(Y, SumF, CountF)<br>17  if(Y.Gender == 'F') {<br>18    SumF = SumF + Y.Mathematics<br>19    CountF = CountF + 1<br>20  }<br>21  return([SumF, CountF])<br>22 End addmarks<ul><li>a) Error in Line 4</li><li>b) Error in Line 11</li><li>c) Error in Line 17</li><li>d) Error in Line 18</li><li>e) Error in Line 21</li></ul>";"Correct: b)";"<b>Explanation:</b> The first loop and the addMarks procedure correctly calculate the average Mathematics marks for only female students (AvgT). The second loop is intended to count male students whose marks are below this average. However, Line 11 if(X.Mathematics < AvgT) only checks the marks condition and does not check if the student's gender is male (X.Gender == 'M'). As a result, it incorrectly counts all students (both male and female) whose math marks are below the female average.<br><b>Distractor Rationale:</b><ul><li>a) Line 4 correctly calls the procedure to update the sum and count.</li><li>c) Line 17 correctly filters for female students to calculate the average.</li><li>d) Line 18 correctly adds the mathematics marks for female students.</li><li>e) Line 21 correctly returns the updated sum and count.</li></ul>"
"What will A represent at the end of the execution of the following pseudocode using the ""Olympics"" dataset?<br>A = 0, B = 0<br>while (Table 1 has more rows) {<br>  Read the first row X in Table 1<br>  if(X.Year < 2005 or X.Year > 2008) {<br>    A = A + 1<br>  }<br>  else {<br>    if(X.Sport == ""Wrestling"") {<br>      B = B + 1<br>    }<br>  }<br>  Move X to Table 2<br>}<ul><li>a) Number of players who have won medal in the Year either after 2005 or before 2008</li><li>b) Number of players who have won medal in the Year either before 2005 or after 2008</li><li>c) Number of players who have won the medal in ""Wrestling"" in the Year 2005, 2006 and 2007.</li><li>d) Number of players other than wrestlers who have won medal in the Year either after 2005 or before 2008</li></ul>";"Correct: b)";"<b>Explanation:</b> The variable 'A' is incremented inside the 'if' block. The condition for this block is X.Year < 2005 or X.Year > 2008. This directly translates to counting the number of players who won a medal in a year that was either before 2005 OR after 2008.<br><b>Distractor Rationale:</b><ul><li>a) This option incorrectly uses ""after 2005"" (which would be > 2005) and ""before 2008"" (which would be < 2008). The logic is reversed.</li><li>c) This describes the condition for incrementing B, not A.</li><li>d) The condition for A does not exclude wrestlers.</li></ul>"
"What will B represent at the end of the execution of the following pseudocode using the ""Olympics"" dataset?<br>A = 0, B = 0<br>while (Table 1 has more rows) {<br>  Read the first row X in Table 1<br>  if(X.Year < 2005 or X.Year > 2008) {<br>    A = A + 1<br>  }<br>  else {<br>    if(X.Sport == ""Wrestling"") {<br>      B = B + 1<br>    }<br>  }<br>  Move X to Table 2<br>}<ul><li>a) Number of players who have won the medal in ""Wrestling"" the Year either after 2005 or before 2008</li><li>b) Number of players who have won the medal in ""Wrestling"" between 2005 and 2007 (end points are included)</li><li>c) Number of players who have won the medal in any other Sport except ""Wrestling"" in the Year 2005 to 2008</li><li>d) Number of players who have won the medal in ""Wrestling"" in the Year either before 2005 or after 2008</li></ul>";"Correct: b)";"<b>Explanation:</b> The variable 'B' is incremented inside the 'else' block. The 'else' block is executed when the condition X.Year < 2005 or X.Year > 2008 is false. This means the year must be >= 2005 AND <= 2008. The years that satisfy this are 2005, 2006, 2007, and 2008. Inside this 'else' block, there's a further condition: X.Sport == ""Wrestling"". Therefore, B counts wrestlers who won medals in the years 2005, 2006, 2007, or 2008. Option (b) is the closest description, although it omits 2008.<br><b>Distractor Rationale:</b><ul><li>a) This describes a condition related to the 'if' block for A, not the 'else' block for B.</li><li>c) This is incorrect; B specifically counts wrestlers, not players from other sports.</li><li>d) This is the same incorrect logic as option a.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. When will C be True?<br>A = 0, B = 0, C = False<br>while (Table 1 has more rows) {<br>  Read the first row X in Table 1<br>  if(X.Gender == 'F') {<br>    A = A + 1<br>  }<br>  else {<br>    if(X.CityTown == ""Erode"") {<br>      B = B + 1<br>    }<br>  }<br>  Move X to Table 2<br>}<br>if(A < B) {<br>  C = True<br>}<ul><li>a) If there exist less female students than male students from Erode</li><li>b) If there exist more female students than students from Erode</li><li>c) If there exist less Erode students than female students</li><li>d) If there exist more female students than male students</li></ul>";"Correct: a)";"<b>Explanation:</b> The variable 'A' counts the total number of female students. The 'else' block executes for students who are not female (i.e., male). Inside the 'else' block, 'B' is incremented only if the student's CityTown is ""Erode"". Therefore, 'B' counts the number of male students from Erode. The variable 'C' is set to True only if A < B, which means if the number of female students is less than the number of male students from Erode.<br><b>Distractor Rationale:</b><ul><li>b) This describes the condition A > B.</li><li>c) This incorrectly describes what B represents. B is not all students from Erode, only male students.</li><li>d) This incorrectly describes what B represents. B is not all male students, only those from Erode.</li></ul>"
"What will A represent at the end of the execution of the following pseudocode using the ""Scores"" dataset?<br>A = 0, count = 0<br>while(Table 1 has more rows) {<br>  Read the first row X in Table 1<br>  B = True<br>  count = count + 1<br>  if(X.Physics >= 90) { B = False }<br>  if(X.Chemistry >= 90) { B = False }<br>  if(X.Mathematics >= 90) { B = False }<br>  if(B == True) {<br>    A = A + 1<br>  }<br>  Move X to Table 2<br>}<ul><li>a) Number of students who have scored more than 90 marks in all subjects</li><li>b) Number of students who have scored less than 90 marks in exactly one subject</li><li>c) Number of students who have scored less than 90 marks in all subjects</li><li>d) Number of students who have scored at least 90 marks in all subjects</li></ul>";"Correct: c)";"<b>Explanation:</b> For each student, the variable 'B' is initialized to True. It is then set to False if the student scores 90 or more in Physics, OR Chemistry, OR Mathematics. The variable 'A' is only incremented if 'B' remains True at the end of these checks. 'B' will only remain True if the student did not score 90 or more in any of the three subjects. This is equivalent to saying the student scored less than 90 in all three subjects.<br><b>Distractor Rationale:</b><ul><li>a) This would require a different logic, likely using 'and' conditions to check if all scores are >= 90.</li><li>b) This would require more complex logic to count how many subjects are below 90.</li><li>d) This is the opposite of the correct logic.</li></ul>"
"The procedure countBills is intended to return True if a card Y's TotalBillAmount is greater than the average TotalBillAmount of its shop, and False otherwise. Identify all lines with mistakes.<br>1. Procedure countBills(Y, Pile 1)<br>2.   count = 1, avg = 0, amount = 0<br>3.   while (Pile 1 has more cards) {<br>4.     Read the top card X from Pile 1<br>5.     if (X.ShopName == Y.ShopName) {<br>6.       amount = amount + X.TotalBillAmount<br>7.       count = count + 1<br>8.     }<br>9.     Move card X to Pile 2<br>10.  }<br>11.  avg = amount / count<br>12.  if (X.TotalBillAmount > avg) {<br>13.    return(True)<br>14.  }<br>15.  return(False)<br>16. End countBills<ul><li>a) Line 2: Initialization of avg to 0 is incorrect</li><li>b) Line 2: Initialization of count to 1 is incorrect</li><li>c) Line 5: The condition to update amount is incorrect</li><li>d) Line 12: Condition checking statement is incorrect.</li></ul>";"Correct: b), d)";"<b>Explanation:</b> There are two errors. First, in Line 2, count is initialized to 1. It should be initialized to 0 to correctly count the number of bills from the specified shop. Second, in Line 12, the condition checks X.TotalBillAmount > avg. However, 'X' refers to the last card read from the pile inside the loop. The procedure is supposed to check the bill amount of the input card 'Y' against the calculated average. The correct condition should be if (Y.TotalBillAmount > avg).<br><b>Distractor Rationale:</b><ul><li>a) Initializing avg to 0 is acceptable as it is recalculated in Line 11 before being used.</li><li>c) Line 5 correctly compares the shop names to identify bills from the same shop as card Y.</li></ul>"
"What will A represent at the end of the execution of the following pseudocode using the ""Words"" dataset? avg stores the average letter count of all words.<br>A = 0, count = 0<br>while (Table 1 has more rows) {<br>  Read the first row X in Table 1<br>  B = 0<br>  if(X.PartOfSpeech == ""Pronoun"") { B = B + 1 }<br>  if(X.LetterCount > avg) { B = B + 1 }<br>  if(B == 0) {<br>    A = A + 1<br>  }<br>  Move X to Table 2<br>}<ul><li>a) Number of words which are pronouns and number of words with letter count greater than the average</li><li>b) Number of words which are not pronouns and number of words with letter count less than the average</li><li>c) Number of words which are not pronouns and number of words with letter count less than or equal to average letter count</li><li>d) Number of words which are pronouns and number of words with letter count equal to the average</li></ul>";"Correct: c)";"<b>Explanation:</b> 'A' is incremented only when B is equal to 0. 'B' is initialized to 0 for each word and is incremented if the word is a ""Pronoun"" or if its letter count is greater than the average. For 'B' to remain 0, both of these conditions must be false. The word must NOT be a ""Pronoun"" AND its letter count must NOT be greater than avg (i.e., it must be less than or equal to avg).<br><b>Distractor Rationale:</b><ul><li>a) This describes the case where B would be 2.</li><li>b) This is close, but misses the case where the letter count is exactly equal to the average.</li><li>d) This describes a mix of conditions that don't align with B being 0.</li></ul>"
"The condition to modify A is changed to if(B == 1). What will A represent now, using the same pseudocode structure as the previous question?<br>A = 0, count = 0<br>while(Table 1 has more rows) {<br>  Read the first row X in Table 1<br>  B = 0<br>  if(X.PartOfSpeech == ""Pronoun"") { B = B + 1 }<br>  if(X.LetterCount > avg) { B = B + 1 }<br>  if(B == 1) {<br>    A = A + 1<br>  }<br>  Move X to Table 2<br>}<ul><li>a) Number of words which are pronouns and number of words with letter count greater than the average</li><li>b) Number of words which are pronouns and number of words with letter count less than the average</li><li>c) Number of words that are either pronoun or have letter count less than the average letter count but not both</li><li>d) Number of words that are either pronouns or have letter count greater than the average letter count but not both</li></ul>";"Correct: d)";"<b>Explanation:</b> 'A' is now incremented when B is equal to 1. 'B' becomes 1 if exactly one of the two conditions is true: (1) the word is a ""Pronoun"" but its letter count is NOT greater than avg, OR (2) the word is NOT a ""Pronoun"" but its letter count IS greater than avg. This is a classic exclusive OR (XOR) situation. It counts words that are either pronouns or have a letter count greater than the average, but not both simultaneously.<br><b>Distractor Rationale:</b><ul><li>a) This describes the case where B would be 2.</li><li>b) This only describes one of the two possibilities for B being 1.</li><li>c) This incorrectly uses ""less than"" for the letter count condition.</li></ul>"
"The pseudocode is intended to count the number of male students who have scored above the subject average in at least two subjects. Choose the correct code fragment to complete the pseudocode. (MSQ)<br>A = 0<br>while (Table 1 has more rows) {<br>  B = 0<br>  Read the first row X from Table 1<br>  if(X.Gender == 'M') {<br>    if(X.Mathematics > M) { B = B + 1 }<br>    if(X.Physics > P) { B = B + 1 }<br>    if(X.Chemistry > C) { B = B + 1 }<br>  }<br>  ** Fill here **<br>  Move X to Table 2<br>}<ul><li>a) if(B >= 1) { A = A + 1 }</li><li>b) if(B <= 2) { A = A + 1 }</li><li>c) if(B < 3) { A = A + 1 }</li><li>d) if(B > 1) { A = A + 1 }</li></ul>";"Correct: d)";"<b>Explanation:</b> The variable 'B' counts how many subjects a male student has scored above average in. The requirement is to count students who are above average in ""at least two"" subjects. This means B must be 2 or 3. The condition if(B > 1) correctly checks for B being 2 or 3. The condition if(B >= 2) would also be correct.<br><b>Distractor Rationale:</b><ul><li>a) This would count students who scored above average in at least one subject.</li><li>b) This would incorrectly count students who scored above average in 0, 1, or 2 subjects.</li><li>c) This is similar to b, but excludes the case where B is 3.</li></ul>"
"The pseudocode calculates average bill amounts for SV Stores (MSV) and Big Bazaar (MBB). It then needs to count bills from SV Stores with amounts less than MBB (variable A) and bills from Big Bazaar with amounts greater than MSV (variable B). Choose the correct code fragment.<br>... (code to calculate MSV and MBB) ...<br>A = 0, B = 0<br>while(Pile 2 has more cards) {<br>  Read the top card X from Pile 2<br>  ** Fill Here **<br>  Move card X to Pile 1<br>}<ul><li>a) if(X.ShopName == ""SV Stores"" and X.TotalBillAmount < MBB) { A = A + 1 }<br>if(X.ShopName == ""Big Bazaar"" and X.TotalBillAmount > MSV) { B = B + 1 }</li><li>b) if(X.ShopName == ""SV Stores"" and X.TotalBillAmount < MBB) { B = B + 1 }<br>if(X.ShopName == ""Big Bazaar"" and X.TotalBillAmount > MSV) { A = A + 1 }</li><li>c) if(X.ShopName == ""SV Stores"" and X.TotalBillAmount > MSV) { A = A + 1 }<br>if(X.ShopName == ""Big Bazaar"" and X.TotalBillAmount > MBB) { B = B + 1 }</li><li>d) if(X.ShopName == ""SV Stores"" and X.TotalBillAmount > MSV) { B = B + 1 }<br>if(X.ShopName == ""Big Bazaar"" and X.TotalBillAmount > MBB) { A = A + 1 }</li></ul>";"Correct: a)";"<b>Explanation:</b> The problem statement requires two specific counts. For variable A: count bills where ShopName is ""SV Stores"" AND TotalBillAmount is less than MBB (Big Bazaar's average). For variable B: count bills where ShopName is ""Big Bazaar"" AND TotalBillAmount is greater than MSV (SV Stores' average). Option (a) correctly implements these two distinct conditional checks.<br><b>Distractor Rationale:</b><ul><li>b) This swaps the variables being incremented (A and B).</li><li>c) This checks against the wrong average for both conditions (e.g., SV Stores amount vs SV Stores average).</li><li>d) This swaps the variables and checks against the wrong averages.</li></ul>"
"What will A represent at the end of the execution of the following pseudocode using the ""Words"" dataset?<br>... (first loop calculates B = average letter count of all Verbs) ...<br>SumS = 0, CountS = 0, A = 0<br>while (Table 2 has more rows) {<br>  Read the first row X in Table 2<br>  CountS = CountS + 1<br>  SumS = SumS + X.LetterCount<br>  if(X.Word ends with a full stop) {<br>    C = SumS / CountS<br>    if(C < B) {<br>      A = A + 1<br>    }<br>    SumS = 0, CountS = 0<br>  }<br>  Move X to Table 1<br>}<ul><li>a) Number of sentences with average letter count more than the average letter count of verbs</li><li>b) Number of sentences with average letter count less than the average letter count of verbs</li><li>c) Number of words with average letter count more than the average letter count of verbs</li><li>d) Number of words with average letter count less than the average letter count of verbs</li></ul>";"Correct: b)";"<b>Explanation:</b> The first part of the code calculates 'B', the average letter count of all verbs. The second loop processes the text sentence by sentence, identified by a full stop. For each sentence, it calculates 'C', the average letter count of words in that sentence (SumS / CountS). 'A' is incremented whenever a sentence's average letter count ('C') is less than the average letter count of verbs ('B'). Therefore, 'A' counts the number of sentences with an average letter count less than the average verb letter count.<br><b>Distractor Rationale:</b><ul><li>a) This describes the condition C > B.</li><li>c) The code calculates averages per sentence, not per word.</li><li>d) The code calculates averages per sentence, not per word.</li></ul>"
"Which concept best describes organizing data from multiple student grade cards into a single structure with columns for ID, Name, Gender, Math, Physics, etc., and one row per student?<br><ul><li>a) Procedure</li><li>b) Side Effect</li><li>c) Table</li><li>d) Parameter</li></ul>";"Correct: c)";"<b>Explanation:</b> A table is the ideal data structure for this purpose. Each attribute or field from the card (like Name, Gender, Math score) becomes a column, and each individual card (representing a student) becomes a row. This creates a structured, uniform way to store and access the information.<br><b>Distractor Rationale:</b><ul><li>a) A procedure is a set of instructions to perform a task, not a data structure.</li><li>b) A side effect is an unintended modification of data by a procedure.</li><li>d) A parameter is a value passed to a procedure to customize its execution.</li></ul>"
"A procedure is written to find the student with the minimum total marks. Which of the following initializations for the variable MinVal is the most robust?<br>Procedure FindMinTotal()<br>  MinVal = ?<br>  while (Pile 1 has more cards) {<br>    Read card X from Pile 1<br>    if (X.Total < MinVal) {<br>      MinVal = X.Total<br>    }<br>    Move X to Pile 2<br>  }<br>  return(MinVal)<br>End Procedure<ul><li>a) MinVal = 0</li><li>b) MinVal = The total marks of the first card in the pile.</li><li>c) MinVal = 101 (assuming marks are out of 100 per subject, so max total is 300)</li><li>d) MinVal = 301 (assuming max total is 300)</li></ul>";"Correct: d)";"<b>Explanation:</b> To find a minimum value, the tracking variable (MinVal) must be initialized to a value that is guaranteed to be greater than any possible value in the dataset. Since the maximum possible total is 300, initializing MinVal to 301 ensures that the Total of the very first card will be less than MinVal, correctly starting the comparison process.<br><b>Distractor Rationale:</b><ul><li>a) Initializing to 0 is incorrect because if all student totals are positive, the condition X.Total < MinVal would never be true, and the procedure would wrongly return 0.</li><li>b) This is a valid strategy, but it requires special handling for the first card and is slightly less straightforward than initializing with a guaranteed high value.</li><li>c) 101 is not guaranteed to be higher than all possible total marks, as a student could score more than 101 in total.</li></ul>"
"A procedure SumMarks(gen, fld) returns the sum of marks for a given gender gen in a specific field fld. Which of the following are valid ways to use this procedure in pseudocode? Select all that apply.<ul><li>a) BoyPhysicsSum = SumMarks(M, Physics)</li><li>b) if (SumMarks(F, Total) > SumMarks(M, Total)) { Print(""Girls did better"") }</li><li>c) SumMarks(F, Chemistry)</li><li>d) Print(SumMarks(M, Maths) / 30)</li></ul>";"Correct: a), b), d)";"<b>Explanation:</b> A procedure that returns a value can be used as part of an expression. Its return value can be assigned to a variable (a), used in a comparison within a conditional statement (b), or used in an arithmetic operation (d).<br><b>Distractor Rationale:</b><ul><li>c) Simply calling the procedure without assigning its return value to a variable or using it in an expression means the computed sum is lost and not used for anything, which is generally not a useful way to call a procedure that returns a value.</li></ul>"
"Consider the following procedure that processes a deck of cards:<br>Procedure ProcessDeck(Deck)<br>  while (Deck has more cards) {<br>    Pick a card X from Deck<br>    Move X to SeenDeck<br>  }<br>  while (SeenDeck has more cards) {<br>    Pick a card X from SeenDeck<br>    Move X to Deck<br>  }<br>End Procedure<br>If the initial Deck was in the order [Card1, Card2, Card3, Card4] from top to bottom, what is the order of Deck after ProcessDeck is executed?<ul><li>a) [Card1, Card2, Card3, Card4] (Original order)</li><li>b) [Card4, Card3, Card2, Card1] (Reversed order)</li><li>c) The deck is empty.</li><li>d) The order is unpredictable.</li></ul>";"Correct: b)";"<b>Explanation:</b> This is a classic example of a procedure with a side effect. The first loop moves cards one by one from Deck to SeenDeck. If Deck is a pile, Card1 is moved first, then Card2, etc. SeenDeck will become [Card4, Card3, Card2, Card1] from top to bottom. The second loop moves them back to Deck, so Deck will end up in the reversed order [Card4, Card3, Card2, Card1].<br><b>Distractor Rationale:</b><ul><li>a) To restore the original order, a third pile would be needed to reverse the SeenDeck before moving it back to Deck.</li><li>c) The procedure explicitly moves the cards back to the Deck.</li><li>d) The process is deterministic; the final order is predictable.</li></ul>"
"When discussing procedures, what is the primary purpose of defining an 'interface'?<ul><li>a) To describe the specific step-by-step pseudocode inside the procedure.</li><li>b) To provide a contract specifying what the procedure needs (parameters), what it returns, and what side effects it has.</li><li>c) To ensure the procedure runs as fast as possible.</li><li>d) To automatically debug any errors within the procedure's logic.</li></ul>";"Correct: b)";"<b>Explanation:</b> The interface of a procedure acts as a contract. It separates the 'what' from the 'how'. It tells a user what parameters to provide, what kind of value to expect in return, and how the procedure might alter the data it's given (side effects), without needing to know the internal implementation details.<br><b>Distractor Rationale:</b><ul><li>a) This describes the implementation, not the interface. The interface hides these details.</li><li>c) Performance is a quality of the implementation, not the interface itself. A different implementation could have different performance while satisfying the same interface.</li><li>d) An interface defines expectations but does not perform debugging.</li></ul>"
"When converting a shopping bill with a variable number of items into a single, neat table, what is the main drawback?<br><ul><li>a) It is impossible to represent all the items.</li><li>b) The table requires a variable number of columns for each bill.</li><li>c) Information like Bill ID, Customer Name, and Total must be duplicated for each item row.</li><li>d) It is more efficient than using multiple tables.</li></ul>";"Correct: c)";"<b>Explanation:</b> To fit a variable number of items into a fixed-column table, each item must get its own row. To associate each item row with the correct bill, information that is constant for the whole bill (like Bill ID, Shop Name, Customer, and Total) must be repeated in every single one of those rows, leading to data duplication.<br><b>Distractor Rationale:</b><ul><li>a) It is possible to represent all items by giving each one a row.</li><li>b) The entire point of this method is to create a 'neat' table with a fixed number of columns.</li><li>d) It is generally less efficient in terms of storage space than using two linked tables due to the data duplication.</li></ul>"
"A procedure is designed to find the average letter count of all words that are nouns. Identify potential errors in the following pseudocode. Select all that apply.<br>1. Procedure AvgNounLength()<br>2.   Sum = 0, Count = 1<br>3.   while (Pile 1 has more cards) {<br>4.     Read card X from Pile 1<br>5.     if (X.PartOfSpeech == ""Noun"") {<br>6.       Sum = Sum + X.LetterCount<br>7.     }<br>8.     Count = Count + 1<br>9.     Move X to Pile 2<br>10.  }<br>11.  Avg = Sum / Count<br>12.  return(Avg)<br>13. End Procedure<ul><li>a) Line 2: Count is initialized incorrectly.</li><li>b) Line 6: Sum is updated incorrectly.</li><li>c) Line 8: Count is incremented in the wrong place.</li><li>d) Line 11: The calculation for Avg is correct given the variables.</li></ul>";"Correct: a), c)";"<b>Explanation:</b> There are two errors. In Line 2, Count should be initialized to 0, not 1. Initializing to 1 will lead to an incorrect final count. In Line 8, Count is incremented for every card, regardless of whether it is a noun or not. It should only be incremented inside the if block (like the Sum variable) to count only the nouns.<br><b>Distractor Rationale:</b><ul><li>b) Line 6 correctly adds the letter count to the sum.</li><li>d) While the formula Sum / Count is correct for an average, the values of Sum and Count will be wrong due to the other errors, making the final result incorrect. However, the line itself is syntactically correct.</li></ul>"
"What is the most significant advantage of modularizing pseudocode using procedures?<ul><li>a) It makes the pseudocode run faster.</li><li>b) It reduces the need for variables.</li><li>c) It avoids describing the same process repeatedly, making the code easier to read and maintain.</li><li>d) It guarantees that the code will have no errors.</li></ul>";"Correct: c)";"<b>Explanation:</b> The primary benefit of procedures is reusability. By defining a process once (e.g., finding a maximum value), you can 'call' that procedure whenever you need it, rather than rewriting the same block of code multiple times. This makes the overall code shorter, easier to understand, and much easier to update; if you improve the procedure, the improvement applies everywhere it's called.<br><b>Distractor Rationale:</b><ul><li>a) Using procedures doesn't inherently make code faster; it's about organization and structure.</li><li>b) Procedures still require variables to do their work.</li><li>d) Procedures help organize code, which can make it easier to find and fix errors, but they do not guarantee an error-free program.</li></ul>"
"You need to write a procedure that counts the number of students from a given City whose Total marks are above a specific Threshold. The procedure signature is CountTopStudents(City, Threshold). Which conditional statement correctly identifies the students to be counted?<ul><li>a) if (X.City == City or X.Total > Threshold)</li><li>b) if (X.City == City and X.Total > Threshold)</li><li>c) if (X.City > City and X.Total == Threshold)</li><li>d) if (X.Total > City and X.City == Threshold)</li></ul>";"Correct: b)";"<b>Explanation:</b> The problem requires two conditions to be met simultaneously for a student to be counted. The student's city must match the City parameter AND the student's total marks must be greater than the Threshold parameter. The logical and operator correctly combines these two requirements.<br><b>Distractor Rationale:</b><ul><li>a) Using or would incorrectly count students who are from the city but have low scores, as well as students with high scores who are not from the city.</li><li>c) This makes no logical sense; you cannot use > to compare city names in this context.</li><li>d) This incorrectly compares the Total with the City and the City with the Threshold.</li></ul>"
"Which of the following procedures would most likely be designed to have a desirable and intentional side effect? Select all that apply.<ul><li>a) FindMax(Deck)</li><li>b) CalculateAverage(Deck)</li><li>c) SortDeck(Deck)</li><li>d) UpdateRecord(CardID, NewValue)</li></ul>";"Correct: c), d)";"<b>Explanation:</b> A side effect is a modification of data that is passed to a procedure. For SortDeck(Deck), the entire purpose is to modify the Deck by reordering it. This is an intentional and desirable side effect. Similarly, for UpdateRecord(CardID, NewValue), the purpose is to find a specific record and change its value, which is also an intentional side effect.<br><b>Distractor Rationale:</b><ul><li>a) FindMax is typically expected to return the maximum value without changing the original deck. Reordering the deck would be an undesirable side effect.</li><li>b) CalculateAverage should return the average without modifying the deck.</li></ul>"
"A procedure TopThreeMarks(Subj) is designed to find the three highest scores in a given subject. If multiple students are tied for the second-highest score, how does this affect the outcome?<ul><li>a) The procedure will fail and produce an error.</li><li>b) The procedure will correctly identify all tied students.</li><li>c) The procedure, as typically designed, will find the max, but the second and third highest values might not be unique.</li><li>d) The procedure will ignore all tied scores.</li></ul>";"Correct: c)";"<b>Explanation:</b> A simple procedure that maintains max, secondmax, and thirdmax variables will handle ties, but it won't distinguish between them. For example, if the scores are [100, 95, 95, 90], the procedure will report max=100, secondmax=95, and thirdmax=95. It correctly identifies the values of the top scores, but does not explicitly report that two students shared the second-highest score.<br><b>Distractor Rationale:</b><ul><li>a) Ties are a normal data condition and a well-written procedure should not error.</li><li>b) The simple procedure tracks the top three values, not necessarily all the students who achieved those values. More complex logic would be needed for that.</li><li>d) There is no reason for the procedure to ignore tied scores.</li></ul>"
"When representing a shopping bill using two separate, linked tables, which of the following is the best approach?<ul><li>a) Table 1: Bill ID, Item, Quantity, Price. Table 2: Shop Name, Customer Name, Total.</li><li>b) Table 1: Bill ID, Shop Name, Customer Name, Total. Table 2: Bill ID, Item, Quantity, Price, Cost.</li><li>c) Table 1: Item, Quantity, Price. Table 2: Bill ID, Shop Name, Customer Name.</li><li>d) Table 1: Bill ID, Shop Name, Customer. Table 2: Item, Category, Total.</li></ul>";"Correct: b)";"<b>Explanation:</b> The most efficient way to split the data is to put all the information that is constant for the entire bill into one table, and all the information that varies per item into a second table. A unique Bill ID must be present in both tables to link them. Table 1 correctly holds the per-bill data, and Table 2 holds the per-item data, with Bill ID linking each item to its corresponding bill.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect because Total is per-bill information and should be with the Shop Name and Customer.</li><li>c) This is incorrect because the tables cannot be linked without a common Bill ID column in both.</li><li>d) This is incorrect because Total is per-bill information and should be in Table 1.</li></ul>"
"What is the return value of a procedure like SubjectTopper(Card, MMark, PMark, CMark), which checks if a student is in the top three of any subject?<ul><li>a) A number representing the student's highest subject rank.</li><li>b) A list of subjects in which the student is a topper.</li><li>c) A Boolean value (True or False).</li><li>d) The student's total score.</li></ul>";"Correct: c)";"<b>Explanation:</b> The purpose of this procedure is to answer a simple yes/no question: ""Is this student a subject topper?"". The most direct and useful way to represent this answer is with a Boolean value. It returns True if the student's marks are greater than or equal to the threshold in at least one subject, and False otherwise. This Boolean value can then be easily used in an if statement.<br><b>Distractor Rationale:</b><ul><li>a) The procedure checks a condition; it doesn't calculate a rank.</li><li>b) While possible, this is more complex than needed. A simple True/False is sufficient for the prize-awarding problem.</li><li>d) The procedure evaluates subject marks, not the total score.</li></ul>"
"A procedure is written to find the range of scores (Max - Min) for a given subject. It contains a logical error. What is the problem?<br>Procedure GetRange(Subj)<br>  MaxVal = 0<br>  MinVal = 0<br>  while (Pile 1 has more cards) {<br>    Read card X from Pile 1<br>    if (X.Subj > MaxVal) { MaxVal = X.Subj }<br>    if (X.Subj < MinVal) { MinVal = X.Subj }<br>    Move X to Pile 2<br>  }<br>  return(MaxVal - MinVal)<br>End Procedure<ul><li>a) MaxVal is initialized incorrectly.</li><li>b) The return statement should be MinVal - MaxVal.</li><li>c) MinVal is initialized incorrectly.</li><li>d) The loops should be nested.</li></ul>";"Correct: c)";"<b>Explanation:</b> The error is in the initialization of MinVal. By setting MinVal = 0, the condition X.Subj < MinVal will never be true for any non-negative score. The procedure will incorrectly return 0 for MinVal. To correctly find a minimum, the variable must be initialized to a value guaranteed to be larger than any possible score (e.g., 101 if scores are out of 100).<br><b>Distractor Rationale:</b><ul><li>a) Initializing MaxVal to 0 is correct for finding the maximum of non-negative scores.</li><li>b) The range is correctly calculated as Max minus Min.</li><li>d) A single loop through all cards is the correct structure.</li></ul>"
"Consider a procedure UpdateScore(CardID, Subject, NewScore) that finds a student's card and updates their score for a specific subject. This procedure does not have a return statement. How should it be called?<ul><li>a) result = UpdateScore(17, Physics, 88)</li><li>b) if (UpdateScore(17, Physics, 88) == True) { ... }</li><li>c) UpdateScore(17, Physics, 88)</li><li>d) Print(UpdateScore(17, Physics, 88))</li></ul>";"Correct: c)";"<b>Explanation:</b> This procedure's main purpose is to perform an action (modifying data), which is a side effect. It does not compute and return a useful value. In such cases, the procedure call is a standalone statement. You simply state the procedure name and provide the necessary parameters to tell it what to do.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect because the procedure does not return a value to be assigned to result.</li><li>b) This is incorrect as there is no Boolean value returned to be used in a comparison.</li><li>d) This is incorrect as there is no value to be printed.</li></ul>"
"A programmer splits the shopping bill data into two tables: Bills and BillItems. The Bills table has columns BillID, ShopName, CustomerName. The BillItems table has ItemID, ItemName, Quantity, Price. What is the critical error in this design?<ul><li>a) The Bills table should also include the Total.</li><li>b) There is no common column to link a row in BillItems back to a row in Bills.</li><li>c) The BillItems table should not have an ItemID.</li><li>d) The ShopName and CustomerName should be in the BillItems table.</li></ul>";"Correct: b)";"<b>Explanation:</b> When data is split across multiple tables, there must be a way to relate them. The BillItems table needs a 'foreign key' column—in this case, BillID—that matches the 'primary key' in the Bills table. Without the BillID in the BillItems table, there is no way to know which bill an item belongs to.<br><b>Distractor Rationale:</b><ul><li>a) While including the Total in the Bills table is a good idea, the lack of a linking column is a more fundamental, critical error.</li><li>c) An ItemID could be useful for uniquely identifying each row in the BillItems table.</li><li>d) This would reintroduce the data duplication problem that splitting the tables was meant to solve.</li></ul>"
"The following pseudocode is intended to find the second-lowest total bill amount. What is the logical error?<br>First = 10000, Second = 10000<br>while (Pile 1 has more cards) {<br>  Read card X from Pile 1<br>  if (X.TotalBillAmount < First) {<br>    Second = First<br>    First = X.TotalBillAmount<br>  }<br>  if (X.TotalBillAmount > First and X.TotalBillAmount < Second) {<br>    Second = X.TotalBillAmount<br>  }<br>  Move X to Pile 2<br>}<ul><li>a) The initialization values are too high.</li><li>b) The first if statement is correct, but the second one should be an else if.</li><li>c) The variables should be named Max and SecondMax.</li><li>d) The second if condition should use or instead of and.</li></ul>";"Correct: b)";"<b>Explanation:</b> If a new amount is the absolute lowest (the first if is true), the code correctly updates First and Second. However, it then immediately proceeds to the second if. The new lowest amount will now be First, so the condition X.TotalBillAmount > First will be false, and Second will not be updated correctly in all cases. By changing the second if to an else if, we ensure that only one of the two update blocks can execute for any given card, which is the correct logic.<br><b>Distractor Rationale:</b><ul><li>a) The initialization values are correct for finding minimums.</li><li>c) The variable names are descriptive and correct for the task.</li><li>d) Using or would be logically incorrect.</li></ul>"
"A procedure's 'contract' or interface should specify which of the following? Select all that apply.<ul><li>a) The names of the local variables used inside the procedure.</li><li>b) The parameters it expects to receive.</li><li>c) The value it will return.</li><li>d) Any potential side effects it might have on the data it is given.</li></ul>";"Correct: b), c), d)";"<b>Explanation:</b> The interface defines the boundary between the caller and the procedure. The caller needs to know what to provide (parameters), what to expect back (return value), and how its data might be changed (side effects). The internal details, such as the names of local variables, are part of the implementation and should be hidden by the interface.<br><b>Distractor Rationale:</b><ul><li>a) Local variable names are implementation details, not part of the interface. A programmer could change the local variable names without affecting any code that calls the procedure.</li></ul>"
"If you use a procedure to calculate the sum of marks for boys and then call the same procedure again to calculate the sum for girls, what is the main benefit you are gaining?<ul><li>a) Speed, because the second call is faster.</li><li>b) Accuracy, because procedures make fewer mistakes than manual calculations.</li><li>c) Reusability, because you are using the same code to perform a similar task on different data.</li><li>d) Simplicity, because you do not need to use any variables.</li></ul>";"Correct: c)";"<b>Explanation:</b> This is a prime example of reusability. You have written the logic for summing marks once, inside the procedure. You can then reuse that same logic for different subsets of your data (boys, girls) simply by changing the parameter you pass to it. This avoids writing duplicate code.<br><b>Distractor Rationale:</b><ul><li>a) The second call is not inherently faster than the first.</li><li>b) While procedures help enforce consistency, the primary concept demonstrated here is reusing a single piece of code.</li><li>d) You still need variables to store the results of the procedure calls (e.g., boy_sum, girl_sum).</li></ul>"
"A procedure CheckEligibility(Card) is written. Inside the procedure, it determines if a student's total is above 250. If it is, the procedure prints ""Eligible""; otherwise, it prints ""Not Eligible"". The procedure has no return statement. This type of procedure is called primarily for its...<ul><li>a) Return value</li><li>b) Side effect</li><li>c) Parameters</li><li>d) Speed</li></ul>";"Correct: b)";"<b>Explanation:</b> The ""side effect"" of a procedure is any observable effect it has other than returning a value. In this case, the observable effect is printing text to a screen or console. Since it doesn't return a value, it is called specifically to produce this side effect.<br><b>Distractor Rationale:</b><ul><li>a) The procedure is explicitly described as having no return statement.</li><li>c) Parameters are the inputs to the procedure, not its primary purpose or effect.</li><li>d) Speed is a characteristic of the implementation, not the type of effect it produces.</li></ul>"
"What is the key difference between passing a 'value' (like 'F' for female) and a 'field name' (like 'Physics') as a parameter to a procedure operating on student cards?<ul><li>a) There is no difference; the procedure treats them the same way.</li><li>b) A 'value' is used for comparison (e.g., if X.Gender == gen), while a 'field name' is used to access a specific part of the card's data (e.g., Sum = Sum + X.fld).</li><li>c) A 'value' must be a letter, and a 'field name' must be a number.</li><li>d) Passing a 'field name' is less efficient than passing a 'value'.</li></ul>";"Correct: b)";"<b>Explanation:</b> This highlights the two main ways parameters can be used to add flexibility. A value parameter provides concrete data to be used in a comparison or calculation. A field name parameter tells the procedure which piece of data on the card to operate on, making the procedure adaptable to different attributes of the data structure.<br><b>Distractor Rationale:</b><ul><li>a) The procedure uses them in fundamentally different ways.</li><li>c) The data types are not restricted in this way; a value could be a number and a field name is a string of letters.</li><li>d) There is no inherent performance difference; it's about how the parameter is used logically.</li></ul>"
"A procedure is written to find the student with the minimum total marks. Which of the following initializations for the variable MinVal is the most robust?<br>Procedure FindMinTotal()<br>  MinVal = ?<br>  while (Pile 1 has more cards) {<br>    Read card X from Pile 1<br>    if (X.Total < MinVal) {<br>      MinVal = X.Total<br>    }<br>    Move X to Pile 2<br>  }<br>  return(MinVal)<br>End Procedure<ul><li>a) MinVal = 0</li><li>b) MinVal = The total marks of the first card in the pile.</li><li>c) MinVal = 101 (assuming marks are out of 100 per subject, so max total is 300)</li><li>d) MinVal = 301 (assuming max total is 300)</li></ul>";"Correct: d)";"<b>Explanation:</b> To find a minimum value, the tracking variable (MinVal) must be initialized to a value that is guaranteed to be greater than any possible value in the dataset. Since the maximum possible total is 300, initializing MinVal to 301 ensures that the Total of the very first card will be less than MinVal, correctly starting the comparison process.<br><b>Distractor Rationale:</b><ul><li>a) Initializing to 0 is incorrect because if all student totals are positive, the condition X.Total < MinVal would never be true, and the procedure would wrongly return 0.</li><li>b) This is a valid strategy, but it requires special handling for the first card and is slightly less straightforward than initializing with a guaranteed high value.</li><li>c) 101 is not guaranteed to be higher than all possible total marks, as a student could score more than 101 in total.</li></ul>"
"A procedure SumMarks(gen, fld) returns the sum of marks for a given gender gen in a specific field fld. Which of the following are valid ways to use this procedure in pseudocode? Select all that apply.<ul><li>a) BoyPhysicsSum = SumMarks(M, Physics)</li><li>b) if (SumMarks(F, Total) > SumMarks(M, Total)) { Print(""Girls did better"") }</li><li>c) SumMarks(F, Chemistry)</li><li>d) Print(SumMarks(M, Maths) / 30)</li></ul>";"Correct: a), b), d)";"<b>Explanation:</b> A procedure that returns a value can be used as part of an expression. Its return value can be assigned to a variable (a), used in a comparison within a conditional statement (b), or used in an arithmetic operation (d).<br><b>Distractor Rationale:</b><ul><li>c) Simply calling the procedure without assigning its return value to a variable or using it in an expression means the computed sum is lost and not used for anything, which is generally not a useful way to call a procedure that returns a value.</li></ul>"
"Consider the following procedure that processes a deck of cards:<br>Procedure ProcessDeck(Deck)<br>  while (Deck has more cards) {<br>    Pick a card X from Deck<br>    Move X to SeenDeck<br>  }<br>  while (SeenDeck has more cards) {<br>    Pick a card X from SeenDeck<br>    Move X to Deck<br>  }<br>End Procedure<br>If the initial Deck was in the order [Card1, Card2, Card3, Card4] from top to bottom, what is the order of Deck after ProcessDeck is executed?<ul><li>a) [Card1, Card2, Card3, Card4] (Original order)</li><li>b) [Card4, Card3, Card2, Card1] (Reversed order)</li><li>c) The deck is empty.</li><li>d) The order is unpredictable.</li></ul>";"Correct: b)";"<b>Explanation:</b> This is a classic example of a procedure with a side effect. The first loop moves cards one by one from Deck to SeenDeck. If Deck is a pile, Card1 is moved first, then Card2, etc. SeenDeck will become [Card4, Card3, Card2, Card1] from top to bottom. The second loop moves them back to Deck, so Deck will end up in the reversed order [Card4, Card3, Card2, Card1].<br><b>Distractor Rationale:</b><ul><li>a) To restore the original order, a third pile would be needed to reverse the SeenDeck before moving it back to Deck.</li><li>c) The procedure explicitly moves the cards back to the Deck.</li><li>d) The process is deterministic; the final order is predictable.</li></ul>"
"When discussing procedures, what is the primary purpose of defining an 'interface'?<ul><li>a) To describe the specific step-by-step pseudocode inside the procedure.</li><li>b) To provide a contract specifying what the procedure needs (parameters), what it returns, and what side effects it has.</li><li>c) To ensure the procedure runs as fast as possible.</li><li>d) To automatically debug any errors within the procedure's logic.</li></ul>";"Correct: b)";"<b>Explanation:</b> The interface of a procedure acts as a contract. It separates the 'what' from the 'how'. It tells a user what parameters to provide, what kind of value to expect in return, and how the procedure might alter the data it's given (side effects), without needing to know the internal implementation details.<br><b>Distractor Rationale:</b><ul><li>a) This describes the implementation, not the interface. The interface hides these details.</li><li>c) Performance is a quality of the implementation, not the interface itself. A different implementation could have different performance while satisfying the same interface.</li><li>d) An interface defines expectations but does not perform debugging.</li></ul>"
"When converting a shopping bill with a variable number of items into a single, neat table, what is the main drawback?<br><ul><li>a) It is impossible to represent all the items.</li><li>b) The table requires a variable number of columns for each bill.</li><li>c) Information like Bill ID, Customer Name, and Total must be duplicated for each item row.</li><li>d) It is more efficient than using multiple tables.</li></ul>";"Correct: c)";"<b>Explanation:</b> To fit a variable number of items into a fixed-column table, each item must get its own row. To associate each item row with the correct bill, information that is constant for the whole bill (like Bill ID, Shop Name, Customer, and Total) must be repeated in every single one of those rows, leading to data duplication.<br><b>Distractor Rationale:</b><ul><li>a) It is possible to represent all items by giving each one a row.</li><li>b) The entire point of this method is to create a 'neat' table with a fixed number of columns.</li><li>d) It is generally less efficient in terms of storage space than using two linked tables due to the data duplication.</li></ul>"
"A procedure is designed to find the average letter count of all words that are nouns. Identify potential errors in the following pseudocode. Select all that apply.<br>1. Procedure AvgNounLength()<br>2.   Sum = 0, Count = 1<br>3.   while (Pile 1 has more cards) {<br>4.     Read card X from Pile 1<br>5.     if (X.PartOfSpeech == ""Noun"") {<br>6.       Sum = Sum + X.LetterCount<br>7.     }<br>8.     Count = Count + 1<br>9.     Move X to Pile 2<br>10.  }<br>11.  Avg = Sum / Count<br>12.  return(Avg)<br>13. End Procedure<ul><li>a) Line 2: Count is initialized incorrectly.</li><li>b) Line 6: Sum is updated incorrectly.</li><li>c) Line 8: Count is incremented in the wrong place.</li><li>d) Line 11: The calculation for Avg is correct given the variables.</li></ul>";"Correct: a), c)";"<b>Explanation:</b> There are two errors. In Line 2, Count should be initialized to 0, not 1. Initializing to 1 will lead to an incorrect final count. In Line 8, Count is incremented for every card, regardless of whether it is a noun or not. It should only be incremented inside the if block (like the Sum variable) to count only the nouns.<br><b>Distractor Rationale:</b><ul><li>b) Line 6 correctly adds the letter count to the sum.</li><li>d) While the formula Sum / Count is correct for an average, the values of Sum and Count will be wrong due to the other errors, making the final result incorrect. However, the line itself is syntactically correct.</li></ul>"
"What is the most significant advantage of modularizing pseudocode using procedures?<ul><li>a) It makes the pseudocode run faster.</li><li>b) It reduces the need for variables.</li><li>c) It avoids describing the same process repeatedly, making the code easier to read and maintain.</li><li>d) It guarantees that the code will have no errors.</li></ul>";"Correct: c)";"<b>Explanation:</b> The primary benefit of procedures is reusability. By defining a process once (e.g., finding a maximum value), you can 'call' that procedure whenever you need it, rather than rewriting the same block of code multiple times. This makes the overall code shorter, easier to understand, and much easier to update; if you improve the procedure, the improvement applies everywhere it's called.<br><b>Distractor Rationale:</b><ul><li>a) Using procedures doesn't inherently make code faster; it's about organization and structure.</li><li>b) Procedures still require variables to do their work.</li><li>d) Procedures help organize code, which can make it easier to find and fix errors, but they do not guarantee an error-free program.</li></ul>"
"You need to write a procedure that counts the number of students from a given City whose Total marks are above a specific Threshold. The procedure signature is CountTopStudents(City, Threshold). Which conditional statement correctly identifies the students to be counted?<ul><li>a) if (X.City == City or X.Total > Threshold)</li><li>b) if (X.City == City and X.Total > Threshold)</li><li>c) if (X.City > City and X.Total == Threshold)</li><li>d) if (X.Total > City and X.City == Threshold)</li></ul>";"Correct: b)";"<b>Explanation:</b> The problem requires two conditions to be met simultaneously for a student to be counted. The student's city must match the City parameter AND the student's total marks must be greater than the Threshold parameter. The logical and operator correctly combines these two requirements.<br><b>Distractor Rationale:</b><ul><li>a) Using or would incorrectly count students who are from the city but have low scores, as well as students with high scores who are not from the city.</li><li>c) This makes no logical sense; you cannot use > to compare city names in this context.</li><li>d) This incorrectly compares the Total with the City and the City with the Threshold.</li></ul>"
"Which of the following procedures would most likely be designed to have a desirable and intentional side effect? Select all that apply.<ul><li>a) FindMax(Deck)</li><li>b) CalculateAverage(Deck)</li><li>c) SortDeck(Deck)</li><li>d) UpdateRecord(CardID, NewValue)</li></ul>";"Correct: c), d)";"<b>Explanation:</b> A side effect is a modification of data that is passed to a procedure. For SortDeck(Deck), the entire purpose is to modify the Deck by reordering it. This is an intentional and desirable side effect. Similarly, for UpdateRecord(CardID, NewValue), the purpose is to find a specific record and change its value, which is also an intentional side effect.<br><b>Distractor Rationale:</b><ul><li>a) FindMax is typically expected to return the maximum value without changing the original deck. Reordering the deck would be an undesirable side effect.</li><li>b) CalculateAverage should return the average without modifying the deck.</li></ul>"
"A procedure TopThreeMarks(Subj) is designed to find the three highest scores in a given subject. If multiple students are tied for the second-highest score, how does this affect the outcome?<ul><li>a) The procedure will fail and produce an error.</li><li>b) The procedure will correctly identify all tied students.</li><li>c) The procedure, as typically designed, will find the max, but the second and third highest values might not be unique.</li><li>d) The procedure will ignore all tied scores.</li></ul>";"Correct: c)";"<b>Explanation:</b> A simple procedure that maintains max, secondmax, and thirdmax variables will handle ties, but it won't distinguish between them. For example, if the scores are [100, 95, 95, 90], the procedure will report max=100, secondmax=95, and thirdmax=95. It correctly identifies the values of the top scores, but does not explicitly report that two students shared the second-highest score.<br><b>Distractor Rationale:</b><ul><li>a) Ties are a normal data condition and a well-written procedure should not error.</li><li>b) The simple procedure tracks the top three values, not necessarily all the students who achieved those values. More complex logic would be needed for that.</li><li>d) There is no reason for the procedure to ignore tied scores.</li></ul>"
"When representing a shopping bill using two separate, linked tables, which of the following is the best approach?<ul><li>a) Table 1: Bill ID, Item, Quantity, Price. Table 2: Shop Name, Customer Name, Total.</li><li>b) Table 1: Bill ID, Shop Name, Customer Name, Total. Table 2: Bill ID, Item, Quantity, Price, Cost.</li><li>c) Table 1: Item, Quantity, Price. Table 2: Bill ID, Shop Name, Customer Name.</li><li>d) Table 1: Bill ID, Shop Name, Customer. Table 2: Item, Category, Total.</li></ul>";"Correct: b)";"<b>Explanation:</b> The most efficient way to split the data is to put all the information that is constant for the entire bill into one table, and all the information that varies per item into a second table. A unique Bill ID must be present in both tables to link them. Table 1 correctly holds the per-bill data, and Table 2 holds the per-item data, with Bill ID linking each item to its corresponding bill.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect because Total is per-bill information and should be with the Shop Name and Customer.</li><li>c) This is incorrect because the tables cannot be linked without a common Bill ID column in both.</li><li>d) This is incorrect because Total is per-bill information and should be in Table 1.</li></ul>"
"What is the return value of a procedure like SubjectTopper(Card, MMark, PMark, CMark), which checks if a student is in the top three of any subject?<ul><li>a) A number representing the student's highest subject rank.</li><li>b) A list of subjects in which the student is a topper.</li><li>c) A Boolean value (True or False).</li><li>d) The student's total score.</li></ul>";"Correct: c)";"<b>Explanation:</b> The purpose of this procedure is to answer a simple yes/no question: ""Is this student a subject topper?"". The most direct and useful way to represent this answer is with a Boolean value. It returns True if the student's marks are greater than or equal to the threshold in at least one subject, and False otherwise. This Boolean value can then be easily used in an if statement.<br><b>Distractor Rationale:</b><ul><li>a) The procedure checks a condition; it doesn't calculate a rank.</li><li>b) While possible, this is more complex than needed. A simple True/False is sufficient for the prize-awarding problem.</li><li>d) The procedure evaluates subject marks, not the total score.</li></ul>"
"A procedure is written to find the range of scores (Max - Min) for a given subject. It contains a logical error. What is the problem?<br>Procedure GetRange(Subj)<br>  MaxVal = 0<br>  MinVal = 0<br>  while (Pile 1 has more cards) {<br>    Read card X from Pile 1<br>    if (X.Subj > MaxVal) { MaxVal = X.Subj }<br>    if (X.Subj < MinVal) { MinVal = X.Subj }<br>    Move X to Pile 2<br>  }<br>  return(MaxVal - MinVal)<br>End Procedure<ul><li>a) MaxVal is initialized incorrectly.</li><li>b) The return statement should be MinVal - MaxVal.</li><li>c) MinVal is initialized incorrectly.</li><li>d) The loops should be nested.</li></ul>";"Correct: c)";"<b>Explanation:</b> The error is in the initialization of MinVal. By setting MinVal = 0, the condition X.Subj < MinVal will never be true for any non-negative score. The procedure will incorrectly return 0 for MinVal. To correctly find a minimum, the variable must be initialized to a value guaranteed to be larger than any possible score (e.g., 101 if scores are out of 100).<br><b>Distractor Rationale:</b><ul><li>a) Initializing MaxVal to 0 is correct for finding the maximum of non-negative scores.</li><li>b) The range is correctly calculated as Max minus Min.</li><li>d) A single loop through all cards is the correct structure.</li></ul>"
"Consider a procedure UpdateScore(CardID, Subject, NewScore) that finds a student's card and updates their score for a specific subject. This procedure does not have a return statement. How should it be called?<ul><li>a) result = UpdateScore(17, Physics, 88)</li><li>b) if (UpdateScore(17, Physics, 88) == True) { ... }</li><li>c) UpdateScore(17, Physics, 88)</li><li>d) Print(UpdateScore(17, Physics, 88))</li></ul>";"Correct: c)";"<b>Explanation:</b> This procedure's main purpose is to perform an action (modifying data), which is a side effect. It does not compute and return a useful value. In such cases, the procedure call is a standalone statement. You simply state the procedure name and provide the necessary parameters to tell it what to do.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect because the procedure does not return a value to be assigned to result.</li><li>b) This is incorrect as there is no Boolean value returned to be used in a comparison.</li><li>d) This is incorrect as there is no value to be printed.</li></ul>"
"A programmer splits the shopping bill data into two tables: Bills and BillItems. The Bills table has columns BillID, ShopName, CustomerName. The BillItems table has ItemID, ItemName, Quantity, Price. What is the critical error in this design?<ul><li>a) The Bills table should also include the Total.</li><li>b) There is no common column to link a row in BillItems back to a row in Bills.</li><li>c) The BillItems table should not have an ItemID.</li><li>d) The ShopName and CustomerName should be in the BillItems table.</li></ul>";"Correct: b)";"<b>Explanation:</b> When data is split across multiple tables, there must be a way to relate them. The BillItems table needs a 'foreign key' column—in this case, BillID—that matches the 'primary key' in the Bills table. Without the BillID in the BillItems table, there is no way to know which bill an item belongs to.<br><b>Distractor Rationale:</b><ul><li>a) While including the Total in the Bills table is a good idea, the lack of a linking column is a more fundamental, critical error.</li><li>c) An ItemID could be useful for uniquely identifying each row in the BillItems table.</li><li>d) This would reintroduce the data duplication problem that splitting the tables was meant to solve.</li></ul>"
"The following pseudocode is intended to find the second-lowest total bill amount. What is the logical error?<br>First = 10000, Second = 10000<br>while (Pile 1 has more cards) {<br>  Read card X from Pile 1<br>  if (X.TotalBillAmount < First) {<br>    Second = First<br>    First = X.TotalBillAmount<br>  }<br>  if (X.TotalBillAmount > First and X.TotalBillAmount < Second) {<br>    Second = X.TotalBillAmount<br>  }<br>  Move X to Pile 2<br>}<ul><li>a) The initialization values are too high.</li><li>b) The first if statement is correct, but the second one should be an else if.</li><li>c) The variables should be named Max and SecondMax.</li><li>d) The second if condition should use or instead of and.</li></ul>";"Correct: b)";"<b>Explanation:</b> If a new amount is the absolute lowest (the first if is true), the code correctly updates First and Second. However, it then immediately proceeds to the second if. The new lowest amount will now be First, so the condition X.TotalBillAmount > First will be false, and Second will not be updated correctly in all cases. By changing the second if to an else if, we ensure that only one of the two update blocks can execute for any given card, which is the correct logic.<br><b>Distractor Rationale:</b><ul><li>a) The initialization values are correct for finding minimums.</li><li>c) The variable names are descriptive and correct for the task.</li><li>d) Using or would be logically incorrect.</li></ul>"
"A procedure's 'contract' or interface should specify which of the following? Select all that apply.<ul><li>a) The names of the local variables used inside the procedure.</li><li>b) The parameters it expects to receive.</li><li>c) The value it will return.</li><li>d) Any potential side effects it might have on the data it is given.</li></ul>";"Correct: b), c), d)";"<b>Explanation:</b> The interface defines the boundary between the caller and the procedure. The caller needs to know what to provide (parameters), what to expect back (return value), and how its data might be changed (side effects). The internal details, such as the names of local variables, are part of the implementation and should be hidden by the interface.<br><b>Distractor Rationale:</b><ul><li>a) Local variable names are implementation details, not part of the interface. A programmer could change the local variable names without affecting any code that calls the procedure.</li></ul>"
"If you use a procedure to calculate the sum of marks for boys and then call the same procedure again to calculate the sum for girls, what is the main benefit you are gaining?<ul><li>a) Speed, because the second call is faster.</li><li>b) Accuracy, because procedures make fewer mistakes than manual calculations.</li><li>c) Reusability, because you are using the same code to perform a similar task on different data.</li><li>d) Simplicity, because you do not need to use any variables.</li></ul>";"Correct: c)";"<b>Explanation:</b> This is a prime example of reusability. You have written the logic for summing marks once, inside the procedure. You can then reuse that same logic for different subsets of your data (boys, girls) simply by changing the parameter you pass to it. This avoids writing duplicate code.<br><b>Distractor Rationale:</b><ul><li>a) The second call is not inherently faster than the first.</li><li>b) While procedures help enforce consistency, the primary concept demonstrated here is reusing a single piece of code.</li><li>d) You still need variables to store the results of the procedure calls (e.g., boy_sum, girl_sum).</li></ul>"
"A procedure CheckEligibility(Card) is written. Inside the procedure, it determines if a student's total is above 250. If it is, the procedure prints ""Eligible""; otherwise, it prints ""Not Eligible"". The procedure has no return statement. This type of procedure is called primarily for its...<ul><li>a) Return value</li><li>b) Side effect</li><li>c) Parameters</li><li>d) Speed</li></ul>";"Correct: b)";"<b>Explanation:</b> The ""side effect"" of a procedure is any observable effect it has other than returning a value. In this case, the observable effect is printing text to a screen or console. Since it doesn't return a value, it is called specifically to produce this side effect.<br><b>Distractor Rationale:</b><ul><li>a) The procedure is explicitly described as having no return statement.</li><li>c) Parameters are the inputs to the procedure, not its primary purpose or effect.</li><li>d) Speed is a characteristic of the implementation, not the type of effect it produces.</li></ul>"
"What is the key difference between passing a 'value' (like 'F' for female) and a 'field name' (like 'Physics') as a parameter to a procedure operating on student cards?<ul><li>a) There is no difference; the procedure treats them the same way.</li><li>b) A 'value' is used for comparison (e.g., if X.Gender == gen), while a 'field name' is used to access a specific part of the card's data (e.g., Sum = Sum + X.fld).</li><li>c) A 'value' must be a letter, and a 'field name' must be a number.</li><li>d) Passing a 'field name' is less efficient than passing a 'value'.</li></ul>";"Correct: b)";"<b>Explanation:</b> This highlights the two main ways parameters can be used to add flexibility. A value parameter provides concrete data to be used in a comparison or calculation. A field name parameter tells the procedure which piece of data on the card to operate on, making the procedure adaptable to different attributes of the data structure.<br><b>Distractor Rationale:</b><ul><li>a) The procedure uses them in fundamentally different ways.</li><li>c) The data types are not restricted in this way; a value could be a number and a field name is a string of letters.</li><li>d) There is no inherent performance difference; it's about how the parameter is used logically.</li></ul>"
"When representing data from a collection of student grade cards in a table, what does each row typically represent?<ul><li>a) A single subject's score</li><li>b) A single student (one card)</li><li>c) An attribute like 'Name' or 'Gender'</li><li>d) The average score for the class</li></ul>";"Correct: b)";"<b>Explanation:</b> When converting card-based data to a tabular format, the standard convention is that each complete unit of information (in this case, one student's grade card) becomes a single row in the table. The different pieces of information on that card become the columns.<br><b>Distractor Rationale:</b><ul><li>a) A single subject's score would be a value in a specific cell (the intersection of a row and a column), not an entire row.</li><li>c) An attribute like 'Name' becomes a column header, defining the data for that column across all rows.</li><li>d) The average score is a calculated value derived from the table, not a fundamental part of its structure representing a single card.</li></ul>"
"What is the primary problem with representing a shopping bill, which has a variable number of items, in a single table row?<ul><li>a) It would require a variable number of columns, which is not a standard 'neat' table structure.</li><li>b) The total bill amount cannot be stored.</li><li>c) The customer's name would have to be repeated.</li><li>d) It is impossible to store the quantity of each item.</li></ul>";"Correct: a)";"<b>Explanation:</b> A standard table has a fixed number of columns for every row. If each item on a bill were to get its own set of columns (e.g., Item1_Name, Item1_Price, Item2_Name, Item2_Price...), a bill with 5 items would need a different number of columns than a bill with 10 items. This breaks the uniform structure of a table.<br><b>Distractor Rationale:</b><ul><li>b) The total bill amount is a single value and can easily be stored in its own column.</li><li>c) Repetition of the customer's name happens when using multiple rows for one bill, not when trying to fit it into a single row.</li><li>d) The quantity could be stored in a dedicated column for each item. The issue is the variable number of these columns.</li></ul>"
"To solve the problem of variable items on a shopping bill, one can use multiple rows in a table for a single bill. What is the most crucial piece of information needed to link these multiple rows together?<ul><li>a) The customer's name</li><li>b) The total bill amount</li><li>c) A unique Bill ID</li><li>d) The name of the shop</li></ul>";"Correct: c)";"<b>Explanation:</b> A unique Bill ID is the only piece of information guaranteed to be the same for all items on one specific bill and different from all items on another bill. By repeating this unique ID in each item's row, you create a clear and unambiguous link, ensuring you can group all items from a single transaction.<br><b>Distractor Rationale:</b><ul><li>a) A customer could have multiple bills, so the name is not unique to a single transaction.</li><li>b) Two different bills could coincidentally have the same total amount.</li><li>d) A shop will have thousands of different bills.</li></ul>"
"What is the most efficient way to represent shopping bill data in a database to minimize data duplication?<ul><li>a) A single table with one row per item, duplicating all bill-level information in each row.</li><li>b) A single table with a variable number of columns.</li><li>c) Two tables: one for bill-level information (ID, Customer, Total) and a second for item-level information (Bill ID, Item, Price), linked by the Bill ID.</li><li>d) One table for each customer.</li></ul>";"Correct: c)";"<b>Explanation:</b> This is a standard database normalization technique. By splitting the data, information that is constant for the whole bill (Customer, Shop, Total) is stored only once in the first table. The second table lists the individual items, and the only duplicated information is the Bill ID, which is necessary to link the items back to the correct bill. This significantly reduces data redundancy compared to the single-table, multi-row approach.<br><b>Distractor Rationale:</b><ul><li>a) This method works but creates significant data duplication.</li><li>b) This is not a standard or efficient table structure.</li><li>d) This doesn't solve the problem of a single customer having multiple bills with multiple items.</li></ul>"
"Consider the following pseudocode:<br>Procedure SumSubject(gender_param, subject_param)<br>  Sum = 0<br>  while (Pile 1 has more cards) {<br>    Read card X from Pile 1<br>    if (X.Gender == gender_param) {<br>      Sum = Sum + X.subject_param<br>    }<br>    Move X to Pile 2<br>  }<br>  return(Sum)<br>End Procedure<br>What does the call SumSubject(F, Total) compute?<ul><li>a) The sum of total marks for all female students.</li><li>b) The sum of marks in the 'F' subject for all students.</li><li>c) The total number of female students.</li><li>d) The average total marks for female students.</li></ul>";"Correct: a)";"<b>Explanation:</b> The procedure is called with two parameters. The first, gender_param, is set to 'F'. The second, subject_param, is set to 'Total'. The procedure iterates through all cards, and for each card where the gender is 'F', it adds the value from the 'Total' field to the Sum. Therefore, it calculates the sum of total marks for all female students.<br><b>Distractor Rationale:</b><ul><li>b) 'F' is a value used for comparison, not a subject name.</li><li>c) The procedure sums marks, it does not count students.</li><li>d) The procedure calculates the sum, not the average (which would require dividing by the count).</li></ul>"
"In pseudocode, what is the term for a value, like 'M' or 'Physics', that is passed to a procedure to customize its execution?<ul><li>a) A variable</li><li>b) A return value</li><li>c) A parameter</li><li>d) A side effect</li></ul>";"Correct: c)";"<b>Explanation:</b> A parameter is a piece of information provided to a procedure when it is called. The procedure uses the parameter's value to alter its behavior, such as filtering by a specific gender ('M') or accessing a particular data field ('Physics').<br><b>Distractor Rationale:</b><ul><li>a) A variable is a storage location for data within the code, while a parameter is specifically about passing data into a procedure.</li><li>b) A return value is data passed out of a procedure.</li><li>d) A side effect is a modification of data outside the procedure's local scope.</li></ul>"
"A procedure UpdateMarks(CardId, Subject, Marks) is called. It finds the specified card and updates the marks for the given subject. This procedure does not return any value. This is an example of a procedure called for its...<ul><li>a) return value</li><li>b) parameter</li><li>c) side effect</li><li>d) interface</li></ul>";"Correct: c)";"<b>Explanation:</b> The primary purpose of this procedure is to modify the state of the data (the marks on a card). Any modification of data outside of the procedure's own local variables is known as a side effect. In this case, the side effect is the intended and desired outcome.<br><b>Distractor Rationale:</b><ul><li>a) The procedure is explicitly stated not to have a return value.</li><li>b) Parameters are the inputs to the procedure, not its effect.</li><li>d) The interface is the definition of how to call the procedure, not the result of calling it.</li></ul>"
"A procedure is designed to find the maximum score in a subject but has an unintended side effect of reversing the order of the card pile it was given. In which of the following scenarios would this side effect be most problematic?<ul><li>a) The pile was randomly shuffled before being passed to the procedure.</li><li>b) The procedure is only called once.</li><li>c) The pile was sorted by student name before being passed to the procedure.</li><li>d) The pile contains cards for both male and female students.</li></ul>";"Correct: c)";"<b>Explanation:</b> If effort was made to put the data in a specific order (e.g., sorted by name), an unintended reordering (like reversal) destroys that work. The caller might be expecting the pile to remain sorted for a subsequent operation, which would now fail or produce incorrect results. This makes the side effect highly undesirable.<br><b>Distractor Rationale:</b><ul><li>a) If the pile is already in a random order, reversing it just results in a different random order, which is likely not a problem.</li><li>b) The number of calls doesn't change the fact that the order is lost.</li><li>d) The gender of students is irrelevant to the problem of data ordering.</li></ul>"
"When finding the top three values in a list of scores, why is it necessary to handle the case where a new score is greater than the current max differently from when it's between max and secondmax?<ul><li>a) Because a new max value requires shifting the old max to secondmax and the old secondmax to thirdmax.</li><li>b) Because a new max value means the procedure must restart from the beginning.</li><li>c) It is not necessary; the update logic is the same for all cases.</li><li>d) Because a new max value requires re-initializing all variables to 0.</li></ul>";"Correct: a)";"<b>Explanation:</b> If a new score is the highest seen so far, it displaces the entire top-three ranking. The old max is no longer the max, but it becomes the new secondmax. Consequently, the old secondmax becomes the new thirdmax. This cascade of updates is different from when a new score only fits between max and secondmax, which only requires updating secondmax and thirdmax.<br><b>Distractor Rationale:</b><ul><li>b) The procedure can handle the update dynamically without restarting.</li><li>c) The update logic is different; a new max requires a 3-variable shift, while a new second-max requires a 2-variable shift.</li><li>d) Re-initialization is not required.</li></ul>"
"A procedure TopThreeMarks(Subj) is used to find the third-highest mark in a subject. What is the primary reason this is sufficient for determining if a student is a 'subject topper' (in the top three)?<ul><li>a) It also implicitly returns the first and second highest marks.</li><li>b) If a student's score is greater than or equal to the third-highest mark, they must be in the top three.</li><li>c) It is the only value the procedure is capable of returning.</li><li>d) The third-highest mark is always the same as the average mark.</li></ul>";"Correct: b)";"<b>Explanation:</b> The third-highest mark acts as a threshold. By definition, any student who scored at least that much must be the third-highest, second-highest, or highest scorer. Therefore, a single comparison (StudentScore >= ThirdHighestMark) is all that is needed to answer the yes/no question of whether they are in the top three.<br><b>Distractor Rationale:</b><ul><li>a) The procedure is explicitly designed to return only one value.</li><li>c) The procedure calculates all three but is designed to return only the third for simplicity.</li><li>d) There is no relationship between the third-highest mark and the average.</li></ul>"
"In the three-prizes problem, why is it a good strategy to first calculate the third-highest marks for each subject and store them in variables (maths3, phys3, chem3) before the main loop?<ul><li>a) To ensure the main loop runs exactly three times.</li><li>b) To avoid repeatedly recalculating these same threshold values for every single student card being checked.</li><li>c) Because the procedure TopThreeMarks can only be called before a while loop.</li><li>d) To determine the total number of students in the class.</li></ul>";"Correct: b)";"<b>Explanation:</b> Calculating the top three marks requires iterating through the entire deck of cards. Doing this inside the main loop (which also iterates through the entire deck) would be extremely inefficient. It would mean that for each of the 30 students, you would re-scan all 30 cards to find the top three subject marks. By calculating these thresholds once at the beginning, you perform this expensive operation only three times (once per subject) instead of 30 * 3 = 90 times.<br><b>Distractor Rationale:</b><ul><li>a) The main loop runs once for each student, not three times.</li><li>c) Procedures can be called anywhere, including inside loops.</li><li>d) This calculation does not determine the student count.</li></ul>"
"What does a 'Boolean' value represent?<ul><li>a) A number with a decimal point.</li><li>b) A text string.</li><li>c) A state of either True or False.</li><li>d) A list of items.</li></ul>";"Correct: c)";"<b>Explanation:</b> A Boolean is a data type that has only two possible values: True or False. It is fundamental in programming for representing the result of logical comparisons and for controlling the flow of execution in conditional statements like if.<br><b>Distractor Rationale:</b><ul><li>a) This describes a floating-point number.</li><li>b) This describes a string.</li><li>d) This describes a list or array.</li></ul>"
"In the pseudocode if (A or B or C), under what condition will the entire expression be True?<ul><li>a) Only if A, B, and C are all True.</li><li>b) Only if A, B, and C are all False.</li><li>c) If at least one of A, B, or C is True.</li><li>d) Only if exactly one of A, B, or C is True.</li></ul>";"Correct: c)";"<b>Explanation:</b> The logical OR operator evaluates to True if any of its operands are True. It only evaluates to False if all of its operands are False.<br><b>Distractor Rationale:</b><ul><li>a) This describes the behavior of the and operator.</li><li>b) This is the condition for the expression to be False.</li><li>d) This describes an exclusive OR (XOR) operation, not a standard OR.</li></ul>"
"In the three-prizes problem, what is a potential 'boundary condition' or edge case that the initial pseudocode might not handle correctly?<ul><li>a) A student having a total score of 0.</li><li>b) Having more than 30 students in the dataset.</li><li>c) All three prize winners being of the same gender.</li><li>d) A student having the same mark in all three subjects.</li></ul>";"Correct: c)";"<b>Explanation:</b> The initial logic focuses on finding the top three qualified students based on marks. It does not actively enforce the gender diversity rule during the selection process. A possible outcome is that the top three students are all boys or all girls. This is a boundary condition that would require additional logic to handle, such as replacing the lowest-ranked winner with the highest-ranked winner of the underrepresented gender.<br><b>Distractor Rationale:</b><ul><li>a) A score of 0 would be handled correctly by the min/max logic.</li><li>b) The algorithm scales with the number of students.</li><li>d) This would not cause an error in the logic.</li></ul>"
"If a procedure call is used as a standalone statement, like UpdateMarks(17, Physics, 88), what can you infer about the procedure?<ul><li>a) It must return a Boolean value.</li><li>b) Its primary purpose is to cause a side effect.</li><li>c) It must not accept any parameters.</li><li>d) It is computationally very expensive.</li></ul>";"Correct: b)";"<b>Explanation:</b> If a procedure's result isn't being assigned to a variable or used in a condition, it means the caller isn't interested in any value it might return. The only reason to call such a procedure is for the action it performs—its side effect, such as modifying data, printing to the screen, or saving a file.<br><b>Distractor Rationale:</b><ul><li>a) If it returned a Boolean, it would typically be used in an if statement.</li><li>c) It is clearly accepting three parameters.</li><li>d) Its computational cost is an implementation detail, not inferable from how it's called.</li></ul>"
"What is the difference between an 'argument' and a 'parameter' in the context of procedures?<ul><li>a) They are exactly the same and the terms are always interchangeable.</li><li>b) An argument is the value passed during the call, while a parameter is the variable in the procedure's definition.</li><li>c) A parameter is the value passed during the call, while an argument is the variable in the procedure's definition.</li><li>d) Arguments are used for input, while parameters are used for output.</li></ul>";"Correct: b)";"<b>Explanation:</b> While often used interchangeably in casual conversation, there is a formal distinction. A parameter (or formal parameter) is the variable name listed in the procedure's definition (e.g., fld in Procedure SumMarks(fld)). An argument (or actual parameter) is the actual value or variable that is passed to the procedure when it is called (e.g., Physics in the call SumMarks(Physics)).<br><b>Distractor Rationale:</b><ul><li>a) There is a subtle but important formal difference.</li><li>c) This reverses the definitions.</li><li>d) Both are related to input for the procedure. The output is a return value.</li></ul>"
"Why is it necessary to perform two separate iterations (or 'passes') over the 'Scores' dataset to find all students who scored below the class average?<ul><li>a) The first pass is to sort the data, and the second is to find the average.</li><li>b) It is not necessary; it can be done in a single pass.</li><li>c) The first pass is required to calculate the final average of the entire class, which is needed as a fixed threshold for the second pass.</li><li>d) The first pass counts the boys, and the second pass counts the girls.</li></ul>";"Correct: c)";"<b>Explanation:</b> The average of the entire class can only be known after all student scores have been seen and summed. You cannot determine if a student is below the final average until the final average is calculated. Therefore, the first pass is essential to compute this overall average. The second pass then uses this calculated average as a constant value to compare each student against.<br><b>Distractor Rationale:</b><ul><li>a) Sorting is not required to find the average.</li><li>b) While you can calculate a running average, this value changes with each card, making it impossible to create a definitive list of 'below average' students until the end. This would require repeatedly re-evaluating all previously seen cards, which is far less efficient than two simple passes.</li><li>d) The task is about the overall class average, not separated by gender.</li></ul>"
"To assign grades (A, B, C, D) by dividing the range of scores (from min to max) into four equal bands, what must be calculated in the first pass through the data?<ul><li>a) The average and the total number of students.</li><li>b) Only the maximum score.</li><li>c) The minimum and maximum scores.</li><li>d) The score of every student.</li></ul>";"Correct: c)";"<b>Explanation:</b> The grading bands are defined by the range of actual scores. To know the range, you must know the lowest score (minimum) and the highest score (maximum) present in the dataset. These two values can only be determined by iterating through all the student cards once to find these extremes.<br><b>Distractor Rationale:</b><ul><li>a) The average is not needed for this specific grading method.</li><li>b) The minimum score is also required to establish the lower bound of the range.</li><li>d) While you look at every score, you only need to retain the min and max from the first pass.</li></ul>"
"If the word ""Monday"" appears 3 times in a text and has a letter count of 6, and the average letter count for all words is 5.1, how would this word be categorized based on the criteria: Frequent (count > 1) and Long (length >= 6)?<ul><li>a) Infrequent and Short</li><li>b) Frequent and Short</li><li>c) Infrequent and Long</li><li>d) Frequent and Long</li></ul>";"Correct: d)";"<b>Explanation:</b> The word ""Monday"" meets both criteria. Its frequency is 3, which is greater than 1, so it is Frequent. Its length is 6, which is greater than or equal to 6, so it is Long.<br><b>Distractor Rationale:</b><ul><li>a) It is neither infrequent nor short.</li><li>b) It is frequent, but it is not short.</li><li>c) It is long, but it is not infrequent.</li></ul>"
"A hypothesis states ""Frequent words are short words."" The data shows that out of 10 frequent words, 9 are short and 1 is long. It also shows that out of 50 infrequent words, 20 are short and 30 are long. Which statement is the strongest conclusion?<ul><li>a) The hypothesis is completely false.</li><li>b) The data strongly supports the idea that if a word is frequent, it is very likely to be short.</li><li>c) The data strongly supports the idea that if a word is short, it is very likely to be frequent.</li><li>d) The data shows no correlation between frequency and length.</li></ul>";"Correct: b)";"<b>Explanation:</b> The evidence for this specific direction is very strong: 9 out of 10 (90%) of the frequent words fit the hypothesis. This indicates a strong correlation in one direction. <br><b>Distractor Rationale:</b><ul><li>a) The hypothesis is not completely false; in fact, it is largely supported.</li><li>c) This is the reverse statement. The data shows that 9 frequent words are short, but 20 infrequent words are also short. So, out of 29 short words, only 9 are frequent (less than a third). This does not strongly support the reverse claim.</li><li>d) There is a clear correlation, especially for frequent words.</li></ul>"

"In the context of procedures, which statement best describes the relationship between 'parameters' and 'arguments'?<ul><li>a) They are identical terms with no difference.</li><li>b) A 'parameter' is the variable in the procedure's definition, while an 'argument' is the actual value passed to the procedure when it is called.</li><li>c) An 'argument' is the variable in the procedure's definition, while a 'parameter' is the actual value passed to the procedure when it is called.</li><li>d) Parameters are used for procedures that return a value, while arguments are used for procedures that do not.</li></ul>";"Correct: b)";"<b>Explanation:</b> This is the formal distinction in computer science. The procedure is defined with placeholders called parameters (e.g., Procedure SumMarks(gen, fld)). When you call the procedure, you provide actual values or variables, which are called arguments (e.g., SumMarks(F, Chemistry)).<br><b>Distractor Rationale:</b><ul><li>a) While often used interchangeably in conversation, they have distinct formal meanings.</li><li>c) This reverses the correct definitions.</li><li>d) The distinction is about definition vs. invocation, not about the procedure's return type.</li></ul>"
"A procedure is designed to find the average score for a specific subject (Subj) but contains a logical error. What is the error?<br>Procedure AvgSubj(Subj)<br>  Sum = 0, Count = 0<br>  while (Pile 1 has more cards) {<br>    Read card X from Pile 1<br>    Sum = Sum + X.Subj<br>    Count = Count + 1<br>    Move X to Pile 2<br>  }<br>  Avg = Sum / Count<br>  return(Avg)<br>End Procedure<ul><li>a) The procedure should not return a value.</li><li>b) Sum and Count are initialized incorrectly.</li><li>c) The parameter Subj is used incorrectly in the line Sum = Sum + X.Subj.</li><li>d) There are no errors in this procedure.</li></ul>";"Correct: d)";"<b>Explanation:</b> This procedure is correct. It initializes Sum and Count to 0. It iterates through all cards, correctly accumulating the score from the specified subject field (X.Subj) into Sum and incrementing the Count. Finally, it correctly calculates and returns the average. The use of X.Subj correctly indicates that the field to be accessed is determined by the Subj parameter.<br><b>Distractor Rationale:</b><ul><li>a) Returning the calculated average is the primary purpose of this procedure.</li><li>b) Initializing both Sum and Count to 0 is the correct approach.</li><li>c) The notation X.Subj is the standard way in the course's pseudocode to indicate accessing a field on card X whose name is specified by the parameter Subj.</li></ul>"
"Why is a two-pass algorithm (one to find the min/max, a second to categorize) necessary when assigning grades based on dividing the actual range of scores into equal bands?<ul><li>a) Because the average score must be calculated first.</li><li>b) Because the grade bands (e.g., 85-100 for an 'A') are unknown until the minimum and maximum scores in the dataset are determined.</li><li>c) Because students cannot be assigned a grade until all other students' grades are known.</li><li>d) It is not necessary; it can be done in a single pass.</li></ul>";"Correct: b)";"<b>Explanation:</b> The definition of the grade bands depends on the full range of scores. You cannot know the full range (i.e., the absolute minimum and maximum) until you have seen every score. Therefore, a first pass is required to establish these two values. Only then can you define the bands and use them in a second pass to assign a grade to each student.<br><b>Distractor Rationale:</b><ul><li>a) This grading method does not depend on the average score.</li><li>c) A student's grade depends only on their score and the pre-defined bands, not on other students' grades.</li><li>d) It cannot be done in a single pass because the bands themselves would keep changing as new minimums or maximums are found, requiring constant re-grading of all previous students.</li></ul>"
"Which of the following scenarios is an example of a procedure's 'interface'?<ul><li>a) Inside a procedure, a while loop is used to iterate through a pile of cards.</li><li>b) A procedure is defined as Procedure FindAverage(Deck) and is documented to return a single numerical value and not modify the order of Deck.</li><li>c) A variable named temp_max is used inside a procedure to hold the maximum value found so far.</li><li>d) A procedure runs in 5 seconds on a small dataset and 50 seconds on a large one.</li></ul>";"Correct: b)";"<b>Explanation:</b> The interface is the contract with the outside world. It specifies the procedure's name (FindAverage), the data it needs (Deck), what it provides back (a single numerical value), and its side effects (none, in this case). It tells you what the procedure does, not how it does it.<br><b>Distractor Rationale:</b><ul><li>a) A while loop is an implementation detail.</li><li>c) temp_max is a local variable, an implementation detail.</li><li>d) Performance is a characteristic of the implementation, not the interface contract.</li></ul>"
"What is a key reason to modularize code by creating procedures like TopThreeMarks(Subj)? Select all that apply.<ul><li>a) It avoids repeating complex logic, making the main code shorter and more readable.</li><li>b) If a more efficient way to find the top three marks is discovered, the code only needs to be updated in one place.</li><li>c) It allows the same logic to be reused for different subjects (Maths, Physics, etc.) by changing the parameter.</li><li>d) It guarantees the procedure will have no side effects.</li></ul>";"Correct: a), b), c)";"<b>Explanation:</b> Procedures are fundamental to good software design. They promote code reuse (c), which avoids repetition and makes the main logic easier to follow (a). They also encapsulate logic, so that improvements or bug fixes made inside the procedure are automatically applied everywhere the procedure is called (b).<br><b>Distractor Rationale:</b><ul><li>d) Creating a procedure does not guarantee it will have no side effects. Whether a procedure has side effects is a design choice that must be documented in its interface.</li></ul>"
"A procedure is created to find all students who are from Chennai AND have a total score greater than 250. Which logical operator is essential for this task?<ul><li>a) OR</li><li>b) NOT</li><li>c) AND</li><li>d) XOR</li></ul>";"Correct: c)";"<b>Explanation:</b> The task requires that both conditions be true simultaneously for a student to be selected. The AND operator is used to combine conditions in this way, returning true only if the condition on its left and the condition on its right are both true.<br><b>Distractor Rationale:</b><ul><li>a) OR would incorrectly include students from Chennai with low scores, and high-scoring students not from Chennai.</li><li>b) NOT is used to negate a single condition.</li><li>d) XOR (exclusive OR) would select students who meet one condition but not both.</li></ul>"
"If a procedure SortDeck(Deck) is called, what is its primary, intended outcome?<ul><li>a) To return the number of cards in the deck.</li><li>b) To return a Boolean value indicating if the deck is already sorted.</li><li>c) To modify the Deck parameter by reordering its cards (a side effect).</li><li>d) To create a new, sorted copy of the deck, leaving the original Deck unchanged.</li></ul>";"Correct: c)";"<b>Explanation:</b> The name SortDeck implies an action performed on the deck itself. The most common and direct way such a procedure works is by rearranging the items within the Deck that was passed to it. This modification of the input parameter is an intentional and desirable side effect.<br><b>Distractor Rationale:</b><ul><li>a) This would likely be a CountCards(Deck) procedure.</li><li>b) This would be an IsSorted(Deck) procedure.</li><li>d) While possible, this would likely be named something like CreateSortedCopy(Deck). The name SortDeck implies an in-place sort.</li></ul>"
"When finding the three lowest values, min1, min2, and min3, how must the variables be initialized?<ul><li>a) To 0, 0, 0</li><li>b) To -1, -1, -1</li><li>c) To a very large value, like 10000, 10000, 10000</li><li>d) To the values from the first three cards.</li></ul>";"Correct: c)";"<b>Explanation:</b> To find a minimum, the initial placeholder values must be guaranteed to be larger than any possible value in the data. This ensures that the first value encountered will be smaller and will correctly replace the initial placeholder. Initializing to a very large number achieves this.<br><b>Distractor Rationale:</b><ul><li>a) Initializing to 0 would fail if all data points are positive.</li><li>b) Initializing to -1 would fail if all data points are non-negative.</li><li>d) This is a possible strategy, but it's more complex as it requires special handling for the first few items. Initializing to a large value is simpler and more robust.</li></ul>"
"What is a significant risk of having a procedure with an undocumented side effect?<ul><li>a) The procedure will run more slowly.</li><li>b) The procedure will be difficult to call with the correct parameters.</li><li>c) The caller may assume the data they passed is unchanged, leading to incorrect results in subsequent operations.</li><li>d) The procedure cannot return a value.</li></ul>";"Correct: c)";"<b>Explanation:</b> If the procedure's interface (its contract) does not state that it will modify the data passed to it, the user of that procedure will rightfully assume the data remains pristine. If the procedure does modify it (e.g., reverses a sorted list), and the user then tries to perform an operation that depends on the original state (e.g., a binary search that requires a sorted list), the program will behave incorrectly.<br><b>Distractor Rationale:</b><ul><li>a) Side effects are not directly related to performance.</li><li>b) The side effect doesn't change how the procedure is called.</li><li>d) A procedure can have both a side effect and a return value.</li></ul>"
"Which of the following pseudocode fragments correctly checks if a student's Physics score is greater than or equal to the third-highest physics score, stored in a variable phys3?<ul><li>a) if (X.Physics >= phys3)</li><li>b) if (X.Physics == phys3)</li><li>c) if (X.Physics > phys3)</li><li>d) if (phys3 >= X.Physics)</li></ul>";"Correct: a)";"<b>Explanation:</b> The goal is to see if the student's score meets or exceeds the threshold for being in the top three. The threshold is the third-highest score. Therefore, the student's score (X.Physics) must be greater than or equal to (>=) this threshold (phys3).<br><b>Distractor Rationale:</b><ul><li>b) This only checks for ties with the third-highest score, excluding the first and second.</li><li>c) This excludes students who scored exactly the third-highest score.</li><li>d) This reverses the logic.</li></ul>"
"In the context of the ""Scores"" dataset, what does the expression X.Total refer to?<ul><li>a) The total number of students.</li><li>b) The average score of student X.</li><li>c) The value in the 'Total' column for the specific row (card) currently referenced by the variable X.</li><li>d) A procedure to calculate the total for student X.</li></ul>";"Correct: c)";"<b>Explanation:</b> This dot notation is a standard way to access a specific attribute (field or column) of a data record. X represents the entire record (the row or card), and .Total specifies that we want to retrieve the value stored in the Total field of that particular record.<br><b>Distractor Rationale:</b><ul><li>a) This would be a variable like StudentCount.</li><li>b) This would require a calculation like X.Total / 3.</li><li>d) This is a direct data access, not a procedure call.</li></ul>"
"If a dataset has a variable number of attributes per card (like a shopping bill with a variable number of items), what is the fundamental challenge in representing it as a single, simple table?<ul><li>a) Tables cannot store text data.</li><li>b) Simple tables require a fixed, uniform number of columns for every row.</li><li>c) Each card must have a unique ID.</li><li>d) The total amount can only be calculated at the end.</li></ul>";"Correct: b)";"<b>Explanation:</b> The defining characteristic of a simple, 'neat' table is its grid structure, where every row has the same number of columns, and each column represents the same attribute for every row. Data where the number of attributes changes from one record to the next (like a bill with 3 items vs. one with 10 items) violates this fundamental structure.<br><b>Distractor Rationale:</b><ul><li>a) Tables are perfectly capable of storing text.</li><li>c) While unique IDs are good practice, they don't solve the structural problem of variable attributes.</li><li>d) The total can be stored as a single attribute, which doesn't pose a structural problem.</li></ul>"
"A procedure is called as follows: is_frequent = CheckFrequency(word, 1). The procedure returns True if the word's count is greater than the number provided, and False otherwise. What are word and 1 in this context?<ul><li>a) Both are parameters.</li><li>b) Both are arguments.</li><li>c) word is an argument, 1 is a parameter.</li><li>d) word is a parameter, 1 is an argument.</li></ul>";"Correct: b)";"<b>Explanation:</b> When a procedure is called, the values passed into it are known as arguments. Both word (which is a variable holding a value) and the literal value 1 are being passed into the CheckFrequency procedure, so they are both arguments for this specific call.<br><b>Distractor Rationale:</b><ul><li>a) Parameters are the names in the procedure's definition, not the values in the call.</li><li>c) Both are arguments.</li><li>d) Both are arguments.</li></ul>"
"What is the final value of Count?<br>Count = 0<br>MaxVal = 80<br>Scores = [95, 75, 80, 90, 60]<br>for each Score in Scores {<br>  if (Score > MaxVal) {<br>    Count = Count + 1<br>  }<br>}<ul><li>a) 0</li><li>b) 1</li><li>c) 2</li><li>d) 5</li></ul>";"Correct: c)";"<b>Explanation:</b> The code iterates through the list of scores and increments Count only when a score is strictly greater than MaxVal (80).<br>- 95 > 80: True. Count becomes 1.<br>- 75 > 80: False.<br>- 80 > 80: False.<br>- 90 > 80: True. Count becomes 2.<br>- 60 > 80: False.<br>The final value of Count is 2.<br><b>Distractor Rationale:</b><ul><li>a) Two scores are greater than 80.</li><li>b) Two scores are greater than 80.</li><li>d) The condition is not met for all five scores.</li></ul>"
"A procedure RestoreDeck(Source, Destination) moves all cards from the Source pile to the Destination pile. If this is done one card at a time from top to bottom, what is the relationship between the final Destination pile and the original Source pile?<ul><li>a) They are identical in order.</li><li>b) The Destination pile is a reversed version of the Source pile.</li><li>c) The Destination pile is randomly shuffled.</li><li>d) The Destination pile is sorted by Card ID.</li></ul>";"Correct: b)";"<b>Explanation:</b> When you move cards from the top of one pile to the top of another, the order gets reversed. The first card you take from Source ends up at the bottom of Destination, and the last card you take from Source ends up at the top of Destination.<br><b>Distractor Rationale:</b><ul><li>a) To maintain the order, you would need an intermediate third pile.</li><li>c) The process is deterministic, not random.</li><li>d) The procedure only moves cards; it does not perform any sorting logic.</li></ul>"
"Which of the following is NOT part of a procedure's 'interface'?<ul><li>a) The name of the procedure.</li><li>b) The data type of the value it returns.</li><li>c) The algorithm used to produce the result.</li><li>d) The number and types of parameters it accepts.</li></ul>";"Correct: c)";"<b>Explanation:</b> The interface defines what the procedure does, not how it does it. The specific algorithm or step-by-step logic used inside the procedure is its implementation. The implementation can be changed or improved without affecting the interface, as long as it still accepts the same parameters and produces the same kind of result.<br><b>Distractor Rationale:</b><ul><li>a) The name is essential for calling the procedure.</li><li>b) The return type is crucial for knowing how to use the result.</li><li>d) The parameters are crucial for providing the correct input.</li></ul>"
"To find the number of students who scored exactly the class average, why is a two-pass approach generally necessary?<ul><li>a) The first pass is to find the maximum score.</li><li>b) The average score is often a fraction, and student scores are integers.</li><li>c) The final class average is unknown until all scores have been processed in the first pass.</li><li>d) The second pass is needed to sort the students by score.</li></ul>";"Correct: c)";"<b>Explanation:</b> Similar to finding students below average, you cannot know the final, precise average of the entire class until you have seen every single score. A first pass is required to sum all scores and divide by the count to get the exact average. Only then, in a second pass, can you compare each student's score to this now-known value to see if it's an exact match.<br><b>Distractor Rationale:</b><ul><li>a) The maximum score is not needed to calculate the average.</li><li>b) While true, this doesn't explain the need for two passes. The comparison can still be made.</li><li>d) Sorting is not required for this task.</li></ul>"
"What is the final value of Z?<br>A = 10<br>B = 20<br>Z = 0<br>if (A > 5 and B < 30) {<br>  Z = Z + 1<br>}<br>if (A == 10 or B == 10) {<br>  Z = Z + 1<br>}<br>if (not (A > B)) {<br>  Z = Z + 1<br>}<ul><li>a) 0</li><li>b) 1</li><li>c) 2</li><li>d) 3</li></ul>";"Correct: d)";"<b>Explanation:</b> Let's trace the execution:<br>1. A > 5 (10 > 5) is True. B < 30 (20 < 30) is True. True and True is True. Z becomes 1.<br>2. A == 10 is True. B == 10 is False. True or False is True. Z becomes 2.<br>3. A > B (10 > 20) is False. not (False) is True. Z becomes 3.<br>The final value of Z is 3.<br><b>Distractor Rationale:</b><ul><li>a) All three conditions are met.</li><li>b) All three conditions are met.</li><li>c) All three conditions are met.</li></ul>"
"When designing a procedure, what does it mean to make it 'modular'?<ul><li>a) To ensure it has as few lines of code as possible.</li><li>b) To make it a self-contained, reusable unit that performs a specific task.</li><li>c) To write the code in a way that only one programmer can understand it.</li><li>d) To ensure it can only be used with one specific type of data.</li></ul>";"Correct: b)";"<b>Explanation:</b> Modularity means breaking down a large, complex problem into smaller, manageable, and independent pieces (modules or procedures). A good procedure is self-contained (doesn't depend heavily on outside variables), performs one well-defined task, and can be reused in different parts of a program or even in different programs.<br><b>Distractor Rationale:</b><ul><li>a) While conciseness is good, it is not the primary meaning of modularity. A complex task might require a longer procedure.</li><li>c) The goal of modularity is to improve clarity and maintainability for all programmers.</li><li>d) A well-designed modular procedure is often generic and can be used with different data by using parameters.</li></ul>"
"You are given a list of words. You need to count how many words are either a ""Noun"" or have a letter count of exactly 4, but not both. Which pseudocode snippet correctly implements this logic?<ul><li>a) if (X.PartOfSpeech == ""Noun"" and X.LetterCount == 4)</li><li>b) if (X.PartOfSpeech == ""Noun"" or X.LetterCount == 4)</li><li>c) if ( (X.PartOfSpeech == ""Noun"" or X.LetterCount == 4) and not (X.PartOfSpeech == ""Noun"" and X.LetterCount == 4) )</li><li>d) if (not (X.PartOfSpeech == ""Noun""))</li></ul>";"Correct: c)";"<b>Explanation:</b> This logic describes an exclusive OR (XOR) operation. It means one condition or the other must be true, but not both. The expression (A or B) and not (A and B) is the standard way to write XOR using basic AND, OR, and NOT operators. A is X.PartOfSpeech == ""Noun"" and B is X.LetterCount == 4.<br><b>Distractor Rationale:</b><ul><li>a) This is AND, which checks if both are true.</li><li>b) This is OR, which checks if at least one is true (including the case where both are true).</li><li>d) This only checks one of the conditions.</li></ul>"