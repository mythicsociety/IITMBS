"Front";"Back";"Extra"
"For which of the following situation(s) is/are a nested loop needed? (Select all that apply)<ul><li>a) To find the pair of students who have the same birthdays from the ""Scores"" dataset</li><li>b) To find the pair of students who scored the same marks in Physics from the ""Scores"" dataset</li><li>c) To find the number of words which have highest letter count from the ""Words"" dataset</li><li>d) To find the number of bills from the same shop from the ""Shopping Bills"" dataset</li></ul>";"Correct: a), b)";"<b>Explanation:</b> Finding pairs of items within a dataset that share a common property requires comparing each item with every other item. This necessitates a nested loop structure where the outer loop selects an item and the inner loop iterates through the remaining items to compare against.<br><b>Distractor Rationale:</b><ul><li>c) Finding the words with the highest letter count can be done with a single loop. You would iterate through the words, keeping track of the maximum letter count found so far and the count of words matching that maximum.</li><li>d) Counting bills from a specific shop can be accomplished with a single loop and a filter. You iterate through the bills and increment a counter if the shop name matches the target.</li></ul>"
"The following pseudocode is executed using the ""Words"" dataset. At the end of the execution, A captures the number of sentences with at least two nouns that have at most two vowels. Choose the correct code fragments to complete the pseudocode.<br><br>1 A = 0, C = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X from Table 1<br>4   if(X.PartofSpeech == ""Noun"" and countVowels(X) <= 2) {<br>5     C = C + 1<br>6   }<br>7   if(X.word ends with a full stop) {<br>8     if(C >= 2) {<br>9       A = A + 1<br>10    }<br>11    *** Statement1 ***<br>12  }<br>13  *** Statement2 ***<br>14  Move X to Table 2<br>15 }<br><br>16 Procedure countVowels(Y)<br>17  i = 1<br>18  B = 0<br>19  while(i < Y.LetterCount) {<br>20    if(ith letter of Y.word is a vowel) {<br>21      B = B + 1<br>22    }<br>23    *** Statement3 ***<br>24  }<br>25  *** Statement4 ***<br>26  return(B)<br>27 End countVowels<ul><li>a) Statement1: C = 0<br>   Statement2: Not necessary<br>   Statement3: i = i + 1<br>   Statement4: Not necessary</li><li>b) Statement1: Not necessary<br>   Statement2: C = 0<br>   Statement3: Not necessary<br>   Statement4: i = i + 1</li><li>c) Statement1: Not necessary<br>   Statement2: C = C + 1<br>   Statement3: Not necessary<br>   Statement4: i = i + 1</li><li>d) Statement1: C = 0<br>   Statement2: Not necessary<br>   Statement3: Not necessary<br>   Statement4: i = i + 1</li></ul>";"Correct: b)";"<b>Explanation:</b> The variable 'C' counts the specific nouns within a single sentence. It must be reset to 0 after the end of each sentence is detected (when a word ends with a full stop). The 'countVowels' procedure needs to iterate through all letters of the word, so the iterator 'i' must be incremented within the while loop. Statement1 is not necessary because C should be reset after the check, not within the 'if(C >= 2)' block. Statement3 is not necessary as the logic only requires incrementing the vowel count.<br><b>Distractor Rationale:</b><ul><li>a) Placing C=0 in Statement1 resets the count before it's used for the next sentence. Placing i=i+1 in Statement3 would cause the loop to skip letters.</li><li>c) Incrementing C in Statement2 would be incorrect; it needs to be reset to 0 for the next sentence.</li><li>d) Placing C=0 in Statement1 is incorrect as explained above.</li></ul>"
"The following pseudocode is executed using the ""Library"" dataset. At the end of the execution, N captures the name of a book which has the maximum number of pages and is written in a language other than English, and A captures the number of pages in the book.<br><br>1 A = 0, N = ""None""<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   if(X.Language != ""English"" and X.Pages > A) {<br>5     A = X.Pages<br>6     N = X.Name<br>7   }<br>8   Move X to Table 2<br>9 }<br><br>If the rows of the table are shuffled in any random order, then choose the correct option(s). (Select all that apply)<ul><li>a) There will be no change in N, irrespective of the order of rows.</li><li>b) There might be a change in N, based on the order of rows.</li><li>c) There will be no change in A, irrespective of the order of rows.</li><li>d) There might be a change in A, based on the order of rows.</li></ul>";"Correct: b), c)";"<b>Explanation:</b> The variable 'A' will always find the maximum number of pages among non-English books, regardless of the order, because it's simply looking for the highest value. However, 'N' might change. If there are multiple non-English books with the exact same maximum number of pages, the one that appears first in the shuffled deck will be the one whose name is stored in 'N'. Since the condition is X.Pages > A and not >= A, once the maximum page count is found, 'N' will not be updated even if another book with the same max page count appears later.<br><b>Distractor Rationale:</b><ul><li>a) 'N' can change if multiple books tie for the maximum page count, as its final value depends on which of those books is processed first.</li><li>d) 'A' will always end up with the single highest page count value, so it is not affected by the order of rows.</li></ul>"
"The given pseudocode is executed using the ""Shopping Bills"" dataset. frac stores the ratio of the number of customers who purchased both ""Bread"" and ""Milk"" to the number of customers who purchased ""Milk"". Choose the correct code fragment to complete the pseudocode. (Assume there is at least one customer who has purchased ""Milk"").<br><br>1 mCount = 0, bCount = 0<br>2 while (Pile 1 has more cards) {<br>3   Read the top card X in Pile 1<br>4   *** Fill the code ***<br>5   Move X to Pile 2.<br>6 }<br>7 frac = bCount / mCount<br><br>8 Procedure isItem(Y, A)<br>9   C = False<br>10  while (Card Y has more items) {<br>11    Read an item Z from ItemList of card Y<br>12    if(Z.Item == A) {<br>13      C = True<br>14    }<br>15    Remove Z from ItemList of Y<br>16  }<br>17  return(C)<br>18 End isItem<ul><li>a) if(isItem(X, ""Milk"")) {<br>   mCount = mCount + 1<br>}<br>if(isItem(X, ""Bread"")) {<br>   bCount = bCount + 1<br>}</li><li>b) if(isItem(X, ""Bread"")) {<br>   bCount = bCount + 1<br>   if(isItem(X, ""Milk"")) {<br>     mCount = mCount + 1<br>   }<br>}</li><li>c) if(isItem(X, ""Milk"") and isItem(X, ""Bread"")) {<br>   mCount = mCount + 1<br>   bCount = bCount + 1<br>}</li><li>d) if(isItem(X, ""Milk"")) {<br>   mCount = mCount + 1<br>   if(isItem(X, ""Bread"")) {<br>     bCount = bCount + 1<br>   }<br>}</li></ul>";"Correct: d)";"<b>Explanation:</b> We need to count all customers who bought Milk for the denominator (mCount). Then, out of those who bought Milk, we need to count how many also bought Bread for the numerator (bCount). Option d) correctly increments mCount for every Milk purchase and then, within that condition, it checks for and increments bCount for a Bread purchase.<br><b>Distractor Rationale:</b><ul><li>a) This incorrectly counts all Bread purchasers for bCount, not just those who also bought Milk.</li><li>b) This incorrectly counts Milk purchasers for mCount only if they also bought Bread.</li><li>c) This would make mCount and bCount equal, both counting only customers who bought both items, leading to a ratio of 1.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. Two students form a study pair if their difference in Mathematics marks are at most 10. Assume that Pile P1 is always restored back after calling studyPair(Pile P1).<br><br>1 count1 = studyPair(Pile 1)<br>2 while (Pile 1 has more cards) {<br>3   Read the top card X in Pile 1<br>4   if (X.CityTown == ""Chennai"") { Move X to Pile CHN }<br>5   if (X.CityTown == ""Bengaluru"") { Move X to Pile BLR }<br>6   if (X.CityTown == ""Vellore"") { Move X to Pile VLR }<br>7 }<br>8 count2 = studyPair(Pile CHN) + studyPair(Pile BLR) + studyPair(Pile VLR)<br>9 count3 = count1 - count2<br><br>10 Procedure studyPair(Pile P1)<br>11  A = 0<br>12  while(Pile P1 has more cards) {<br>13    Read the first card X in Pile P1<br>14    Move X to Pile P2<br>15    while(Pile P1 has more cards) {<br>16      Read the top card Y in Pile P1<br>17      if(-10 <= X.Mathematics - Y.Mathematics <= 10) {<br>18        A = A + 1<br>19      }<br>20      Move Y to Pile P3<br>21    }<br>22    Move all cards from Pile P3 to Pile P1<br>23  }<br>24  return(A)<br>25 End studyPair<br><br>What will count1 represent at the end of execution?<ul><li>a) Number of study pairs</li><li>b) Number of pairs of study pair</li><li>c) Number of students who formed study pairs</li><li>d) Number of study pairs from the same city</li></ul>";"Correct: a)";"<b>Explanation:</b> The studyPair procedure takes a pile of student cards and uses a nested loop to compare every student (X) with every other student (Y). It increments a counter 'A' for each pair whose Mathematics marks differ by at most 10. count1 is the result of calling this procedure on the entire dataset (Pile 1). Therefore, count1 represents the total number of study pairs across all cities.<br><b>Distractor Rationale:</b><ul><li>b) This is nonsensical phrasing.</li><li>c) The code counts pairs, not individual students.</li><li>d) This describes count2, not count1. count1 is calculated before any city-based filtering occurs.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. Two students form a study pair if their difference in Mathematics marks are at most 10. Assume that Pile P1 is always restored back after calling studyPair(Pile P1).<br><br>1 count1 = studyPair(Pile 1)<br>2 while (Pile 1 has more cards) {<br>3   Read the top card X in Pile 1<br>4   if (X.CityTown == ""Chennai"") { Move X to Pile CHN }<br>5   if (X.CityTown == ""Bengaluru"") { Move X to Pile BLR }<br>6   if (X.CityTown == ""Vellore"") { Move X to Pile VLR }<br>7 }<br>8 count2 = studyPair(Pile CHN) + studyPair(Pile BLR) + studyPair(Pile VLR)<br>9 count3 = count1 - count2<br><br>10 Procedure studyPair(Pile P1)<br>11  A = 0<br>12  while(Pile P1 has more cards) {<br>13    Read the first card X in Pile P1<br>14    Move X to Pile P2<br>15    while(Pile P1 has more cards) {<br>16      Read the top card Y in Pile P1<br>17      if(-10 <= X.Mathematics - Y.Mathematics <= 10) {<br>18        A = A + 1<br>19      }<br>20      Move Y to Pile P3<br>21    }<br>22    Move all cards from Pile P3 to Pile P1<br>23  }<br>24  return(A)<br>25 End studyPair<br><br>What will count3 represent at the end of execution?<ul><li>a) Number of study pairs where at least one student in each pair is not from the cities Chennai, Bengaluru, and Vellore</li><li>b) Number of study pairs where the students in each pair are from different cities</li><li>c) Number of study pairs where students in each pair are from different cities among Chennai, Bengaluru and Vellore</li><li>d) Number of study pairs where students in each pair are from the same city among Chennai, Bengaluru and Vellore</li></ul>";"Correct: b)";"<b>Explanation:</b> count1 is the total number of study pairs in the entire dataset. count2 is the sum of study pairs where both students are from Chennai, both are from Bengaluru, or both are from Vellore. In other words, count2 is the number of intra-city pairs for those three specific cities. count3 is count1 - count2. This subtraction removes all the same-city pairs from the total count, leaving only the inter-city pairs (e.g., Chennai-Bengaluru, Vellore-Erode, etc.) and intra-city pairs from cities other than the main three.<br><b>Distractor Rationale:</b><ul><li>a) This is too restrictive. A pair from (Chennai, Bengaluru) would be counted in count3, but both students are from the specified cities.</li><li>c) This is also too restrictive. It implies pairs must be formed between students from Chennai, Bengaluru, and Vellore. count3 also includes pairs like (Erode, Salem).</li><li>d) This describes count2, not count3.</li></ul>"
"The following pseudocode is executed using the ""Words"" dataset.<br><br>1 count = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   Move X to Table 2<br>5   i = 1, A = False, B = False<br>6   while(i <= X.LetterCount) {<br>7     if(ith letter of X.word is a vowel) {<br>8       if(A) {<br>9         B = True<br>10      }<br>11      A = True<br>12    }<br>13    else {<br>14      A = False<br>15    }<br>16    i = i + 1<br>17  }<br>18  if(B) {<br>19    count = count + 1<br>20  }<br>21 }<br><br>What will count represent at the end of execution?<ul><li>a) Number of words with at least one pair of vowels occurring consecutively</li><li>b) Number of words with at most two pairs of vowels occurring consecutively</li><li>c) Number of words with at least two pairs of the same vowel occurring consecutively</li><li>d) Number of words with at most one pair of vowels occurring consecutively</li></ul>";"Correct: a)";"<b>Explanation:</b> The variable 'A' acts as a flag that becomes True if the current letter is a vowel. The variable 'B' becomes True only if the code finds a vowel (if(ith letter...is a vowel)) immediately after another vowel (if(A) is true from the previous iteration). Once 'B' is set to True for a word, it remains True for the rest of that word's processing. The final count is incremented only if 'B' is True, meaning the word contained at least one instance of consecutive vowels.<br><b>Distractor Rationale:</b><ul><li>b) The code does not count pairs; it just detects if at least one exists.</li><li>c) The code does not check if the vowels are the same.</li><li>d) The logic counts words with at least one pair, not at most one.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. At the end of the execution, A, B and C capture the number of pairs of students who scored at most 200, from 201 to 250 and at least 251, respectively who are from the same city but are of different gender. Choose the correct code fragment(s) to complete the pseudocode. (Select all that apply)<br><br>1 A = 0, B = 0, C = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   if(X.Total <= 200) { Move X to Table 2 }<br>5   if(X.Total >= 201 and X.Total <= 250) { Move X to Table 3 }<br>6   if(X.Total >= 251) { Move X to Table 4 }<br>7 }<br>8 A = similarTotal(Table 2)<br>9 B = similarTotal(Table 3)<br>10 C = similarTotal(Table 4)<br><br>11 Procedure similarTotal(Table T1)<br>12  D = 0<br>13  while (Table T1 has more rows) {<br>14    Read the first row Y in Table T1<br>15    Move Y to Table T2<br>16    while (Table T1 has more rows) {<br>17      Read the first row Z in Table T1<br>18      Move Z to Table T3<br>19      *** Fill the code ***<br>20    }<br>21    Move all rows from Table T3 to Table T1<br>22  }<br>23  return(D)<br>24 End similarTotal<ul><li>a) if(Y.CityTown == Z.CityTown) {<br>   if(Y.Gender != Z.Gender) {<br>     D = D + 1<br>   }<br>}</li><li>b) if(Y.Gender != Z.Gender) {<br>   if(Y.CityTown == Z.CityTown) {<br>     D = D + 1<br>   }<br>}</li><li>c) if(Y.CityTown == Z.CityTown or Y.Gender != Z.Gender) {<br>   D = D + 1<br>}</li><li>d) if(Y.CityTown == Z.CityTown and Y.Gender != Z.Gender) {<br>   D = D + 1<br>}</li></ul>";"Correct: a), b), d)";"<b>Explanation:</b> The goal is to count pairs that are from the same city AND have different genders. Options a), b), and d) all correctly implement this logic. Options a) and b) use nested if statements, which is logically equivalent to a single if statement with an and operator, as shown in option d). The order of checks (city first or gender first) does not change the final outcome.<br><b>Distractor Rationale:</b><ul><li>c) Using an or operator is incorrect. It would count pairs that share a city but not gender, pairs that have different genders but not the same city, and pairs that satisfy both. This does not match the problem's requirement.</li></ul>"
"The given pseudocode is executed using ""Scores"" dataset. Let B be a positive integer value. What does the procedure DoSomething compute? <br><br>1 Procedure DoSomething(B)<br>2   C = 0, D = 100<br>3   while (Table 1 has more rows) {<br>4     Read the first row X in Table 1<br>5     if(X.Chemistry > C) {<br>6       C = X.Chemistry<br>7     }<br>8     if(X.Chemistry < D) {<br>9       D = X.Chemistry<br>10    }<br>11    Move X to Table 2<br>12  }<br>13  if(C - D >= B) {<br>14    return (False)<br>15  }<br>16  else {<br>17    return (True)<br>18  }<br>19 End DoSomething<ul><li>a) Returns True if and only if the difference between the maximum Chemistry marks and the minimum Chemistry marks is at least B</li><li>b) Returns True if and only if the difference between the maximum Chemistry marks and the minimum Chemistry marks is at most B</li><li>c) Returns True if and only if the difference between the maximum Chemistry marks and the second maximum Chemistry marks is at most B</li><li>d) Returns True if and only if the difference between the maximum Chemistry marks and the minimum Chemistry marks is less than B</li></ul>";"Correct: d)";"<b>Explanation:</b> The loop iterates through all student cards to find the maximum Chemistry score (stored in C) and the minimum Chemistry score (stored in D). After the loop, it checks if the range (C - D) is greater than or equal to B. If it is, it returns False. Otherwise (meaning C - D is less than B), it returns True. Therefore, the procedure returns True if and only if the range of Chemistry marks is less than B.<br><b>Distractor Rationale:</b><ul><li>a) This describes the condition for returning False, not True.</li><li>b) This is incorrect because if the difference is exactly B, the procedure returns False. 'At most B' includes B.</li><li>c) The variable D finds the absolute minimum, not the second maximum.</li></ul>"
"The following pseudocode is executed using the ""Words"" dataset. At the end of the execution, C captures the number of nouns with letter count at least four and at most eight. But the pseudocode may have mistakes. Identify all such mistakes (if any). (Select all that apply)<br><br>1 C = 0<br>2 while (Table 1 has more cards) {<br>3   Read the first row X from Table 1<br>4   if (CheckSomething(X, 4, 8)){<br>5     C = C + 1<br>6   }<br>7   Move X to Table 2<br>8 }<br><br>9 Procedure CheckSomething(Y, C1, C2)<br>10  if (Y.PartOfSpeech == ""Noun"") {<br>11    if(C1 <= Y.LetterCount and Y.LetterCount <= C2) {<br>12      return (True)<br>13    }<br>14    else {<br>15      return (False)<br>16    }<br>17  }<br>18  else {<br>19    return (True)<br>20  }<br>21 End CheckSomething<ul><li>a) Line 4: Incorrect parameters used to call the procedure</li><li>b) Line 5: C is wrongly updated</li><li>c) Line 11: Incorrect conditional statement</li><li>d) Line 19: Incorrect value for return</li></ul>";"Correct: d)";"<b>Explanation:</b> The procedure is intended to return True only for nouns within a specific length range. The logic correctly handles this in lines 10-16. However, if the word is not a noun (the else block on line 18), the procedure incorrectly returns True. It should return False for any word that is not a noun, so that the main loop does not increment the counter C.<br><b>Distractor Rationale:</b><ul><li>a) The parameters (X, 4, 8) are passed correctly to check for letter counts between 4 and 8.</li><li>b) C is correctly incremented by 1 when the procedure returns True.</li><li>c) The condition C1 <= Y.LetterCount and Y.LetterCount <= C2 correctly checks if the letter count is within the inclusive range [C1, C2].</li></ul>"
"The following pseudocode is executed using the ""Library"" dataset. At the end of the execution, A captures the number of pairs of books which are published in the same genre and in the same year but in different languages. But the pseudocode may have mistakes. Identify all such mistakes (if any). (Select all that apply)<br><br>1 A = 0<br>2 while (Table 1 has more cards) {<br>3   Read the first row X from Table 1<br>4   Move X to Table 2<br>5   while (Table 1 has more rows) {<br>6     Read the first row Y from Table 1<br>7     B = False, C = False, D = True<br>8     if(X.Genre == Y.Genre) { B = True }<br>9     if(X.Year == Y.Year) { C = True }<br>10    if(X.Language == Y.Language) { D = False }<br>11    if(B and C and D) {<br>12      A = A + 1<br>13    }<br>14    Move Y to Table 3<br>15  }<br>16  Move all rows from Table 3 to Table 1<br>17 }<ul><li>a) Line 1: A is initialized with wrong value</li><li>b) Line 8: B is updated with wrong value</li><li>c) Line 9: C is updated with wrong value</li><li>d) Line 10: D is updated with wrong value</li><li>e) No errors</li></ul>";"Correct: e)";"<b>Explanation:</b> The logic correctly implements the requirements. A is a counter, so it must be initialized to 0. The nested loops correctly form pairs of books. The flags B, C, and D are used to check the conditions. B becomes True for same genre. C becomes True for same year. D is initialized to True and becomes False only for same language, effectively meaning D is True for different languages. The final if(B and C and D) correctly checks if all three conditions (same genre, same year, different language) are met before incrementing the counter A.<br><b>Distractor Rationale:</b><ul><li>a) A counter must start at 0.</li><li>b) The logic for flag B is correct.</li><li>c) The logic for flag C is correct.</li><li>d) The logic for flag D correctly identifies different languages.</li></ul>"
"For which of the following situations is a nested loop needed? Assume that no procedure is used. (Select all that apply)<ul><li>a) To find the number of authors who have written a book in ""French"" in 2007 from the ""Library"" dataset.</li><li>b) To find the number of pair of students who have scored the same Physics marks from the ""Scores"" dataset</li><li>c) To find the number of players who have won the medal in ""Wrestling"" from the ""Sports"" dataset</li><li>d) To find the number of students with at least two vowels in their name from the ""Scores"" dataset.</li></ul>";"Correct: b), d)";"<b>Explanation:</b> A nested loop is required when you need to perform an operation for each item in a set against other items in the same or another set. <br>b) Finding pairs of students with the same score requires comparing each student to every other student. <br>d) To count vowels in a student's name, you need an outer loop to iterate through students and an inner loop to iterate through the letters of each student's name.<br><b>Distractor Rationale:</b><ul><li>a) This can be done with a single loop and a filter checking for language ""French"" AND year 2007.</li><li>c) This is a simple counting task with a single loop and a filter for the sport ""Wrestling"".</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. Assume that length(x) is a procedure that returns the number of letters present in a word x. What will A represent at the end of the execution?<br><br>1 A = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   i = 1, B = True<br>5   C = X.Name<br>6   while(i <= length(C)) {<br>7     if(ith letter of C is a vowel) {<br>8       B = False<br>9     }<br>10    i = i + 1<br>11  }<br>12  if(B) {<br>13    A = A + 1<br>14  }<br>15  Move X to Table 2<br>16 }<ul><li>a) Number of students whose names are without vowels</li><li>b) Number of students whose names have at most one vowel</li><li>c) Number of students whose names have exactly one vowel</li><li>d) Number of students whose names have at least one vowel</li></ul>";"Correct: a)";"<b>Explanation:</b> The variable 'B' is initialized to True for each student. The inner loop iterates through the letters of the student's name. If it finds even a single vowel, it sets 'B' to False. 'A' is only incremented if 'B' remains True after the inner loop finishes. This means 'A' only counts students for whom the inner loop never found a vowel.<br><b>Distractor Rationale:</b><ul><li>b) If a name has one vowel, 'B' will become False, and 'A' will not be incremented.</li><li>c) Same reason as b).</li><li>d) Same reason as b).</li></ul>"
"The following pseudocode is executed using the ""Library"" dataset. What will C represent at the end of the execution? Assume that there is only one row corresponding to each author in the ""Library"" dataset.<br><br>1 C = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   Move X to Table 2<br>5   while(Table 1 has more rows) {<br>6     Read the first row Y in Table 1<br>7     if(findPair(X, Y)) {<br>8       C = C + 1<br>9     }<br>10    Move Y to Table 3<br>11  }<br>12  Move all rows from Table 3 to Table 1<br>13 }<br><br>14 Procedure findPair(X, Y)<br>15  if(X.Genre == Y.Genre and X.Language != Y.Language) {<br>16    return (True)<br>17  }<br>18  else {<br>19    return (False)<br>20  }<br>21 End findPair<ul><li>a) Number of authors who have written different genre books in same language</li><li>b) Number of pairs of authors who have written different genre books in same language</li><li>c) Number of authors who have written same genre books in different language</li><li>d) Number of pairs of authors who have written same genre books in different language</li></ul>";"Correct: d)";"<b>Explanation:</b> The nested while loops ensure that every author (X) is compared with every other author (Y). The findPair procedure returns True only when two conditions are met: the genres are the same (X.Genre == Y.Genre) and the languages are different (X.Language != Y.Language). The counter C is incremented for every pair that satisfies these conditions. Therefore, C counts the number of pairs of authors who have written books in the same genre but in different languages.<br><b>Distractor Rationale:</b><ul><li>a) The code counts pairs of authors, not individual authors. The genre/language condition is also inverted.</li><li>b) The genre/language condition is inverted.</li><li>c) The code counts pairs of authors, not individual authors.</li></ul>"
"Two words are said to be special if they fulfill following conditions:<br><ul><li>Number of vowels are same in both the words</li><li>Number of consonants are not same in both the words</li></ul>The given pseudocode is executed using the ""Words"" dataset. The variable count in the given pseudocode counts the number of special pairs. Choose the correct code fragment(s) to complete the pseudocode.<br><br>1 count = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   Move X to Table 2<br>5   while (Table 1 has more rows) {<br>6     Read the first row Y in Table 1<br>7     *** Fill here ***<br>8     Move Y to Table 3<br>9   }<br>10  Move all rows from Table 3 to Table 1<br>11 }<br><br>12 Procedure vCount(Z)<br>13   vowelCount = 0, i = 1<br>14   while(i <= Z.LetterCount){<br>15     if(ith letter of Z.Word is a vowel) {<br>16       vowelCount = vowelCount + 1<br>17     }<br>18     i = i + 1<br>19   }<br>20   return(vowelCount)<br>21 End vCount<ul><li>a) if (X.LetterCount == Y.LetterCount) {<br>   if(vCount(X) == vCount(Y)){<br>     count = count + 1<br>   }<br>}</li><li>b) if(X.LetterCount != Y.LetterCount) {<br>   if(vCount(X) == vCount(Y)) {<br>     count = count + 1<br>   }<br>}</li><li>c) if(X.LetterCount == Y.LetterCount) {<br>   if(vCount(X) != vCount(Y)) {<br>     count = count + 1<br>   }<br>}</li><li>d) if(X.LetterCount != Y.LetterCount) {<br>   if(vCount(X) != vCount(Y)) {<br>     count = count + 1<br>   }<br>}</li></ul>";"Correct: b)";"<b>Explanation:</b> The two conditions for a special pair are same vowel count and different consonant count. The total LetterCount is the sum of vowels and consonants. If two words have the same vowel count (vCount(X) == vCount(Y)), the only way for them to have a different consonant count is if their total LetterCount is also different. Therefore, the correct logic is to check for X.LetterCount != Y.LetterCount and vCount(X) == vCount(Y).<br><b>Distractor Rationale:</b><ul><li>a) If the total letter counts are the same and the vowel counts are the same, the consonant counts must also be the same. This is the opposite of what is required.</li><li>c) This checks for different vowel counts, which violates the first condition.</li><li>d) This checks for different vowel counts, which violates the first condition.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. The variables M, P and C store the number of students in Mathematics, Physics and Chemistry clubs respectively.<br><br>1 M = 0, P = 0, C = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   subject = maxSubject(X)<br>5   if(X.subject > 90){<br>6     if(subject == ""Mathematics""){ M = M + 1 }<br>7     if(subject == ""Physics""){ P = P + 1 }<br>8     if(subject == ""Chemistry""){ C = C + 1 }<br>9   }<br>10  Move X to Table 2<br>11 }<br><br>12 Procedure maxSubject(Z)<br>13   if(Z.Chemistry > Z.Mathematics){<br>14     if(Z.Chemistry > Z.Physics){ return(""Chemistry"") }<br>15     else{ return(""Physics"") }<br>16   }<br>17   else{<br>18     if(Z.Mathematics > Z.Physics) { return(""Mathematics"") }<br>19     else{ return(""Physics"") }<br>20   }<br>21 End maxSubject<br><br>Which club can a student join if he/she gets 91 marks in all three subjects?<ul><li>a) Physics</li><li>b) Chemistry</li><li>c) Mathematics</li><li>d) The student cannot join any club</li></ul>";"Correct: a)";"<b>Explanation:</b> If a student scores 91 in all subjects, the maxSubject procedure is called. First, it checks if(Z.Chemistry > Z.Mathematics). Since 91 is not greater than 91, this is false, and the code proceeds to the else block. Inside the else block, it checks if(Z.Mathematics > Z.Physics). Since 91 is not greater than 91, this is also false, and the code proceeds to the final else, which returns ""Physics"". The main loop then checks if the score for the returned subject (Physics) is > 90. Since 91 > 90, the student joins the Physics club.<br><b>Distractor Rationale:</b><ul><li>b) Chemistry is only returned if it is strictly greater than both other subjects.</li><li>c) Mathematics is only returned if it is not less than Chemistry and strictly greater than Physics.</li><li>d) The student's score of 91 in Physics qualifies them for that club.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. The variables M, P and C store the number of students in Mathematics, Physics and Chemistry clubs respectively.<br><br>1 M = 0, P = 0, C = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   subject = maxSubject(X)<br>5   if(X.subject > 90){<br>6     if(subject == ""Mathematics""){ M = M + 1 }<br>7     if(subject == ""Physics""){ P = P + 1 }<br>8     if(subject == ""Chemistry""){ C = C + 1 }<br>9   }<br>10  Move X to Table 2<br>11 }<br><br>12 Procedure maxSubject(Z)<br>13   if(Z.Chemistry > Z.Mathematics){<br>14     if(Z.Chemistry > Z.Physics){ return(""Chemistry"") }<br>15     else{ return(""Physics"") }<br>16   }<br>17   else{<br>18     if(Z.Mathematics > Z.Physics) { return(""Mathematics"") }<br>19     else{ return(""Physics"") }<br>20   }<br>21 End maxSubject<br><br>Can a student join more than one club?<ul><li>a) Yes, if the student has scored more than 90 marks in at least two subject</li><li>b) Yes, if the student has scored more than 90 marks in Mathematics and Chemistry</li><li>c) Yes, if the student has secured more than 90 marks and the same marks in Mathematics and Chemistry</li><li>d) No, a student cannot join more than one club</li></ul>";"Correct: d)";"<b>Explanation:</b> The maxSubject procedure is designed to return only a single string value: ""Chemistry"", ""Physics"", or ""Mathematics"". It can never return more than one subject name. In the main loop, the code checks the returned subject and increments only one counter (M, P, or C). Therefore, a student can be assigned to at most one club per the logic.<br><b>Distractor Rationale:</b><ul><li>a) Even with high scores in multiple subjects, the procedure will only return one of them based on its nested comparison logic.</li><li>b) Same as above.</li><li>c) Same as above.</li></ul>"
"The given pseudocode is executed using the ""Shopping Bills"" dataset. frac stores the ratio of the number of customers who purchased both ""Soap"" and ""Facewash"" to the number of customers who purchased ""Facewash"". Choose the correct code fragment to complete the pseudocode. (Assume there is at least one customer who has purchased ""Facewash"").<br><br>1 mCount = 0, bCount = 0<br>2 while (Pile 1 has more cards) {<br>3   Read the top card X in Pile 1<br>4   *** Fill the code ***<br>5   Move X to Pile 2.<br>6 }<br>7 frac = bCount / mCount<br><br>8 Procedure isItem(Y, A)<br>9   C = False<br>10  while (Card Y has more items) {<br>11    Read an item Z from ItemList of card Y<br>12    if(Z.Item == A) { C = True }<br>13    Remove Z from ItemList of Y<br>14  }<br>15  return(C)<br>16 End isItem<ul><li>a) if(isItem(X, ""Facewash"")){<br>   mCount = mCount + 1<br>}<br>if(isItem(X, ""Soap"")) {<br>   bCount = bCount + 1<br>}</li><li>b) if(isItem(X, ""Soap"")) {<br>   bCount = bCount + 1<br>   if(isItem(X, ""Facewash"")){<br>     mCount = mCount + 1<br>   }<br>}</li><li>c) if(isItem(X, ""Facewash"") and isItem(X, ""Soap"")) {<br>   mCount = mCount + 1<br>   bCount = bCount + 1<br>}</li><li>d) if(isItem(X, ""Facewash"")){<br>   mCount = mCount + 1<br>   if(isItem(X, ""Soap"")) {<br>     bCount = bCount + 1<br>   }<br>}</li></ul>";"Correct: d)";"<b>Explanation:</b> The goal is to calculate (buyers of both) / (buyers of Facewash). mCount should count every customer who bought ""Facewash"". bCount should only count customers who bought ""Soap"" given that they already bought ""Facewash"". Option d) correctly implements this by first checking for ""Facewash"" to increment mCount, and then nesting the check for ""Soap"" to increment bCount only for that subset of customers.<br><b>Distractor Rationale:</b><ul><li>a) This incorrectly counts all ""Soap"" buyers for bCount, regardless of whether they bought ""Facewash"".</li><li>b) This incorrectly counts ""Facewash"" buyers for mCount only if they also bought ""Soap"".</li><li>c) This makes both counters equal, counting only those who bought both, which would result in an incorrect ratio of 1.</li></ul>"
"The following pseudocode is executed using the ""Olympics"" dataset. At the end of the execution, A, B and C store the number of pairs of players from the same nation who have won same medal in different year. Assume that one player has won only one medal. Choose the correct code fragment(s) to complete the pseudocode. (Select all that apply)<br><br>1 A = 0, B = 0, C = 0<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   if(X.Medal == ""Gold"") { Move X to Table 2 }<br>5   if(X.Medal == ""Silver"") { Move X to Table 3 }<br>6   if(X.Medal == ""Bronze"") { Move X to Table 4 }<br>7 }<br>8 A = similarPlayers(Table 2)<br>9 B = similarPlayers(Table 3)<br>10 C = similarPlayers(Table 4)<br><br>11 Procedure similarPlayers(Table T1)<br>12  D = 0<br>13  while (Table T1 has more rows) {<br>14    Read the first row Y in Table T1<br>15    Move Y to Table T2<br>16    while (Table T1 has more rows) {<br>17      Read the first row Z in Table T1<br>18      Move Z to Table T3<br>19      *** Fill the code ***<br>20    }<br>21    Move all rows from Table T3 to Table T1<br>22  }<br>23  return(D)<br>24 End similarPlayers<ul><li>a) if(Y.Nationality == Z.Nationality) {<br>   if(Y.Year != Z.Year) {<br>     D = D + 1<br>   }<br>}</li><li>b) if(Y.Year != Z.Year) {<br>   if(Y.Nationality == Z.Nationality) {<br>     D = D + 1<br>   }<br>}</li><li>c) if(Y.Year != Z.Year and Y.Nationality == Z.Nationality) {<br>   D = D + 1<br>}</li><li>d) if(Y.Year != Z.Year or Y.Nationality == Z.Nationality) {<br>   D = D + 1<br>}</li></ul>";"Correct: a), b), c)";"<b>Explanation:</b> The procedure similarPlayers is called on bins of players who won the same medal. Inside, it needs to count pairs from the same nation who won in different years. Options a), b), and c) are all logically equivalent ways to express this AND condition. Options a) and b) use nested ifs, while option c) combines them with an and operator. All three correctly identify the required pairs.<br><b>Distractor Rationale:</b><ul><li>d) Using an or operator is incorrect. It would count pairs from the same nation in the same year, and pairs from different nations in different years, neither of which matches the requirements.</li></ul>"
"The following pseudocode is executed using the ""Words"" dataset.<br><br>1 A = 0, B = 0<br>2 P = True, Q = False<br>3 while (Table 1 has more rows) {<br>4   Read the first row X in Table 1<br>5   if (X.PartOfSpeech == ""Adjective"" and P) {<br>6     P = False<br>7     Q = True<br>8   }<br>9   if(X.PartOfSpeech == ""Noun"" and Q) {<br>10    B = B + 1<br>11  }<br>12  else {<br>13    if(not Q) {<br>14      A = A + 1<br>15    }<br>16  }<br>17  if(X.Word ends with a full stop) {<br>18    P = True<br>19    Q = False<br>20  }<br>21  Move X to Table 2<br>22 }<br><br>What will A represent at the end of execution?<ul><li>a) Number of words after the first noun in every sentence which are not adjectives</li><li>b) Number of words which appear before the first adjective in every sentence</li><li>c) Number of words other than nouns which appear before the first adjective in every sentence</li><li>d) Number of words after the first adjectives in every sentence which are not nouns</li></ul>";"Correct: b)";"<b>Explanation:</b> The variable A is incremented only when not Q is true, which means when Q is False. Q is initialized to False and is only set to True when the first adjective in a sentence is found (because of the and P condition, which prevents it from triggering on subsequent adjectives). Therefore, A counts all words processed while Q is False, which are all the words up to and including the first adjective. However, the condition to increment A is in an else block tied to the noun check. This is a subtle error in the prompt's code. Assuming the intent, it counts words before the first adjective. Let's re-evaluate: A is incremented if not Q is true AND the word is not a noun that appeared after the first adjective. This means A counts all non-noun words before the first adjective, and all words (that are not nouns) after the first adjective. This logic is confusing. Let's stick to the most likely interpretation. The flag Q flips when the first adjective is seen. A is incremented when Q is false. So A counts words before the first adjective.<br><b>Distractor Rationale:</b><ul><li>a) A is not incremented after the first adjective is found, as Q becomes true.</li><li>c) The else condition is tricky, but the primary driver for A is the not Q check, which is tied to the appearance of the first adjective. It counts all words, not just non-nouns, before the first adjective.</li><li>d) A is not incremented after the first adjective.</li></ul>"
"The following pseudocode is executed using the ""Words"" dataset.<br><br>1 A = 0, B = 0<br>2 P = True, Q = False<br>3 while (Table 1 has more rows) {<br>4   Read the first row X in Table 1<br>5   if (X.PartOfSpeech == ""Adjective"" and P) {<br>6     P = False<br>7     Q = True<br>8   }<br>9   if(X.PartOfSpeech == ""Noun"" and Q) {<br>10    B = B + 1<br>11  }<br>12  else {<br>13    if(not Q) {<br>14      A = A + 1<br>15    }<br>16  }<br>17  if(X.Word ends with a full stop) {<br>18    P = True<br>19    Q = False<br>20  }<br>21  Move X to Table 2<br>22 }<br><br>What will B represent at the end of execution?<ul><li>a) Number of nouns after the second adjective in every sentence</li><li>b) Number of nouns before the second adjective in every sentence</li><li>c) Number of nouns before the first adjective in every sentence</li><li>d) Number of nouns after the first adjective in every sentence</li></ul>";"Correct: d)";"<b>Explanation:</b> The counter B is incremented only if two conditions are met: the word is a ""Noun"" AND the flag Q is True. The flag Q is initialized to False and is set to True only when the first adjective of a sentence is encountered (due to the and P check). Q remains True for the rest of the sentence. Therefore, B counts all nouns that appear after the first adjective in each sentence.<br><b>Distractor Rationale:</b><ul><li>a) The logic doesn't distinguish the second adjective; Q stays true after the first.</li><li>b) Nouns before the first adjective are processed when Q is False, so B is not incremented.</li><li>c) Same as b).</li></ul>"
"What is the formula to calculate the number of unique pairwise comparisons required for a set of N items?<ul><li>a) N * (N + 1) / 2</li><li>b) N * N</li><li>c) N * (N - 1)</li><li>d) N * (N - 1) / 2</li></ul>";"Correct: d)";"<b>Explanation:</b> For N items, the first item needs to be compared with the remaining (N-1) items. The second item with (N-2), and so on, down to the last comparison. This forms the sum (N-1) + (N-2) + ... + 1, which is mathematically equivalent to N * (N - 1) / 2. This is also the same as the combinatorial formula for choosing 2 items from N, or NC2.<br><b>Distractor Rationale:</b><ul><li>a) This formula calculates the sum of integers from 1 to N, not the number of pairs.</li><li>b) NN would count comparing each item with itself and would double-count pairs (e.g., comparing A with B and B with A).</li><li>c) N(N-1) corrects for self-comparisons but still double-counts every pair.</li></ul>"
"If you have 100 items and you want to compare every item with every other item, how many comparisons are needed?<ul><li>a) 100</li><li>b) 9900</li><li>c) 4950</li><li>d) 5000</li></ul>";"Correct: c)";"<b>Explanation:</b> Using the formula N * (N - 1) / 2, we can calculate the number of comparisons. With N = 100, the calculation is 100 * (100 - 1) / 2, which simplifies to 100 * 99 / 2, or 9900 / 2, resulting in 4950 comparisons.<br><b>Distractor Rationale:</b><ul><li>a) 100 would mean comparing each item only once, which is incorrect for pairwise comparisons.</li><li>b) 9900 is the result of N * (N-1), which double-counts all the pairs.</li><li>d) 5000 is a close estimate but not the precise calculation.</li></ul>"
"What is the primary motivation for using ""binning"" as a strategy when dealing with problems that require many comparisons?<ul><li>a) To increase the total number of items processed.</li><li>b) To significantly reduce the total number of comparisons required.</li><li>c) To ensure every item is compared with every other item.</li><li>d) To sort the items in alphabetical order before comparison.</li></ul>";"Correct: b)";"<b>Explanation:</b> Binning involves grouping items based on a shared characteristic. This allows comparisons to be performed only within each bin, rather than across the entire dataset. If the bins are reasonably sized, this dramatically reduces the total number of pairwise comparisons from a quadratic growth (N^2) to a more manageable number.<br><b>Distractor Rationale:</b><ul><li>a) Binning organizes existing items; it doesn't increase their count.</li><li>c) The very purpose of binning is to avoid comparing every item with every other item by using a heuristic to exclude impossible pairs.</li><li>d) Sorting is a different organizational strategy and is not the primary purpose of binning for comparison reduction.</li></ul>"
"You have 90 items that need pairwise comparison. You use a binning strategy that divides them into 10 equally-sized bins. How many comparisons are now needed in total?<ul><li>a) 360</li><li>b) 4005</li><li>c) 90</li><li>d) 36</li></ul>";"Correct: a)";"<b>Explanation:</b> With 90 items and 10 bins, each bin contains 90 / 10 = 9 items. The number of comparisons within one bin is calculated as 9 * (9 - 1) / 2 = 36. Since there are 10 such bins, the total number of comparisons is 36 * 10 = 360. This is a significant reduction from the 4005 comparisons required without binning.<br><b>Distractor Rationale:</b><ul><li>b) 4005 is the number of comparisons needed without binning (90 * 89 / 2).</li><li>c) 90 is the total number of items, not comparisons.</li><li>d) 36 is the number of comparisons for a single bin, not the total.</li></ul>"
"What is the formula for the factor of reduction in comparisons when N items are placed into K bins of equal size?<ul><li>a) (N/K - 1) / (N - 1)</li><li>b) (N - 1) / (N/K - 1)</li><li>c) N / K</li><li>d) (N * (N-1)) / K</li></ul>";"Correct: b)";"<b>Explanation:</b> The reduction factor is the ratio of the original number of comparisons to the new number of comparisons. Original = (N*(N-1))/2. New = K * ((N/K)(N/K-1))/2 = (N(N/K-1))/2. The ratio is [(N*(N-1))/2] / [(N*(N/K-1))/2], which simplifies to (N-1) / (N/K - 1).<br><b>Distractor Rationale:</b><ul><li>a) This is the inverse of the correct formula.</li><li>c) This is the size of each bin, not the reduction factor.</li><li>d) This expression does not represent the reduction factor.</li></ul>"
"In the ""loyal customer"" problem, where the goal is to find customers who only shop at one store, what is the most efficient approach?<ul><li>a) Use a nested loop to compare every bill with every other bill to find matching customer names.</li><li>b) First, bin all the shopping bills by customer name, then iterate through each customer's bin to check for multiple shop names.</li><li>c) Iterate through the bills once, keeping a count of how many times each shop appears.</li><li>d) Use a nested loop to compare every bill with every other bill to find matching shop names.</li></ul>";"Correct: b)";"<b>Explanation:</b> The problem initially seems to require a nested loop (comparing each bill to all others). However, a more efficient method is to use binning. By creating a bin for each customer, you group all their bills together. Then, a simple, single iteration through each small bin is enough to see if more than one shop name is present. This avoids the costly nested loop across the entire dataset.<br><b>Distractor Rationale:</b><ul><li>a) This is the naive, inefficient approach that binning helps to avoid.</li><li>c) Counting shop appearances doesn't link purchases to specific customers.</li><li>d) This would find pairs of purchases at the same shop, but wouldn't identify loyal customers.</li></ul>"
"A pseudocode procedure is designed to find the maximum score for a given subject from a ""Scores"" dataset. Which of the following would be the most appropriate parameter to pass to this procedure?<ul><li>a) The entire ""Scores"" dataset.</li><li>b) The name of the subject (e.g., ""Physics"") as a string.</li><li>c) A boolean value (True/False).</li><li>d) The number of students in the dataset.</li></ul>";"Correct: b)";"<b>Explanation:</b> The procedure's core logic (iterating and comparing scores) remains the same regardless of the subject. The only part that changes is which score field to look at (e.g., X.Mathematics vs X.Physics). Therefore, the subject name is the ideal parameter, allowing the same procedure to be reused for different subjects simply by changing the input parameter value.<br><b>Distractor Rationale:</b><ul><li>a) While the procedure operates on the dataset, the dataset itself is the context, not the part that changes between calls.</li><li>c) A boolean value doesn't provide enough information to select a subject.</li><li>d) The number of students is information the procedure would determine from the dataset, not something it needs as an input to change its behavior.</li></ul>"
"What is a potential ""side effect"" of a procedure that operates on a pile of cards?<ul><li>a) The procedure returns a calculated value.</li><li>b) The procedure changes the order of the cards in the pile.</li><li>c) The procedure reads a value from a card.</li><li>d) The procedure takes a parameter.</li></ul>";"Correct: b)";"<b>Explanation:</b> A side effect is any modification the procedure makes to its input data or any state outside of its local scope, beyond just returning a value. Changing the order of the input pile of cards is a classic example of a side effect, as the state of the data given to the procedure has been altered.<br><b>Distractor Rationale:</b><ul><li>a) Returning a value is the primary, intended output of many procedures, not a side effect.</li><li>c) Reading data is a non-modifying action.</li><li>d) Taking a parameter is part of the procedure's definition, not an effect of its execution.</li></ul>"
"When is it necessary for a procedure to have ""no side effects"" on its input data, such as a deck of cards?<ul><li>a) When the procedure needs to run as fast as possible.</li><li>b) When the calling code relies on the original order of the data for subsequent steps.</li><li>c) When the procedure needs to calculate a sum.</li><li>d) It is never necessary; side effects are always acceptable.</li></ul>";"Correct: b)";"<b>Explanation:</b> If the main algorithm that calls a procedure depends on the specific order of items in a list or pile, then any procedure it calls must not permanently alter that order. If a procedure shuffles the cards, the main algorithm might fail in its next steps. In such cases, the procedure must either not change the order or restore the original order before it finishes.<br><b>Distractor Rationale:</b><ul><li>a) Managing side effects can sometimes add overhead, not reduce it.</li><li>c) Calculating a sum typically does not require a specific order.</li><li>d) Side effects can often lead to bugs and unpredictable behavior if not managed carefully.</li></ul>"
"In the problem of resolving a pronoun (e.g., ""he"") to the most recent named noun, what is the key difference between the nested loop approach and the single-pass approach?<ul><li>a) The nested loop approach is faster but uses more memory.</li><li>b) The single-pass approach uses a variable to remember the last seen noun, avoiding the need to re-scan previous words.</li><li>c) The nested loop approach can only handle one pronoun, while the single-pass approach can handle many.</li><li>d) The single-pass approach requires sorting the words by part of speech first.</li></ul>";"Correct: b)";"<b>Explanation:</b> The nested loop approach iterates forward to find a pronoun, and then starts an inner loop iterating backward to find the noun. This is inefficient. The single-pass approach is more clever: it uses a variable (e.g., last_noun_seen) to keep track of the most recent noun encountered. When a pronoun is found, it can be resolved immediately using the value in the variable, eliminating the need for the costly backward scan (the inner loop).<br><b>Distractor Rationale:</b><ul><li>a) The nested loop approach is significantly slower.</li><li>c) Both approaches can handle multiple pronouns.</li><li>d) Sorting would destroy the sentence structure needed to resolve pronouns correctly.</li></ul>"
"What is the general purpose of an accumulator variable in an iteration?<ul><li>a) To count the number of times the loop has run.</li><li>b) To store a single value from the first item in a list.</li><li>c) To create an aggregate or summary value (like a sum, count, or list) from all the items processed so far.</li><li>d) To stop the iteration when a certain condition is met.</li></ul>";"Correct: c)";"<b>Explanation:</b> An accumulator is a variable used to progressively build up a result as the iteration proceeds. It 'accumulates' information from each item. Common examples include summing numbers, counting items that meet a criteria, or building a new list of filtered items.<br><b>Distractor Rationale:</b><ul><li>a) While a loop counter is a type of accumulator, the general purpose is broader, covering sums, averages, etc.</li><li>b) An accumulator collects information from multiple items, not just the first one.</li><li>d) The loop's while condition is responsible for stopping the iteration, not the accumulator variable itself.</li></ul>"
"Which of these tasks would require two separate, sequential iterations (one after the other) rather than a single iteration?<ul><li>a) Finding the total number of students in a class.</li><li>b) Finding the highest Physics score in a class.</li><li>c) Finding all students who scored above the class average.</li><li>d) Finding the number of students from Chennai.</li></ul>";"Correct: c)";"<b>Explanation:</b> To find students who scored above average, you must first know what the average is. This requires a first iteration (pass) through all the data to calculate the sum and then the average. Only then can you perform a second iteration to compare each student's score against that calculated average. The other tasks can all be completed in a single pass.<br><b>Distractor Rationale:</b><ul><li>a) A simple count can be done in one pass.</li><li>b) Finding the maximum can be done in one pass by keeping track of the highest value seen so far.</li><li>d) Counting students from Chennai is a simple filtering and counting operation that can be done in one pass.</li></ul>"
"A filtering condition inside an iterator compares an item's value with a variable (e.g., if (X.Score > max_score)). What is a key characteristic of this type of filtering?<ul><li>a) The filtering condition remains constant throughout the iteration.</li><li>b) The filtering condition can change at each step of the iteration.</li><li>c) This type of filtering can only be used to find minimum values.</li><li>d) This type of filtering requires a nested loop.</li></ul>";"Correct: b)";"<b>Explanation:</b> When the comparison is against a variable that is updated within the loop (like max_score), the condition itself effectively changes. In the beginning, max_score might be 0, so many items pass the filter. Later, as max_score is updated to a higher value, fewer items will satisfy the condition. This dynamic condition is essential for algorithms like finding a maximum or minimum.<br><b>Distractor Rationale:</b><ul><li>a) This is true only if the comparison is against a constant value.</li><li>c) It is used for finding maximums as well.</li><li>d) This type of filtering is commonly used in single loops.</li></ul>"
"Which data structure is most appropriate for storing an item with multiple named fields of different data types, such as a student's name (string), ID (integer), and date of birth (date)?<ul><li>a) List</li><li>b) Record</li><li>c) Boolean</li><li>d) String</li></ul>";"Correct: b)";"<b>Explanation:</b> A record (or struct/object in many programming languages) is specifically designed to bundle together multiple pieces of data, where each piece (field) has its own name and can have a different data type. A list, by contrast, typically holds items of the same data type.<br><b>Distractor Rationale:</b><ul><li>a) A list is a collection of items, usually of the same type, and doesn't have named fields for its elements.</li><li>c) A boolean is a simple data type representing true or false.</li><li>d) A string is a sequence of characters.</li></ul>"
"What is the primary difference between an iteration pattern that compares an element to an aggregate of all elements, and one that compares an element to another specific element?<ul><li>a) The first requires a single loop, the second requires a nested loop.</li><li>b) The first requires a nested loop, the second requires two sequential loops.</li><li>c) The first requires two sequential loops, the second requires a nested loop.</li><li>d) Both require a single loop.</li></ul>";"Correct: c)";"<b>Explanation:</b> To compare an element to an aggregate (like the average), you first need to compute that aggregate. This takes one full iteration. Then, you need a second, sequential iteration to perform the comparison for each element. To compare every element with every other element (pairwise comparison), you need a nested loop structure, where the outer loop picks an element and the inner loop iterates through the others to compare against it.<br><b>Distractor Rationale:</b><ul><li>a) Comparing to an aggregate requires two loops, not one.</li><li>b) The requirements are reversed.</li><li>d) Neither can be accomplished with just a single loop.</li></ul>"
"If a pseudocode while loop starts with the condition while (Pile 1 has more cards), what is the implicit stopping condition?<ul><li>a) When a card from ""Chennai"" is found.</li><li>b) When the loop has run 10 times.</li><li>c) When Pile 1 becomes empty.</li><li>d) When a procedure is called.</li></ul>";"Correct: c)";"<b>Explanation:</b> The while loop continues to execute as long as its condition is true. The condition Pile 1 has more cards will be true until the last card is moved out of Pile 1. At that point, the pile will have no more cards, the condition will become false, and the iteration will stop.<br><b>Distractor Rationale:</b><ul><li>a) This would require an explicit if condition and a break statement, which is not part of the while condition itself.</li><li>b) This would require a counter variable and a check against that counter in the condition.</li><li>d) Calling a procedure does not inherently stop the loop.</li></ul>"
"What is the purpose of the initialization step in an iterative process?<ul><li>a) To define the final output of the algorithm.</li><li>b) To set the starting values for any variables, such as counters or accumulators, before the loop begins.</li><li>c) To check if the input data is valid.</li><li>d) To move all cards from one pile to another.</li></ul>";"Correct: b)";"<b>Explanation:</b> Before an iteration starts, any variables that will be used to track state or accumulate results must be set to a known starting value. For example, a counter must be initialized to 0, a sum to 0, or a max_value variable to a very small number. This ensures the first step of the loop operates correctly.<br><b>Distractor Rationale:</b><ul><li>a) The final output is determined at the end of the iteration, not the beginning.</li><li>c) Data validation is a separate concern, though it can be part of an initial setup.</li><li>d) Moving cards is an action performed within the loop, not during initialization.</li></ul>"
"Which of the following flowchart symbols is used to represent a decision point, such as the condition in a while or if statement?<ul><li>a) A rectangle with rounded corners (terminal symbol).</li><li>b) A rectangle with sharp corners (process symbol).</li><li>c) A diamond shape (decision symbol).</li><li>d) An arrow.</li></ul>";"Correct: c)";"<b>Explanation:</b> In standard flowcharts, the diamond shape is used exclusively to represent a point where a decision is made. It has one entry point and typically two exit points, labeled with outcomes like ""Yes/No"" or ""True/False"".<br><b>Distractor Rationale:</b><ul><li>a) The terminal symbol is used for ""Start"" and ""End"" points.</li><li>b) The process symbol is used for actions and assignment statements.</li><li>d) Arrows indicate the flow of control from one step to the next.</li></ul>"
"A procedure is written to find all loyal customers from a shopping bill dataset. The procedure bins the bills by customer name and then checks each bin. What is a key assumption for this binning strategy to be efficient?<ul><li>a) All customers have purchased the same number of items.</li><li>b) The bills are already sorted by date.</li><li>c) The number of bills per customer is significantly smaller than the total number of bills.</li><li>d) There is only one loyal customer in the dataset.</li></ul>";"Correct: c)";"<b>Explanation:</b> The efficiency of binning comes from breaking a large problem into many smaller ones. If one customer accounts for almost all the bills, their bin would be very large, and the processing for that bin would still be slow. The strategy is most effective when the items (bills) are distributed across many bins, making each individual bin quick to process.<br><b>Distractor Rationale:</b><ul><li>a) The number of items is irrelevant to the logic of finding loyal customers based on shops visited.</li><li>b) The order of bills does not affect the efficiency of this particular binning strategy.</li><li>d) The efficiency of the algorithm does not depend on the number of loyal customers it ultimately finds.</li></ul>"
"You are creating study pairs of students based on their scores. The first step is to bin students into groups with similar total scores (e.g., 200-225, 226-250). What is the next logical step inside each bin to find pairs where one student is strong in Math and the other in Physics?<ul><li>a) Pair the student with the highest total score with the one with the lowest total score.</li><li>b) Sub-divide the bin into two groups: one where Math > Physics, and one where Physics > Math, then form pairs between these two groups.</li><li>c) Sort the students in the bin by name alphabetically.</li><li>d) Calculate the average chemistry score for the bin.</li></ul>";"Correct: b)";"<b>Explanation:</b> The goal is to find complementary strengths. Within a bin of students with similar overall ability (total score), the most direct way to find complementary pairs is to separate them into those who are relatively better at Math and those who are relatively better at Physics. Then, you can efficiently create pairs by picking one student from each sub-group.<br><b>Distractor Rationale:</b><ul><li>a) Total scores are already similar within the bin; this step wouldn't be very useful.</li><li>c) Sorting by name is irrelevant to academic strengths.</li><li>d) Chemistry scores are not relevant to the Math/Physics pairing goal.</li></ul>"
"The number of comparisons required for a pairwise check grows quadratically with the number of items N. What does this imply?<ul><li>a) The number of comparisons grows at a steady, constant rate.</li><li>b) The time taken to perform the comparisons will double if the number of items doubles.</li><li>c) The number of comparisons increases at an accelerating rate as N gets larger.</li><li>d) The number of comparisons is directly proportional to N.</li></ul>";"Correct: c)";"<b>Explanation:</b> A quadratic relationship (proportional to N^2) means that the growth is not linear. As N increases, the increase in the number of comparisons for each additional item becomes larger and larger. This leads to an accelerating, upward-curving growth pattern, which can quickly become computationally expensive.<br><b>Distractor Rationale:</b><ul><li>a) This describes linear growth, not quadratic.</li><li>b) If the number of items doubles from N to 2N, the comparisons will increase by a factor of approximately 4 (from N^2 to (2N)^2 = 4N^2), not 2.</li><li>d) This describes a linear relationship (proportional to N), not quadratic.</li></ul>"
"You have a dataset of 1000 students. You bin them by their city of origin into 20 bins of equal size. What is the approximate reduction factor in the number of pairwise comparisons you have to perform?<ul><li>a) 4.1</li><li>b) 20.4</li><li>c) 50</li><li>d) 1000</li></ul>";"Correct: b)";"<b>Explanation:</b> The reduction factor is (N-1) / (N/K - 1). Here, N=1000 and K=20. So, N/K = 50. The formula becomes (1000 - 1) / (50 - 1) = 999 / 49, which is approximately 20.38. By binning, you are doing about 20 times fewer comparisons.<br><b>Distractor Rationale:</b><ul><li>a) This value is too low and does not reflect the significant savings from binning.</li><li>c) 50 is the size of each bin (N/K), not the reduction factor.</li><li>d) 1000 is the total number of students.</li></ul>"
"A procedure is defined as Procedure FindAverage(CardPile). In this context, what is CardPile?<ul><li>a) A variable that stores the final average.</li><li>b) A constant value, like the number 100.</li><li>c) A parameter, representing the input data the procedure will operate on.</li><li>d) A side effect of the procedure.</li></ul>";"Correct: c)";"<b>Explanation:</b> In a procedure definition, the names within the parentheses are parameters. They act as placeholders for the actual data that will be provided when the procedure is called. Here, CardPile is a parameter that will hold the specific pile of cards the procedure is asked to average.<br><b>Distractor Rationale:</b><ul><li>a) The final average would be a value returned by the procedure or stored in a local variable, not the input parameter itself.</li><li>b) A parameter is a placeholder for data, not the data itself.</li><li>c) A side effect is an action the procedure performs, not its input.</li></ul>"
"Consider the following pseudocode:<br><br>1 A = 10<br>2 B = 20<br>3 Swap(A, B)<br>4 // What are the values of A and B here?<br><br>5 Procedure Swap(X, Y)<br>6   Temp = X<br>7   X = Y<br>8   Y = Temp<br>9 End Procedure<br><br>If the procedure Swap only modifies its local parameter variables (X and Y), what are the values of A and B at line 4?<ul><li>a) A = 20, B = 10</li><li>b) A = 10, B = 20</li><li>c) A = 20, B = 20</li><li>d) A = 10, B = 10</li></ul>";"Correct: b)";"<b>Explanation:</b> When A and B are passed to Swap, their values are copied into the local parameters X and Y. The procedure successfully swaps the values of X and Y, but these changes are confined to the procedure's scope. The original variables A and B in the main code are unaffected. This illustrates how procedures can operate without side effects on the calling code's variables.<br><b>Distractor Rationale:</b><ul><li>a) This would be the result if the procedure was able to modify the original variables directly (pass-by-reference), which is not the default behavior assumed here.</li><li>c) This implies B was changed but not A.</li><li>d) This implies A was changed but not B.</li></ul>"
"Which of the following scenarios best describes an algorithm with a ""side effect""?<ul><li>a) A procedure that takes a list of numbers and returns their sum.</li><li>b) A procedure that takes a list of student cards, sorts that same list in place by name, and returns nothing.</li><li>c) A procedure that takes a number and returns True if it's even and False otherwise.</li><li>d) A procedure that reads the first card in a pile but does not change the pile.</li></ul>";"Correct: b)";"<b>Explanation:</b> A side effect occurs when a function or procedure modifies data outside of its own local scope. Sorting the original list ""in place"" directly alters the input data structure that was passed to it. The calling part of the code will now see a sorted list, even though the procedure didn't explicitly return it. This modification of the input is a side effect.<br><b>Distractor Rationale:</b><ul><li>a) Returning a value is the intended output, not a side effect. The original list is not changed.</li><li>c) Returning a boolean value is the intended output.</li><li>d) Reading data without modifying it is not a side effect.</li></ul>"
"In an iteration to find the total cost of items on a shopping bill, a variable total_cost is initialized to 0. In each step, the item's price is added to total_cost. What is the role of the total_cost variable?<ul><li>a) Iterator</li><li>b) Parameter</li><li>c) Constant</li><li>d) Accumulator</li></ul>";"Correct: d)";"<b>Explanation:</b> total_cost is an accumulator variable. It starts with an initial value (0) and progressively 'accumulates' the sum of prices from each item processed during the iteration. Its final value represents the aggregated result of the entire process.<br><b>Distractor Rationale:</b><ul><li>a) The iterator is the loop structure itself (e.g., the while loop).</li><li>b) A parameter is an input to a procedure.</li><li>c) A constant is a value that does not change. total_cost is updated in every step.</li></ul>"
"To find the most frequently occurring word in a document, which iteration pattern is required?<ul><li>a) A single iteration.</li><li>b) Two sequential iterations: one to count frequencies of all words, and a second to find the word with the highest count.</li><li>c) A nested iteration to compare each word with every other word.</li><li>d) An iteration that stops as soon as the first word is repeated.</li></ul>";"Correct: b)";"<b>Explanation:</b> This is a classic two-pass algorithm. You cannot know which word is the most frequent until you have counted all of them. Therefore, the first iteration is needed to pass through the document and build a frequency count for every unique word (an aggregate). The second iteration is then needed to go through those counts to find the maximum value.<br><b>Distractor Rationale:</b><ul><li>a) A single iteration is insufficient because you don't have the complete frequency data until the end.</li><li>c) A nested iteration would be extremely inefficient for this task. Counting is a much better approach.</li><li>d) This would only find the first repeated word, not the most frequent one.</li></ul>"
"Which of the following is NOT a basic data type?<ul><li>a) Integer</li><li>b) Record</li><li>c) Boolean</li><li>d) Character</li></ul>";"Correct: b)";"<b>Explanation:</b> Integer, Boolean, and Character are fundamental (primitive or basic) data types that hold a single, simple value. A Record is a composite or structured data type; it is a collection of other data types (which can be basic or other records) grouped together under named fields.<br><b>Distractor Rationale:</b><ul><li>a) Integer is a basic data type for whole numbers.</li><li>c) Boolean is a basic data type for true/false values.</li><li>d) Character is a basic data type for single letters or symbols.</li></ul>"
"What is the key advantage of using a Record data type to represent a student's information instead of a List?<ul><li>a) A Record can hold more items than a List.</li><li>b) A Record allows for fields to be accessed by name (e.g., Student.Name), making the code more readable and less error-prone.</li><li>c) A List is faster to iterate through than a Record.</li><li>d) A Record ensures all data is of the same type, like all integers.</li></ul>";"Correct: b)";"<b>Explanation:</b> A Record uses named fields, which provides context and makes the code self-documenting. Accessing Student.Name is much clearer than accessing Student[0]. This reduces the risk of errors, such as mixing up the index for the name and the index for the city.<br><b>Distractor Rationale:</b><ul><li>a) Both data structures can typically hold a variable number of items (or fields).</li><li>c) The iteration speed is generally not a significant differentiator between the two in this context.</li><li>d) This is incorrect; a Record's main feature is its ability to hold fields of different data types. A List is typically used for items of the same data type.</li></ul>"
"A pseudocode algorithm needs to find if any two students in a class of 30 share the same birthday. It uses a nested loop. What is the maximum number of comparisons the inner loop will perform in a single iteration of the outer loop?<ul><li>a) 30</li><li>b) 29</li><li>c) 1</li><li>d) 435</li></ul>";"Correct: b)";"<b>Explanation:</b> The naive nested loop approach compares the student selected by the outer loop with all other students. In the very first iteration of the outer loop, it selects the first student and compares them against the remaining 29 students. As the outer loop progresses, this number will decrease, but the maximum number of comparisons for any single pass of the inner loop is 29.<br><b>Distractor Rationale:</b><ul><li>a) The inner loop compares against other students, so it wouldn't compare a student to themselves.</li><li>c) The inner loop runs multiple times.</li><li>d) 435 is the total number of unique comparisons for the entire process (30 * 29 / 2), not the number in a single inner loop pass.</li></ul>"
"In a flowchart, what does an arrow signify?<ul><li>a) The start of the program.</li><li>b) A calculation or data manipulation step.</li><li>c) A point where a yes/no question is asked.</li><li>d) The flow of control and the order of operations.</li></ul>";"Correct: d)";"<b>Explanation:</b> Arrows are the connectors in a flowchart. They indicate the direction of logical flow, showing which step should be executed after the current one is completed. They guide the reader through the sequence of the algorithm.<br><b>Distractor Rationale:</b><ul><li>a) The start is signified by a terminal symbol (rounded rectangle).</li><li>b) Calculations are shown in process symbols (rectangles).</li><li>c) Questions are asked in decision symbols (diamonds).</li></ul>"
"What is the term for a data type that puts additional constraints on the values and operations of a more general data type (e.g., defining 'Gender' which can only be 'M' or 'F' from the 'Character' type)?<ul><li>a) Supertype</li><li>b) Record</li><li>c) Subtype</li><li>d) List</li></ul>";"Correct: c)";"<b>Explanation:</b> A subtype is a more specific version of a base data type. It inherits the properties of the base type but adds constraints to limit the possible values or the operations that can be performed. This increases data sanity and clarity.<br><b>Distractor Rationale:</b><ul><li>a) A supertype is the more general type from which a subtype is derived.</li><li>b) A record is a composite data type for grouping different fields.</li><li>c) A list is a collection of elements.</li></ul>"
"When finding the maximum value in a list, the filtering condition if (current_item > max_so_far) is used. Why is it crucial that max_so_far is a variable and not a constant?<ul><li>a) Because the list contains variables, not constants.</li><li>b) To allow the benchmark for comparison to be updated as a new, higher value is found during the iteration.</li><li>c) Because constants cannot be used in if statements.</li><li>d) To reduce the number of comparisons needed.</li></ul>";"Correct: b)";"<b>Explanation:</b> The essence of the max-finding algorithm is to maintain a 'rolling' or 'running' maximum. When a new item is encountered that is larger than the current maximum, the algorithm must update its understanding of the maximum. This requires max_so_far to be a variable that can be reassigned a new value within the loop.<br><b>Distractor Rationale:</b><ul><li>a) The list contains values; the distinction between variables and constants is for the comparison logic.</li><li>c) Constants can certainly be used in if statements (e.g., if (score > 90)).</li><li>d) The number of comparisons is N-1 regardless; using a variable is about the correctness of the logic, not the number of steps.</li></ul>"
"Which computational thinking pattern is represented by the pseudocode while (Pile has more cards) { ... }?<ul><li>a) Filtering</li><li>b) Procedure Call</li><li>c) Iteration</li><li>d) Accumulation</li></ul>";"Correct: c)";"<b>Explanation:</b> The while construct is the fundamental representation of iteration in pseudocode. It defines a block of code that will be executed repeatedly as long as a specified condition (in this case, the pile not being empty) remains true.<br><b>Distractor Rationale:</b><ul><li>a) Filtering (if statement) might happen inside the iteration, but the while loop itself is the iteration pattern.</li><li>b) A procedure call would be a named statement like CalculateMax(Pile).</li><li>c) Accumulation is a task often performed within an iteration, but it is not the pattern of the loop itself.</li></ul>"
"If you need to find all pairs of students from the same city, what is the most efficient strategy? (Select all that apply)<ul><li>a) Use a nested loop comparing every student's city with every other student's city.</li><li>b) Bin the students by city, then run a nested loop on each bin to form the pairs.</li><li>c) Create one bin for each student.</li><li>d) Iterate through the list once and count how many students are in each city.</li></ul>";"Correct: b)";"<b>Explanation:</b> The naive approach (a) is very inefficient (O(N^2)). A much better way is to first group all students from the same city together using binning. Once binned, the problem is reduced to finding all pairs within each smaller group (bin). This still requires a nested loop, but it's applied to much smaller sets of data, drastically reducing the total number of comparisons.<br><b>Distractor Rationale:</b><ul><li>a) This is the brute-force, inefficient method.</li><li>c) This doesn't help group students by city.</li><li>d) This counts the students but doesn't form the pairs, which is the goal.</li></ul>"
"A procedure is called as follows: CountItems(ShoppingList, ""Milk""). What is the role of ""Milk"" in this call?<ul><li>a) It is the name of the procedure.</li><li>b) It is a variable being updated.</li><li>c) It is a parameter value, or argument, being passed to the procedure.</li><li>d) It is the return value of the procedure.</li></ul>";"Correct: c)";"<b>Explanation:</b> When a procedure is called, the values provided in the parentheses are the arguments (or actual parameters) that get assigned to the procedure's parameters. In this case, the string literal ""Milk"" is the specific value being passed to the procedure, likely to tell it which item to count.<br><b>Distractor Rationale:</b><ul><li>a) The name of the procedure is CountItems.</li><li>b) It is a fixed value being passed in, not a variable being changed.</li><li>c) The return value is what the procedure gives back after it finishes executing.</li></ul>"
"What is the primary reason that a nested iteration is considered computationally ""costly""?<ul><li>a) It requires more memory to store variables.</li><li>b) The total number of operations grows quadratically (e.g., proportional to N^2) with the size of the input data.</li><li>c) It can only be written using while loops, not other loop types.</li><li>d) It often involves complex procedure calls.</li></ul>";"Correct: b)";"<b>Explanation:</b> The costliness of nested loops comes from the multiplicative effect on the number of operations. If an outer loop runs N times and the inner loop also runs approximately N times for each of those outer iterations, the total number of operations performed by the inner loop's body will be around N * N, or N^2. This quadratic growth means the execution time can become very long, very quickly, as N increases.<br><b>Distractor Rationale:</b><ul><li>a) While variables are used, the memory usage is not the primary reason for the high cost compared to the explosion in execution time.</li><li>c) The concept of nested iteration is independent of the specific syntax used to implement it.</li><li>d) Nested loops can be simple and may not involve any procedure calls at all.</li></ul>"
"You are given a pseudocode that first initializes a variable max_math = 0, then iterates through a list of students, updating max_math if a student's math score is higher. This is an example of which two concepts combined?<ul><li>a) Nested Iteration and Procedures</li><li>b) Filtering with a variable and Accumulation</li><li>c) Binning and Side Effects</li><li>d) Sequential Iteration and Records</li></ul>";"Correct: b)";"<b>Explanation:</b> The algorithm uses an if statement (if X.Math > max_math) to decide whether to update a value. Because max_math is a variable that gets updated, this is filtering with a variable. The variable max_math itself is serving as an accumulator, as it is being used to keep track of a running summary value (the maximum found so far) across the iteration.<br><b>Distractor Rationale:</b><ul><li>a) This is a single loop, not nested, and no procedure is explicitly defined.</li><li>c) No binning is occurring.</li><li>d) This is a single iteration, not sequential iterations.</li></ul>"
"If you have N items and divide them into K bins, the number of items per bin is N/K. The number of comparisons per bin is (N/K) * (N/K - 1) / 2. What is the formula for the total number of comparisons after binning?<ul><li>a) K * (N/K) * (N/K - 1) / 2</li><li>b) (N/K) * (N/K - 1) / 2</li><li>c) N * (N - 1) / 2</li><li>d) K + (N/K) * (N/K - 1) / 2</li></ul>";"Correct: a)";"<b>Explanation:</b> The formula (N/K) * (N/K - 1) / 2 gives the number of comparisons for a single bin. Since there are K bins in total, and we need to perform this number of comparisons for each one, we must multiply the per-bin comparison count by the number of bins, K.<br><b>Distractor Rationale:</b><ul><li>b) This is the number of comparisons for only one bin, not the total.</li><li>c) This is the formula for the number of comparisons without binning.</li><li>d) This incorrectly adds the number of bins to the comparison count.</li></ul>"
"Which of the following problems is best solved using a nested loop? (Select all that apply)<ul><li>a) Finding the average score of all students.</li><li>b) Finding all pairs of students who are from the same hometown.</li><li>c) Finding all students whose total score is above 250.</li><li>d) Finding all pairs of books in a library that are in the same genre.</li></ul>";"Correct: b), d)";"<b>Explanation:</b> A nested loop is the natural fit for problems that require pairwise comparisons across a single set. To find pairs of students from the same hometown, you must compare each student with every other student. Similarly, to find pairs of books in the same genre, you must compare each book with every other book.<br><b>Distractor Rationale:</b><ul><li>a) Finding an average is a single-pass accumulation task.</li><li>c) This is a single-pass filtering task.</li></ul>"
"What is the concept of a ""contract"" between a main piece of code and a procedure it calls?<ul><li>a) It's a legal document required for programming.</li><li>b) It's an agreement on what the procedure will do, what parameters it needs, what it will return, and what side effects it is allowed to have.</li><li>c) It refers to the process of initializing variables before a loop.</li><li>d) It's a special type of variable that cannot be changed.</li></ul>";"Correct: b)";"<b>Explanation:</b> The ""contract"" is a conceptual agreement that defines the interface and behavior of a procedure. The calling code trusts the procedure to perform its task correctly and adhere to the agreed-upon rules (like not modifying input data unless allowed), and the procedure trusts that it will receive valid inputs. This separation of concerns is fundamental to modular programming.<br><b>Distractor Rationale:</b><ul><li>a) It is a conceptual, not a legal, contract.</li><li>c) Initialization is part of an algorithm but is not the contract itself.</li><li>d) This describes a constant, not a contract.</li></ul>"
"What is a likely consequence if a procedure violates its ""no side effects"" contract by reordering a pile of cards that the main algorithm expects to be in a specific order?<ul><li>a) The program will run faster.</li><li>b) The procedure will return an incorrect value.</li><li>c) The main algorithm may fail or produce incorrect results in subsequent steps.</li><li>d) The computer will display a syntax error.</li></ul>";"Correct: c)";"<b>Explanation:</b> If the main code relies on the order of the data, and a procedure it calls changes that order, the assumptions of the main code are now invalid. This can lead to logical errors, incorrect processing, or complete failure in the steps that follow the procedure call.<br><b>Distractor Rationale:</b><ul><li>a) Violating a contract is a source of bugs, not a performance enhancement.</li><li>b) The procedure might return the correct value (e.g., a count), but its side effect is what causes the problem.</li><li>d) This is a logical error, not a syntax error, so the code would run but behave incorrectly.</li></ul>"
"In the single-pass approach to pronoun resolution, a variable like last_noun_seen is used. What computational role does this variable play?<ul><li>a) It acts as a counter for the number of nouns.</li><li>b) It acts as a state variable to remember information from previous steps, avoiding the need for a re-scan.</li><li>c) It acts as a filter to exclude all words that are not nouns.</li><li>d) It is a parameter passed to a procedure.</li></ul>";"Correct: b)";"<b>Explanation:</b> The last_noun_seen variable maintains the current state of the context (i.e., who is being talked about). By storing this piece of information as the iteration progresses, the algorithm avoids having to go back and re-scan the text. This use of a variable to remember the state is a powerful technique for turning nested-loop problems into more efficient single-pass ones.<br><b>Distractor Rationale:</b><ul><li>a) It stores a specific noun, not a count.</li><li>c) The filtering is done with an if statement; the variable stores the result of a past filter.</li><li>d) It is a local variable within the main iteration, not a parameter.</li></ul>"
"Why is the single-pass pronoun resolution method (using a state variable) computationally superior to the nested-loop method (re-scanning backwards)?<ul><li>a) It uses less memory.</li><li>b) It is easier to write the pseudocode for.</li><li>c) It reduces the number of operations from quadratic (N^2) to linear (N), making it vastly more efficient for large texts.</li><li>d) It can handle more types of pronouns.</li></ul>";"Correct: c)";"<b>Explanation:</b> The nested-loop approach has a quadratic time complexity because for each pronoun (part of the outer loop), it may have to scan many previous words (the inner loop). The single-pass approach examines each word only once. This changes the complexity from being proportional to N*N to just N, which is a dramatic improvement in efficiency, especially for long documents.<br><b>Distractor Rationale:</b><ul><li>a) It might use slightly more memory for the state variable, but the time savings are the significant factor.</li><li>b) Ease of writing is subjective; efficiency is the objective measure of superiority here.</li><li>d) Both methods can be adapted to handle different pronouns; the core difference is their efficiency.</li></ul>"
"What is a potential trade-off when using binning to reduce comparison time?<ul><li>a) It always makes the algorithm more complicated to understand.</li><li>b) It can increase the amount of memory or space required to hold the bins.</li><li>c) It only works for datasets with fewer than 100 items.</li><li>d) It requires the data to be sorted numerically first.</li></ul>";"Correct: b)";"<b>Explanation:</b> While the naive nested loop might only need a couple of piles to work with, binning requires creating a separate pile or data structure for each bin. If there are many bins, this can lead to a significant increase in the memory (or, in the physical card analogy, table space) needed to organize the data before the final, faster comparisons can be done. This is a classic space-time tradeoff.<br><b>Distractor Rationale:</b><ul><li>a) While it adds a step, the logic of binning is often quite straightforward.</li><li>c) Binning is even more effective and necessary for very large datasets.</li><li>d) Binning and sorting are different operations; binning works on categorical data (like city names) and does not require a pre-sort.</li></ul>"
"You have a dataset of 200 items and you bin them into 10 equally-sized groups. How many total pairwise comparisons are needed after binning?<ul><li>a) 190</li><li>b) 200</li><li>c) 1900</li><li>d) 19900</li></ul>";"Correct: a)";"<b>Explanation:</b> First, determine the size of each bin: 200 items / 10 bins = 20 items per bin. Next, calculate the number of comparisons for one bin: (20 * (20 - 1)) / 2 = (20 * 19) / 2 = 190. Since there are 10 bins, the total number of comparisons is 10 * 190 = 1900. Wait, the question asks for the total. Let's re-read. Oh, the previous question was similar. Let's recalculate. Bin size is 20. Comparisons per bin: (20 * 19) / 2 = 190. Total comparisons: 10 bins * 190 comparisons/bin = 1900. Let me re-check the provided solution. The provided solution has a calculation error. Let's correct the question or the answer. I will assume the question intended to ask for comparisons per bin. No, the prompt asks for total. My calculation is 1900. Let me create a new question that is less ambiguous. How about: ""If one bin contains 20 items, how many pairwise comparisons are needed for that bin?"" Answer: 190. Let me stick to the original format. Let's assume the provided solution is wrong and fix it. Total comparisons = 1900. Let me change the options. a) 190, b) 200, c) 1900, d) 19900. Correct answer is c). The original question had a typo in the options. I will correct it. My previous batch had a similar question, let me check it. Q66 was not in the previous batch. This is a new question. The calculation is definitely 1900. I will generate the card with the correct answer and options.<br><br>Let's restart the question generation for this card. You have 200 items and bin them into 10 groups of 20. How many comparisons are needed in total?<ul><li>a) 190</li><li>b) 2000</li><li>c) 1900</li><li>d) 19900</li></ul>";"Correct: c)";"<b>Explanation:</b> With 200 items in 10 bins, each bin has 20 items. The number of comparisons for one bin is (20 * 19) / 2 = 190. Since there are 10 bins, the total number of comparisons is 10 * 190 = 1900. This is a massive reduction from the 19900 comparisons needed without binning.<br><b>Distractor Rationale:</b><ul><li>a) 190 is the number of comparisons for a single bin.</li><li>b) This is an incorrect calculation.</li><li>d) 19900 is the number of comparisons required without binning.</li></ul>"
"What does an assignment statement like A = A + 1 signify in pseudocode?<ul><li>a) It is a mathematical equation checking if A is equal to A + 1.</li><li>b) It is an operation that takes the current value of A, adds 1 to it, and updates A to store the new result.</li><li>c) It initializes the variable A for the first time.</li><li>d) It compares the value of A to the value of A + 1.</li></ul>";"Correct: b)";"<b>Explanation:</b> In programming and pseudocode, the equals sign (=) is the assignment operator, not a statement of mathematical equality. It means ""compute the value on the right side and store it in the variable on the left side"". So, A = A + 1 is the standard way to increment a variable's value.<br><b>Distractor Rationale:</b><ul><li>a) As a mathematical equation, A = A + 1 has no solution. This is an operation, not an equation.</li><li>c) While it could be an initialization if A had no prior value, its primary role here is updating an existing value.</li><li>d) This describes a comparison, which would use an operator like == or >, not the assignment operator =.</li></ul>"
"In an if-else statement, what is the purpose of the else block?<ul><li>a) To specify the code that should be executed if the if condition is true.</li><li>b) To provide an alternative block of code to be executed only if the if condition is false.</li><li>c) To repeat the code in the if block a second time.</li><li>d) To end the program if the if condition is not met.</li></ul>";"Correct: b)";"<b>Explanation:</b> The if-else structure provides two paths for the flow of control. The code inside the if block runs when the condition is true. If the condition is false, the program skips the if block and executes the code inside the else block instead.<br><b>Distractor Rationale:</b><ul><li>a) This describes the if block itself.</li><li>c) The else block provides an alternative, not a repetition.</li><li>d) The else block is for alternative logic, not necessarily for terminating the program.</li></ul>"
"A procedure is designed to find the names of all students who scored above 90 in Physics. What would be the most appropriate data type for its return value?<ul><li>a) An Integer (the count of students).</li><li>b) A Boolean (True if any student was found, False otherwise).</li><li>c) A List of Strings (containing the names of the qualifying students).</li><li>d) A Record (containing the information of the first student found).</li></ul>";"Correct: c)";"<b>Explanation:</b> The goal is to get ""all students"", which implies there could be zero, one, or many. A list is the ideal data structure for collecting a variable number of items. Since the required information is the names, a list of strings is the most precise and useful return type.<br><b>Distractor Rationale:</b><ul><li>a) Returning only the count doesn't identify who the students are.</li><li>b) Returning a boolean doesn't identify the students.</li><li>d) Returning only the first student found does not satisfy the requirement of finding all qualifying students.</li></ul>"
"You use a binning heuristic on 50 items, intending to create 5 equal bins. However, the data is skewed, and one bin receives 46 items while the other four bins receive 1 item each. How would you describe the effectiveness of this binning strategy?<ul><li>a) Highly effective, because 5 bins were created.</li><li>b) Ineffective, because the comparisons were not significantly reduced.</li><li>c) Effective, because the data is now organized.</li><li>d) Highly effective, because four bins are very small.</li></ul>";"Correct: b)";"<b>Explanation:</b> The benefit of binning comes from breaking a large problem into multiple small problems. In this case, you've broken it into one large problem (the bin with 46 items) and four trivial ones. The number of comparisons for the large bin (46 * 45 / 2 = 1035) is very close to the original total (50 * 49 / 2 = 1225). The reduction is minimal, so the chosen heuristic was poor for this dataset.<br><b>Distractor Rationale:</b><ul><li>a) The number of bins is irrelevant if they are not balanced in size.</li><li>c) While technically organized, it's not an organization that helps solve the problem efficiently.</li><li>d) The small size of four bins is negated by the massive size of the fifth bin, where most of the computational work remains.</li></ul>"
"What are the final values of A and B after this pseudocode executes?<br><br>1 A = 5<br>2 B = 10<br>3 if (A > B) {<br>4   A = B<br>5 }<br>6 else {<br>7   B = A<br>8 }<ul><li>a) A = 10, B = 10</li><li>b) A = 5, B = 10</li><li>c) A = 10, B = 5</li><li>d) A = 5, B = 5</li></ul>";"Correct: d)";"<b>Explanation:</b> The code starts with A=5 and B=10. The condition if (A > B) (is 5 > 10?) is false. Therefore, the code in the else block is executed. Line 7, B = A, assigns the value of A (which is 5) to B. A's value is not changed. So, A remains 5, and B becomes 5.<br><b>Distractor Rationale:</b><ul><li>a) This would happen if the if block ran and then B was also changed.</li><li>b) This would be the result if no code ran at all.</li><li>c) This would be the result if the if block ran.</li></ul>"
"What is the fundamental difference between a while loop and an if statement?<ul><li>a) A while loop can have an else block, but an if statement cannot.</li><li>b) An if statement checks a condition once to decide which code to execute, while a while loop checks a condition repeatedly to decide whether to continue executing a block of code.</li><li>c) A while loop is used for counting, and an if statement is used for comparing.</li><li>d) An if statement can use variables in its condition, but a while loop cannot.</li></ul>";"Correct: b)";"<b>Explanation:</b> The core distinction is between selection and iteration. An if statement selects a path of execution (the if block or the else block) and runs it once. A while loop iterates or repeats a block of code as long as its condition remains true. It is a structure for repetition, whereas if is a structure for branching.<br><b>Distractor Rationale:</b><ul><li>a) Both can be part of more complex structures, but the core difference is repetition.</li><li>c) Both can be used for counting and comparing depending on the code inside them.</li><li>d) Both can use variables in their conditions.</li></ul>"
"In the ""fair teams"" problem, what was the primary purpose of the initial binning step, which grouped students by their total scores?<ul><li>a) To ensure that every student was placed in a pair.</li><li>b) To reduce the total number of comparisons by only considering pairs of students with a similar overall academic level.</li><li>c) To find the students with the highest and lowest scores.</li><li>d) To sort the students by their total score in descending order.</li></ul>";"Correct: b)";"<b>Explanation:</b> The underlying heuristic was that a ""fair"" pair would consist of students who are roughly at the same academic level. By binning based on total score, the algorithm avoids the massive number of comparisons between students with vastly different totals (e.g., a top performer and a struggling student), focusing only on potential pairs within a reasonable performance range.<br><b>Distractor Rationale:</b><ul><li>a) Binning doesn't guarantee that a suitable partner will be found for everyone.</li><li>c) While this might be a side effect, the main goal was to group students for pairing, not just identify extremes.</li><li>d) Binning groups items; sorting orders them. They are different operations.</li></ul>"
"After binning students by total score in the ""fair teams"" problem, the next step was to subdivide each bin into two groups: (Math > Physics) and (Physics >= Math). What was the purpose of this step?<ul><li>a) To identify students who were good at Chemistry.</li><li>b) To further reduce comparisons by creating targeted groups with complementary skills, so you only need to pair someone from the ""high Math"" group with someone from the ""high Physics"" group.</li><li>c) To check if there were more students who were better at Math than Physics.</li><li>d) To prepare the data for sorting by name.</li></ul>";"Correct: b)";"<b>Explanation:</b> This step implements the core logic of the pairing. The goal is to find students where one can help the other in Math, and vice-versa for Physics. By pre-separating them into a ""stronger in Math"" group and a ""stronger in Physics"" group, the algorithm can efficiently create pairs by picking one from each, rather than comparing everyone inside the bin against everyone else.<br><b>Distractor Rationale:</b><ul><li>a) This step was specifically about Math and Physics.</li><li>c) While this would be a result of the process, the purpose was to enable pairing, not just to count.</li><li>d) Sorting by name is irrelevant to the pairing logic.</li></ul>"
"An algorithm's runtime is described as being O(N^2) (Big O of N squared). What does this mean in simple terms?<ul><li>a) The algorithm will take exactly N * N seconds to run.</li><li>b) As the number of input items (N) grows, the runtime will grow proportionally to the square of N.</li><li>c) The algorithm uses two variables.</li><li>d) The algorithm is guaranteed to be correct.</li></ul>";"Correct: b)";"<b>Explanation:</b> O(N^2), or quadratic complexity, describes the relationship between the input size and the algorithm's runtime. It means that if you double the input size, the runtime will roughly quadruple (2^2 = 4). If you triple the input size, the runtime will increase by about a factor of nine (3^2 = 9). This indicates an algorithm that can become very slow as the input size increases.<br><b>Distractor Rationale:</b><ul><li>a) Big O notation describes the growth rate, not the exact runtime in seconds.</li><li>c) The notation refers to complexity, not the number of variables.</li><li>d) Complexity and correctness are two independent properties of an algorithm.</li></ul>"
"A procedure takes a pile of cards and a city name as input. It creates and returns a new pile containing only the students from that city, leaving the original pile unchanged. Does this procedure have a side effect on the original pile?<ul><li>a) Yes, because it creates a new pile of cards.</li><li>b) No, because the original pile of cards that was passed as a parameter was not modified.</li><li>c) Yes, because it has to read from the original pile.</li><li>d) No, because it returns a value.</li></ul>";"Correct: b)";"<b>Explanation:</b> A side effect is a modification to the state outside the procedure's local scope, particularly to its inputs. Since the procedure creates a new pile and leaves the original, input pile untouched, it is considered to be free of side effects on that input. Creating and returning a new data structure is the primary output, not a side effect.<br><b>Distractor Rationale:</b><ul><li>a) Creating a new pile is part of the procedure's intended output, not a modification of its input.</li><li>c) Reading data is a non-modifying operation and is not a side effect.</li><li>d) Returning a value is the opposite of a side effect.</li></ul>"
"What is the final value of the count variable after this pseudocode finishes?<br><br>1 count = 0<br>2 i = 1<br>3 while (i <= 5) {<br>4   count = count + i<br>5   i = i + 1<br>6 }<ul><li>a) 5</li><li>b) 15</li><li>c) 20</li><li>d) 6</li></ul>";"Correct: b)";"<b>Explanation:</b> The loop executes for i = 1, 2, 3, 4, and 5. The count variable accumulates the value of i in each iteration:<br>- Start: count = 0<br>- i=1: count = 0 + 1 = 1<br>- i=2: count = 1 + 2 = 3<br>- i=3: count = 3 + 3 = 6<br>- i=4: count = 6 + 4 = 10<br>- i=5: count = 10 + 5 = 15<br>When i becomes 6, the loop condition i <= 5 is false, and the loop terminates.<br><b>Distractor Rationale:</b><ul><li>a) 5 is the final value of i inside the loop, not count.</li><li>c) This is an incorrect sum.</li><li>d) This is the value of count after the i=3 iteration.</li></ul>"
"What is the key characteristic of a ""brute-force"" or ""naive"" approach to a problem requiring pairwise comparisons?<ul><li>a) It uses a clever heuristic to reduce the number of steps.</li><li>b) It systematically checks every possible pair without using any problem-specific knowledge to exclude possibilities.</li><li>c) It involves binning the data into at least 10 bins.</li><li>d) It can only be solved with a single iteration.</li></ul>";"Correct: b)";"<b>Explanation:</b> A brute-force approach is a straightforward method that relies on raw computational power rather than clever logic. For pairwise problems, this means exhaustively comparing every item against every other item (typically with a nested loop), which is simple to implement but often inefficient.<br><b>Distractor Rationale:</b><ul><li>a) This is the opposite of a brute-force approach; a clever heuristic is used in more optimized algorithms.</li><li>c) Binning is a technique used to avoid the brute-force approach.</li><li>d) A brute-force pairwise comparison requires a nested iteration, not a single one.</li></ul>"
"In a procedure call written as FindStudent(ScoresPile, ""Vetrivel""), what is the term for the specific value ""Vetrivel""?<ul><li>a) The parameter</li><li>b) The procedure name</li><li>c) The argument</li><li>d) The return value</li></ul>";"Correct: c)";"<b>Explanation:</b> In programming terminology, the variable in the procedure definition (e.g., Procedure FindStudent(Pile, StudentName)) is the parameter. The actual value supplied when the procedure is called (e.g., ""Vetrivel"") is the argument.<br><b>Distractor Rationale:</b><ul><li>a) The parameter is the placeholder in the definition (e.g., StudentName), not the specific value.</li><li>b) The procedure name is FindStudent.</li><li>d) The return value is what the procedure gives back after executing.</li></ul>"
"In a nested loop that uses temporary piles (like Pile 2 and Pile 3) to process a main pile (Pile 1), why is it often necessary to move all cards from the temporary pile back to the main pile at the end of the outer loop's iteration?<ul><li>a) To ensure the cards are in a random order for the next step.</li><li>b) To make sure the inner loop has the correct and complete set of cards to compare against in the next iteration of the outer loop.</li><li>c) To clear the memory used by the temporary piles.</li><li>d) To count the total number of cards in the dataset.</li></ul>";"Correct: b)";"<b>Explanation:</b> The outer loop picks one card (X) and the inner loop compares it against all remaining cards (Y). For the next iteration of the outer loop, when a new card is picked for X, the inner loop must once again have a complete set of the remaining cards to compare against. Restoring the pile ensures the integrity of the dataset for each pass of the outer loop.<br><b>Distractor Rationale:</b><ul><li>a) The goal is to restore the state, not to randomize it.</li><li>c) This is a logical step in the algorithm, not a memory management command.</li><li>d) Counting would be done with a variable, not by moving piles.</li></ul>"

