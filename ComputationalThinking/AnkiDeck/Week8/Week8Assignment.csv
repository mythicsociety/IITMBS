"Front";"Back";"Extra"
"The following pseudocode is executed using the ""Scores"" table. What will A and B represent at the end of the execution?<br><br>1 D = {}<br>2 while (Table 1 has more rows) {<br>3 Read the first row X in Table 1<br>4 if(iskey(D, X.Town/City)) {<br>5 if(D[X.Town/City] > X.Mathematics) {<br>6 D[X.Town/City] = X.Mathematics<br>7 }<br>8 }<br>9 else {<br>10 D[X.Town/City] = X.Mathematics<br>11 }<br>12 Move X to Table 2<br>13 }<br>14<br>15 A = 0, B = 100<br>16 foreach Y in keys(D) {<br>17 if(B == D[Y]) {<br>18 A = A + 1<br>19 }<br>20 if(B > D[Y]) {<br>21 A = 1<br>22 B = D[Y]<br>23 }<br>24 }<ul><li>a) A = Cities where students score the highest marks in Mathematics, B = The highest marks in Mathematics</li><li>b) A = Number of cities where students score the highest marks in Mathematics, B = The highest marks in Mathematics</li><li>c) A = Number of cities where students score the lowest marks in Mathematics, B = The lowest marks in Mathematics</li><li>d) A = Always more than one, B = The highest marks in Mathematics</li></ul>";"Correct: c)";"<b>Explanation:</b> The first loop (lines 2-13) iterates through the 'Scores' table to find the minimum Mathematics score for each city, storing it in dictionary D. The second loop (lines 16-24) iterates through D to find the overall lowest score (B) among all cities and the number of cities (A) that have this lowest score. The initial value of B is 100, and it is updated downwards. Therefore, A is the count of cities with the lowest Mathematics score, and B is that lowest score.<br><b>Distractor Rationale:</b><ul><li>a) A is a counter, not a list of cities. B is the lowest score, not the highest.</li><li>b) The logic finds the minimum score (B is updated when D[Y] is smaller), not the maximum.</li><li>d) A can be one if only one city has the absolute lowest score. B is the lowest score, not the highest.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. What will the value of B represent at the end of the execution?<br><br>1 D = {}, B = 0<br>2 while (Table 1 has more rows) {<br>3 Read the first row X in Table 1<br>4 D = updateDictByField(D, X.Physics)<br>5 Move X to Table 2<br>6 }<br>7 B = findAKey(D)<br>8<br>9 Procedure updateDictByField(D, Value)<br>10 if(iskey(D, value)) {<br>11 D[Value] = D[Value] + 1<br>12 }<br>13 else {<br>14 D[value] = 1<br>15 }<br>16 return(D)<br>17 End updateDictByField<br>18<br>19 Procedure findAKey(D)<br>20 Key = -1, Value = 0<br>21 foreach A in keys(D) {<br>22 if(D[A] > Value) {<br>23 Value = D[A]<br>24 Key = A<br>25 }<br>26 }<br>27 return(Key)<br>28 End findAKey<ul><li>a) Number of repeated marks in Physics</li><li>b) Minimum marks in Physics</li><li>c) Maximum marks in Physics</li><li>d) Most frequent marks in Physics</li></ul>";"Correct: d)";"<b>Explanation:</b> The updateDictByField procedure creates a frequency map (histogram) of Physics marks in the dictionary D, where keys are the marks and values are their frequencies. The findAKey procedure then iterates through this dictionary to find the key (the mark) that has the highest associated value (the highest frequency). Therefore, B will hold the most frequent mark in Physics.<br><b>Distractor Rationale:</b><ul><li>a) B represents a specific mark, not the count of all repeated marks.</li><li>b) The code counts frequency; it does not compare mark values to find the minimum.</li><li>c) The code counts frequency; it does not compare mark values to find the maximum.</li></ul>"
"The following pseudocode is executed using the ""Shopping Bills"" dataset. Identify all mistakes (if any) in the pseudocode which aims to capture, for each customer Z, the shops they visited and the categories of items they purchased. Select all that apply.<br><br>1 D = {}<br>2 while (Pile 1 has more cards) {<br>3 Read the top card X in Pile 1<br>4 D = updateDictionary(D, X)<br>5 Move X to Pile 2<br>6 }<br>7<br>8 Procedure updateDictionary(D, Y)<br>9 if(not iskey(D, Y.CustomerName)) {<br>10 D[Y.CustomerName] = {""Shop"": [], ""Category"": []}<br>11 }<br>12 D[Y.CustomerName][""Shop""][Y.ShopName] = True<br>13 foreach A in Y.ItemList{<br>14 D[Y.CustomerName][""Category""][A.Category] = True<br>15 }<br>16 return(D)<br>17 End updateDictionary<ul><li>a) Error in Line 1</li><li>b) Error in Line 10</li><li>c) Error in Line 12</li><li>d) Error in Line 14</li><li>e) No error</li></ul>";"Correct: c), d)";"<b>Explanation:</b> The goal is to store a list of shops and a list of categories. In Line 10, the values for ""Shop"" and ""Category"" are initialized as lists ([]). However, Lines 12 and 14 attempt to use these lists as dictionaries by assigning a value to a key (e.g., [Y.ShopName] = True). You cannot use a list like a dictionary. The correct approach would be to append items to the list, for example, D[Y.CustomerName][""Shop""] = D[Y.CustomerName][""Shop""] ++ [Y.ShopName] and check for existence before appending.<br><b>Distractor Rationale:</b><ul><li>a) Line 1 correctly initializes an empty dictionary.</li><li>b) Line 10 correctly initializes a nested dictionary structure with lists as values, which is a valid starting point for the intended logic.</li><li>e) There are clear errors in how the lists are being updated.</li></ul>"
"The pseudocode below is executed using the ""station wise"" cards of the ""Train"" dataset. It aims to create a dictionary STN where for a station X and a day of the week A, STN[X][A] stores the number of trains running through X on day A. Choose the correct code fragment to complete the getInfo procedure.<br><br>1 STN = {}<br>2 while (Pile 1 has more cards) {<br>3 Read the top card X in Pile 1<br>4 STN[X.StationName] = getInfo(STN, X)<br>5 Move X to Pile 2<br>6 }<br>7<br>8 Procedure getInfo(STN, X)<br>9 *********************<br>10 * Fill the code *<br>11 *********************<br>12 return(D)<br>13 End getInfo<ul><li>a) 1 D = {}<br>2 foreach A in X.TrainList{<br>3 foreach B in A.Days{<br>4 D[B] = 1<br>5 }<br>6 }</li><li>b) 1 D = {""M"": 0, ""Tu"": 0, ""W"": 0, ""Th"": 0, ""F"": 0, ""Sa"": 0, ""Su"": 0}<br>2 foreach A in X.TrainList{<br>3 foreach B in A.Days{<br>4 D[B] = 1<br>5 }<br>6 }</li><li>c) 1 D = {}<br>2 foreach A in X.TrainList{<br>3 foreach B in A.Days{<br>4 D[B] = D[B] + 1<br>5 }<br>6 }</li><li>d) 1 D = {""M"": 0, ""Tu"": 0, ""W"": 0, ""Th"": 0, ""F"": 0, ""Sa"": 0, ""Su"": 0}<br>2 foreach A in X.TrainList{<br>3 foreach B in A.Days{<br>4 D[B] = D[B] + 1<br>5 }<br>6 }</li></ul>";"Correct: d)";"<b>Explanation:</b> The procedure needs to count trains for each day of the week for a given station. Option (d) correctly initializes a dictionary D with all days of the week set to 0. It then iterates through each train in the station's TrainList and for each day that train runs, it increments the counter for that day (D[B] = D[B] + 1). This correctly accumulates the total number of trains for each day.<br><b>Distractor Rationale:</b><ul><li>a) This fragment doesn't initialize the dictionary with all days, so if a day has no trains, it won't be in the dictionary. It also overwrites the count with 1 instead of incrementing.</li><li>b) This fragment initializes the dictionary correctly but then overwrites the count with 1 (D[B] = 1) instead of incrementing it, so it would only tell if at least one train runs on a day, not how many.</li><li>c) This fragment attempts to increment (D[B] = D[B] + 1) but fails to initialize the dictionary D. This would cause an error the first time a day is encountered because the key would not exist.</li></ul>"
"Consider the dictionary STN computed in the previous question. Choose the correct statement(s) from the options based on the following pseudocode. Select all that apply.<br><br>1 Z = {}, D = {}<br>2 foreach A in keys(STN) {<br>3 C = 0, Y = 0<br>4 D = STN[A]<br>5 foreach B in keys(D) {<br>6 if(Y == D[B]) {<br>7 C = C + 1<br>8 }<br>9 if(Y < D[B]) {<br>10 C = 1<br>11 Y = D[B]<br>12 }<br>13 }<br>14 if (not iskey(Z, C)) {<br>15 Z[C] = 0<br>16 }<br>17 Z[C] = Z[C] + 1<br>18 }<ul><li>a) Keys of the dictionary Z is integer</li><li>b) There can be a value C such that Z[C] is zero</li><li>c) All values of the dictionary elements are non-zero</li><li>d) The number of keys in Z is 8</li></ul>";"Correct: a), c)";"<b>Explanation:</b> The inner loop (lines 5-13) finds the maximum number of trains on any single day for a station (Y) and also counts how many days have this maximum number (C). The outer loop then builds a dictionary Z. The keys of Z are the counts (C), which are integers. The values of Z are the number of stations that have that particular count C of busiest days. Since Z[C] is initialized to 0 and then immediately incremented, any value in Z must be at least 1, making it non-zero.<br><b>Distractor Rationale:</b><ul><li>b) Line 15 initializes Z[C] to 0, but line 17 immediately increments it. A value in Z can never remain 0.</li><li>d) The number of keys in Z depends on the data. C is the number of days that are tied for being the busiest at a station. This count could range from 1 to 7. The number of keys in Z will be the number of distinct values of C found across all stations, which is not necessarily 8.</li></ul>"
"Consider the dictionary STN computed previously. Choose the correct pseudocode to compute the number of stations which have trains passing through all days of a week.<ul><li>a) 1 z = 0<br>2 foreach A in keys(STN) {<br>3 foreach B in keys(STN[A]) {<br>4 if(STN[A][B] < 1) {<br>5 C = False<br>6 }<br>7 }<br>8 if(C) {<br>9 z = z + 1<br>10 }<br>11 }</li><li>b) 1 z = 0<br>2 foreach A in keys(STN) {<br>3 C = True<br>4 foreach B in keys(STN[A]) {<br>5 if(STN[A][B] < 1) {<br>6 C = False<br>7 }<br>8 }<br>9 if(C) {<br>10 z = z + 1<br>11 }<br>12 }</li><li>c) 1 z = 0<br>2 foreach A in keys(STN) {<br>3 C = True<br>4 foreach B in keys(STN[A]) {<br>5 if(STN[A][B] < 1) {<br>6 C = False<br>7 }<br>8 else {<br>9 C = True<br>10 }<br>11 }<br>12 if(C) {<br>13 z = z + 1<br>14 }<br>15 }</li><li>d) 1 z = 0<br>2 foreach A in keys(STN) {<br>3 C = False<br>4 foreach B in keys(STN[A]) {<br>5 if(STN[A][B] < 1) {<br>6 C = True<br>7 }<br>8 }<br>9 if(C) {<br>10 z = z + 1<br>11 }<br>12 }</li></ul>";"Correct: b)";"<b>Explanation:</b> This code correctly implements the logic. For each station A, it initializes a flag C to True (line 3). It then checks every day's train count for that station (lines 4-8). If it finds any day with fewer than 1 train, it sets C to False. After checking all days for station A, if C is still True, it means every day had at least one train, so the station counter z is incremented.<br><b>Distractor Rationale:</b><ul><li>a) The flag C is not re-initialized to True for each new station. Once it is set to False for one station, it will remain False for all subsequent stations, leading to an incorrect count.</li><li>c) The else block (lines 8-10) is problematic. If the last day checked has trains, it will reset C to True, even if a previous day had no trains. This would incorrectly count stations that don't have trains on all days.</li><li>d) The logic is inverted. The flag C is initialized to False and set to True if a day with no trains is found. This would count stations that are missing trains on at least one day, not stations that have them on all days.</li></ul>"
"The following pseudocode is executed using the ""Words"" dataset. What will D represent at the end of the execution?<br><br>1 D = {}<br>2 while (Table 1 has more rows) {<br>3 Read the first row X in Table 1<br>4 D = updateDictionary(D, X)<br>5 Move X to Table 2<br>6 }<br>7<br>8 Procedure updateDictionary(D, Y)<br>9 i = 1, B = ''<br>10 while (i <= Y.LetterCount) {<br>11 B = ith letter in Y.Word<br>12 if(iskey(D, B)) {<br>13 D[B] = D[B] + 1<br>14 }<br>15 else {<br>16 D[B] = 1<br>17 }<br>18 i = i + 1<br>19 }<br>20 return(D)<br>21 End updateDictionary<ul><li>a) Frequency count of each alphabet in the table</li><li>b) Frequency count of each word in the table</li><li>c) Most frequent alphabet in the table</li><li>d) Frequency count of each alphabet in each part of speech</li></ul>";"Correct: a)";"<b>Explanation:</b> The updateDictionary procedure iterates through every single letter of every word passed to it (lines 10-19). It uses a dictionary D to store the counts of each individual letter (B). If a letter is seen for the first time, its count is set to 1; otherwise, its existing count is incremented. The main loop calls this for every word in the dataset, so D accumulates the total frequency of each alphabet across all words.<br><b>Distractor Rationale:</b><ul><li>b) The code iterates through letters, not whole words.</li><li>c) The dictionary D stores the frequency counts, but the pseudocode shown does not include a step to find which alphabet has the maximum frequency.</li><li>d) The code does not use the 'PartofSpeech' information at all; it aggregates counts across all words regardless of their type.</li></ul>"
"Consider the dictionary D and the procedure updateDictionary() from the previous question. Let POS be a list of all parts of speech. Assume a procedure max(D) returns a list of keys with the maximum value. Choose the correct statement(s) from the options based on the following pseudocode. Select all that apply.<br><br>1 C = {""Overall"": max(D)}<br>2 foreach A in POS {<br>3 Move all rows to Table 1<br>4 B = {}<br>5 while (Table 1 has more rows) {<br>6 Read the first row X in Table 1<br>7 if(X.PartofSpeech == A) {<br>8 B = updateDictionary(B, X)<br>9 }<br>10 Move X to Table 2<br>11 }<br>12 C[A] = max(B)<br>13 }<ul><li>a) length(keys(C)) is same as the number of different part of speeches in the input dataset</li><li>b) C captures the list of most frequent alphabet occurred overall in the dataset as well as for each part of speech</li><li>c) C captures the most frequent alphabet occurred overall in the dataset as well as for each part of speech</li><li>d) length(keys(C)) is one more than the number of different part of speeches in the dataset</li></ul>";"Correct: b), d)";"<b>Explanation:</b> The dictionary C is initialized with the key ""Overall"", containing the list of the most frequent alphabets from the entire dataset (computed in the previous question). Then, the code iterates through each PartofSpeech (A in POS). For each part of speech, it re-scans the entire dataset, builds a temporary frequency dictionary B for just the words of that part of speech, finds the most frequent letter(s) using max(B), and stores this list in C with the part of speech as the key. Therefore, C contains the list of most frequent alphabets for the overall dataset AND for each individual part of speech. The number of keys in C will be the number of parts of speech plus one for the ""Overall"" key.<br><b>Distractor Rationale:</b><ul><li>a) The length is the number of parts of speech plus one, due to the initial ""Overall"" key.</li><li>c) max(D) is defined to return a list of keys, not a single key. This is important if there's a tie for the most frequent alphabet.</li></ul>"
"The following pseudocode is executed using the ""Shopping bills"" dataset. What will D represent at the end of the execution?<br><br>1 D = {}<br>2 while (Pile 1 has more cards) {<br>3 Read the top card X in Pile 1<br>4 D = updateDictionary(D, X)<br>5 Move X to Pile 2<br>6 }<br>7<br>8 Procedure updateDictionary(D, Y)<br>9 foreach A in Y.ItemList{<br>10 C = A.ItemName // ASSUMED - This line is blank in the source<br>11 if(iskey(D, C)) {<br>12 if(iskey(D[C], Y.ShopName)) {<br>13 if(D[C][Y.ShopName][""Price""] != A.Price) {<br>14 D[C][Y.ShopName][""Flag""] = True<br>15 }<br>16 }<br>17 else {<br>18 D[C][Y.ShopName] = {""Price"": A.Price, ""Flag"": False}<br>19 }<br>20 }<br>21 else {<br>22 D[C] = {}<br>23 D[C][Y.ShopName] = {""Price"": A.Price, ""Flag"": False}<br>24 }<br>25 }<br>26 return(D)<br>27 End updateDictionary<ul><li>a) For an item C, and a shop S, D[C][S][""Flag""] is set to True if and only if the item is sold for a constant price</li><li>b) For an item C, and a shop S, D[C][S][""Flag""] is set to True if and only if the item is billed in more than one bill</li><li>c) For an item C, and a shop S, D[C][S][""Flag""] is set to True if and only if the item is sold for variable price</li><li>d) For an item C, and a shop S, D[C][S][""Flag""] is set to True if and only if the item is billed exactly one bill</li></ul>";"Correct: c)";"<b>Explanation:</b> The pseudocode builds a nested dictionary D. The logic is as follows: for a given item C and shop Y.ShopName, it initializes a record with the price and a Flag set to False. If it encounters the same item from the same shop again (line 12), it checks if the price is different from the stored price (line 13). If the price is different, it sets the Flag to True (line 14). Therefore, the flag becomes True only when an item is found to be sold at a variable (non-constant) price at a specific shop.<br><b>Distractor Rationale:</b><ul><li>a) The logic is the opposite; the flag is set to True for variable prices, not constant prices.</li><li>b) The flag is triggered by a price difference, not by the number of bills. An item could be in multiple bills at the same price, and the flag would remain False.</li><li>d) This is incorrect; the flag is only set on the second or subsequent billing of an item if the price has changed.</li></ul>"
"The following pseudocode is executed using the ""Scores"" dataset. What will Z represent at the end of the execution?<br><br>1 D = {}<br>2 A = 0, C = 0, Avg = 0<br>3 while (Table 1 has more rows) {<br>4 Read the first row X in Table 1<br>5 A = A + X.Total<br>6 C = C + 1<br>7 if(iskey(D, X.Town/City)) {<br>8 D[X.Town/City][""Total""] = D[X.Town/City][""Total""] + X.Total<br>9 D[X.Town/City][""Count""] = D[X.Town/City][""Count""] + 1<br>10 }<br>11 else {<br>12 D[X.Town/City] = {""Total"": X.Total, ""Count"": 1}<br>13 }<br>14 Move X to Table 2<br>15 }<br>16 Avg = A / C<br>17<br>18 Z = 0<br>19 foreach B in keys(D) {<br>20 D[B][""Average""] = D[B][""Total""] / D[B][""Count""]<br>21 if (D[B][""Average""] > Avg) {<br>22 Z = Z + D[B][""Count""]<br>23 }<br>24 }<ul><li>a) Number of students from the cities with the average total marks of the city is more than the average total marks of the dataset</li><li>b) Number of students from the cities with the average total marks of the city is less than the average total marks of the dataset</li><li>c) Number of cities with the average total marks less than the average total marks of the dataset</li><li>d) Number of cities with the average total marks more than the average total marks of the dataset</li></ul>";"Correct: a)";"<b>Explanation:</b> The first loop (lines 3-15) calculates the overall total marks (A) and total student count (C) for the entire dataset. It also populates a dictionary D to store the total marks and student count for each city. Line 16 computes the overall average (Avg). The second loop (lines 19-24) calculates the average for each city. If a city's average is greater than the overall average (line 21), it adds the number of students from that city (D[B][""Count""]) to the variable Z. Thus, Z accumulates the total number of students from all cities whose average marks exceed the dataset's average.<br><b>Distractor Rationale:</b><ul><li>b) The condition in line 21 is > (greater than), not < (less than).</li><li>c) Z is incremented by the number of students (D[B][""Count""]), not by 1, so it counts students, not cities. The condition is also > not <.</li><li>d) Z is incremented by the number of students (D[B][""Count""]), not by 1, so it counts students, not cities.</li></ul>"
"The following pseudocode is executed using the ""Shopping Bills"" dataset. Let D be a dictionary that maintains the category of items purchased by a customer. Choose the correct code fragment to complete the pseudocode.<br><br>1 D = {}<br>2 while (Pile 1 has more cards) {<br>3 Read the top card X in Pile 1<br>4 *********************<br>5 * Fill the code *<br>6 *********************<br>7 Move X to Pile 2<br>8 }<ul><li>a) 1 foreach A in X.ItemList{<br>2 D[X.CustomerName][A] = True<br>3 }</li><li>b) 1 if(iskey(D, X.CustomerName)) {<br>2 D[X.CustomerName] = {}<br>3 }<br>4 foreach A in X.ItemList{<br>5 D[X.CustomerName][A.Category] = True<br>6 }</li><li>c) 1 if(not iskey(D, X.CustomerName)) {<br>2 D[X.CustomerName] = {}<br>3 }<br>4 else {<br>5 foreach A in X.ItemList{<br>6 D[X.CustomerName][A] = True<br>7 }<br>8 }</li><li>d) 1 if(not iskey(D, X.CustomerName)) {<br>2 D[X.CustomerName] = {}<br>3 }<br>4 foreach A in X.ItemList{<br>5 D[X.CustomerName][A.Category] = True<br>6 }</li></ul>";"Correct: d)";"<b>Explanation:</b> The goal is to create a nested dictionary where D[CustomerName] holds another dictionary of item categories. Option (d) correctly handles this. Line 1 checks if the customer is new. If so, line 2 initializes an empty dictionary for that customer. Critically, this initialization happens only once per customer. Then, the foreach loop (lines 4-6) iterates through the item list and adds each item's category as a key to the inner dictionary. This correctly builds the intended structure.<br><b>Distractor Rationale:</b><ul><li>a) This code fails to initialize the inner dictionary for a new customer, which would cause an error. It also uses the item object A as a key instead of A.Category.</li><li>b) The logic in the if condition is reversed. It initializes a dictionary for a customer who is already a key, which would wipe out their previously recorded categories.</li><li>c) The foreach loop is inside an else block, meaning it will only process items for customers who are already in the dictionary, completely ignoring the first bill for any customer. It also uses A instead of A.Category.</li></ul>"
"What does the following pseudocode compute when it is executed using the ""Shopping bills"" dataset?<br><br>1 BB = {}, A = ""None""<br>2 while (Pile 1 has more cards) {<br>3 Read the top card X in Pile 1<br>4 if (X.ShopName == ""Big Bazaar"") {<br>5 BB = UpdateDictionary(BB, X)<br>6 }<br>7 Move X to Pile 2<br>8 }<br>9 A = GetMaxKeyByKey(BB)<br>10<br>11 Procedure UpdateDictionary(D, Y)<br>12 foreach A in Y.ItemList{<br>13 if(iskey(D, A.Category)) {<br>14 D[A.Category] = D[A.Category] + 1<br>15 }<br>16 else {<br>17 D[A.Category] = 1<br>18 }<br>19 }<br>20 return(D)<br>21 End UpdateDictionary<br>22<br>23 Procedure GetMaxKeyByKey(D)<br>24 A = ""None"", B = 0<br>25 foreach Y in keys(D) {<br>26 if(B < D[Y]) {<br>27 A = Y<br>28 B = D[Y]<br>29 }<br>30 }<br>31 return(A)<br>32 End GetMaxKeyByKey<ul><li>a) Finds the item category from Big Bazaar</li><li>b) Finds the top item category by item category count from Big Bazaar</li><li>c) Finds the most frequent item category from Big Bazaar</li><li>d) Finds the top item category by item quantity from Big Bazaar</li></ul>";"Correct: c)";"<b>Explanation:</b> The UpdateDictionary procedure counts the occurrences of each A.Category across all items in the bills passed to it. The main loop filters for bills from ""Big Bazaar"" only and uses UpdateDictionary to build a frequency count of item categories sold at Big Bazaar into the dictionary BB. Finally, GetMaxKeyByKey iterates through BB to find the key (the category) with the highest value (the highest frequency count). Therefore, the code finds the most frequent item category from Big Bazaar.<br><b>Distractor Rationale:</b><ul><li>a) It doesn't just find a category, it finds the most frequent one.</li><li>b) This is close, but ""most frequent"" is a more precise description of what a frequency count represents than ""top item category by count"".</li><li>d) The code counts categories (A.Category), not the quantity of items purchased. The Item.Quantity field is never used.</li></ul>"
"The following pseudocode is executed using the ""station wise"" cards of the ""Train"" dataset. What will C represent at the end of the execution?<br><br>1 D = {""M"": 0, ""Tu"": 0, ""W"": 0, ""Th"": 0, ""F"": 0, ""Sa"": 0, ""Su"": 0}<br>2 while (Pile 1 has more cards) {<br>3 Read the top card X in Pile 1<br>4 if (X.StationName == ""Mumbai"") {<br>5 foreach A in X.TrainList{<br>6 foreach B in A.Days{<br>7 D[B] = D[B] + 1<br>8 }<br>9 }<br>10 }<br>11 Move X to Pile 2<br>12 }<br>13 C = [], Y = 0<br>14 foreach B in keys(D) {<br>15 if(Y == D[B]) {<br>16 C = C ++ [B]<br>17 }<br>18 if(Y < D[B]) {<br>19 C = [B]<br>20 Y = D[B]<br>21 }<br>22 }<ul><li>a) The busiest day of the Mumbai station</li><li>b) List of busiest days of the Mumbai station</li><li>c) The least busy day of the Mumbai station</li><li>d) List of least busy days of the Mumbai station</li></ul>";"Correct: b)";"<b>Explanation:</b> The first loop (lines 2-12) finds the card for ""Mumbai"" station and populates dictionary D with the total number of trains running on each day of the week. The second loop (lines 14-22) iterates through this daily frequency map to find the day(s) with the maximum number of trains. It uses Y to track the current maximum count. If a day has a count greater than Y, it resets the list C to contain only that day and updates Y. If a day has a count equal to Y, it appends that day to the list C. This correctly handles ties, so C will be a list of all the busiest days.<br><b>Distractor Rationale:</b><ul><li>a) C is a list ([]), so it can hold multiple days in case of a tie. It doesn't just return a single day.</li><li>c) The logic finds the maximum value (Y < D[B]), not the minimum.</li><li>d) The logic finds the maximum value, not the minimum.</li></ul>"
"The following pseudocode is executed using the ""Words"" dataset. At the end of the execution, C captures the number of words with either all letters distinct, or at least three letters that appeared at least twice. Choose the correct code-fragment to complete the pseudocode.<br><br>1 C = 0<br>2 while (Table 1 has more rows) {<br>3 Read the first row X in Table 1<br>4 i = 1, D = {}<br>5 while(i <= X.LetterCount) {<br>6 B = ith letter in X.Word<br>7 if(iskey(D, B)) {<br>8 D[B] = D[B] + 1<br>9 } else {<br>10 D[B] = 1<br>11 }<br>12 i = i + 1<br>13 }<br>14 *********************<br>15 * Fill the code *<br>16 *********************<br>17 Move X to Table 2<br>18 }<ul><li>a) 1 Found = True, A = 0<br>2 foreach Y in keys(D) {<br>3 if(D[Y] > 1) {<br>4 A = A + 1<br>5 }<br>6 else {<br>7 Found = False<br>8 }<br>9 }<br>10 if (Found or A >= 3) {<br>11 C = C + 1<br>12 }</li><li>b) 1 Found = True, A = 0<br>2 foreach Y in keys(D) {<br>3 if(D[Y] > 1) {<br>4 Found = False<br>5 A = A + 1<br>6 }<br>7 }<br>8 if (Found or A >= 3) {<br>9 C = C + 1<br>10 }</li><li>c) 1 Found = True, A = 0<br>2 foreach Y in keys(D) {<br>3 if(D[Y] > 1) {<br>4 Found = False<br>5 A = A + 1<br>6 }<br>7 else {<br>8 Found = True<br>9 }<br>10 }<br>11 if (Found or A >= 3) {<br>12 C = C + 1<br>13 }</li><li>d) 1 Found = True, A = 0<br>2 foreach Y in keys(D) {<br>3 if(D[Y] > 1) {<br>4 Found = False<br>5 }<br>6 else {<br>7 A = A + 1<br>8 }<br>9 }<br>10 if (Found or A >= 3) {<br>11 C = C + 1<br>12 }</li></ul>";"Correct: b)";"<b>Explanation:</b> This option correctly implements the two conditions. Found is initialized to True, assuming the word has all distinct letters. A is a counter for letters that appear more than once. The loop iterates through the letter frequency map D for the current word. If any letter has a count greater than 1 (D[Y] > 1), it means the letters are not all distinct, so Found is set to False. The counter A is also incremented. After checking all letters, the final if condition (Found or A >= 3) correctly checks if either the word had all distinct letters (Found remained True) OR if the number of non-distinct letters was 3 or more.<br><b>Distractor Rationale:</b><ul><li>a) The else block is incorrect. It sets Found to False if a distinct letter is found, which is the opposite of the intended logic.</li><li>c) The else { Found = True } part is flawed. It would reset Found to True for the last letter if it was distinct, even if a previous letter was repeated.</li><li>d) The counter A is incremented in the else block, meaning it's counting distinct letters, not repeated ones.</li></ul>"
"What is a ""side effect"" in the context of a procedure in pseudocode?<ul><li>a) The procedure returns an incorrect value.</li><li>b) The procedure modifies an input variable or data structure that persists after the procedure ends.</li><li>c) The procedure runs slower than expected.</li><li>d) The procedure calls another procedure.</li></ul>";"Correct: b)";"<b>Explanation:</b> A side effect occurs when a procedure, in addition to returning a value, also modifies a variable or data structure that was passed into it from the outside (e.g., a list, dictionary, or table). This change remains in effect even after the procedure has finished executing. While sometimes intentional (like a procedure designed to sort a list ""in-place""), it can often be an unintended and undesirable behavior.<br><b>Distractor Rationale:</b><ul><li>a) Returning an incorrect value is a bug or a logical error, but it is not what is meant by a side effect.</li><li>c) Performance is a measure of efficiency, not a side effect.</li><li>d) Calling another procedure is a standard part of programming and is not a side effect.</li></ul>"
"When might a side effect be desirable or intended in a procedure? Select all that apply.<ul><li>a) When calculating the average of a list of numbers.</li><li>b) When sorting a list ""in-place"" without creating a new list.</li><li>c) When deleting a key from a dictionary directly.</li><li>d) When finding the maximum value in a list.</li></ul>";"Correct: b), c)";"<b>Explanation:</b> Side effects are sometimes used for efficiency or convenience to modify a data structure directly. A procedure that sorts a list ""in-place"" is a classic example; it modifies the original list argument directly instead of returning a new, sorted list. Similarly, a procedure to delete a key from a dictionary might be designed to modify the dictionary passed to it directly, which is an intentional side effect.<br><b>Distractor Rationale:</b><ul><li>a) Calculating an average should not change the original list of numbers. This is a read-only operation.</li><li>d) Finding the maximum value is a read-only operation and should not alter the original list.</li></ul>"
"How can you prevent unintentional side effects when a procedure needs to modify a collection like a list or dictionary for its internal calculations?<ul><li>a) Use a while loop instead of a foreach loop.</li><li>b) Return a boolean value indicating success or failure.</li><li>c) Create a local copy of the input collection inside the procedure and perform modifications on the copy.</li><li>d) Pass the collection as the very last argument to the procedure.</li></ul>";"Correct: c)";"<b>Explanation:</b> The most reliable way to prevent unintentional side effects is to work on a copy. Inside the procedure, you first create a new, local variable and assign it a copy of the input collection. Then, all modifications (like removing elements, changing values) are performed on this local copy. The original collection that was passed as an argument remains untouched, and the caller of the procedure does not see any unexpected changes.<br><b>Distractor Rationale:</b><ul><li>a) The type of loop used does not inherently prevent side effects.</li><li>b) Returning a status is good practice for error handling but does not prevent the procedure from modifying its inputs.</li><li>d) The order of arguments has no bearing on whether a side effect occurs.</li></ul>"
"In the context of the ""Train"" dataset, if you have two dictionaries, one mapping TrainNumber -> List of Stations and another mapping StationName -> List of Trains, what is an efficient strategy to find if you can travel between Station A and Station B with one change of train?<ul><li>a) For every train leaving Station A, get its list of stations. For each of those stations, check all of its trains to see if any go to Station B.</li><li>b) Create a list of all stations reachable directly from Station A. Create a second list of all stations from which Station B is directly reachable. Find a common station in both lists.</li><li>c) Pick a random train from Station A and see where it goes. Then pick a random train from Station B and see where it comes from. Hope they match.</li><li>d) Combine both dictionaries into a single, larger dictionary.</li></ul>";"Correct: b)";"<b>Explanation:</b> This is a ""meet-in-the-middle"" approach and is very efficient. Instead of exploring the entire network from Station A, you do a limited exploration from both ends. You generate the set of all possible transfer stations from A (Reachable_from_A) and the set of all possible transfer stations to B (Reachable_to_B). The intersection of these two sets gives you the junction stations where a change is possible. This avoids the deeply nested loops required by exploring exhaustively from one end.<br><b>Distractor Rationale:</b><ul><li>a) This is a brute-force approach that works but is very inefficient. It can lead to a huge number of checks, especially if the initial trains from Station A go to many stations with many connecting trains.</li><li>c) This is unreliable and unlikely to find a path unless by sheer luck.</li><li>d) Combining the dictionaries is not a logical step and wouldn't simplify the problem of finding a path with a transfer.</li></ul>"
"What is the primary purpose of using a dictionary to create a histogram, for example, counting the frequency of each word length in the ""Words"" dataset?<ul><li>a) To store the words in alphabetical order.</li><li>b) To associate each word with its length.</li><li>c) To use a property (like word length) as a key and a counter as its value, efficiently grouping and counting items with that property.</li><li>d) To ensure that every word is unique.</li></ul>";"Correct: c)";"<b>Explanation:</b> A histogram groups data into bins and counts the number of items in each bin. A dictionary is perfect for this. The 'bin' identifier (e.g., the word length '5') becomes the dictionary key. The 'count' of items in that bin becomes the value associated with that key. When you encounter a new item, you find its corresponding key (its word length) and simply increment the value (the counter). This is far more efficient than, for example, maintaining separate counter variables for each possible length.<br><b>Distractor Rationale:</b><ul><li>a) Dictionaries are inherently unordered. They do not store keys alphabetically.</li><li>b) This describes a simple key-value mapping, but the specific goal of a histogram is to count frequencies, which involves incrementing the value.</li><li>d) A dictionary ensures keys are unique, but its purpose in this context is to count how many times items corresponding to that key appear, not to enforce the uniqueness of the items themselves.</li></ul>"
"When using a dictionary to partition a dataset (e.g., grouping students by city), what is typically stored as the value associated with each key (e.g., each city)?<ul><li>a) A single integer representing the total number of students.</li><li>b) A list of the unique identifiers or names of all items belonging to that group.</li><li>c) A boolean value (True/False) indicating if the group is empty or not.</li><li>d) The key of the next group in the partition.</li></ul>";"Correct: b)";"<b>Explanation:</b> Partitioning means dividing a set into disjoint (non-overlapping) subsets. When using a dictionary for this, the key represents the group (e.g., 'Chennai'). The value is typically a list containing all the items that belong to that group (e.g., a list of all student IDs from Chennai). This allows you to not only know the size of the group (by taking the length of the list) but also to access all the individual members of that group for further processing.<br><b>Distractor Rationale:</b><ul><li>a) Storing only the count is aggregation (like a histogram), not partitioning. Partitioning retains the members of each group.</li><li>c) A boolean value doesn't provide enough information about the members of the group.</li><li>d) Dictionaries are unordered; there is no concept of a 'next' group.</li></ul>"
"Consider a procedure DeleteKey(d, k) that is intended to remove key k from dictionary d. Which of the following implementations correctly performs this action WITHOUT causing a side effect on the original dictionary d?<ul><li>a) 1 myd = {}<br>2 foreach key in keys(d) {<br>3 if (k != key) {<br>4 myd[key] = d[key]<br>5 }<br>6 }<br>7 d = myd<br>8 End Procedure</li><li>b) 1 myd = {}<br>2 foreach key in keys(d) {<br>3 if (k != key) {<br>4 myd[key] = d[key]<br>5 }<br>6 }<br>7 return(myd)<br>8 End Procedure</li><li>c) 1 foreach key in keys(d) {<br>2 if (k == key) {<br>3 // Special instruction to remove d[key]<br>4 }<br>5 }<br>6 return(d)<br>7 End Procedure</li><li>d) 1 d[k] = null<br>2 return(d)<br>3 End Procedure</li></ul>";"Correct: b)";"<b>Explanation:</b> This is the correct implementation for a procedure without side effects. It creates a new, empty dictionary myd. It then copies all key-value pairs from the original dictionary d into myd, except for the key k that is meant to be deleted. Finally, it returns the newly created dictionary myd. The original dictionary d is never modified within the procedure. The calling code would then be responsible for assigning the returned result, e.g., my_dictionary = DeleteKey(my_dictionary, 'some_key').<br><b>Distractor Rationale:</b><ul><li>a) This implementation has a side effect. The line d = myd directly modifies the input dictionary d, which is the definition of a side effect.</li><li>c) This assumes a special instruction to remove a key exists, which we haven't defined. It also returns the modified d, which would be a side effect.</li><li>d) Assigning null to a key doesn't typically remove the key; it just changes its value to null. This also modifies d directly, causing a side effect.</li></ul>"
