"Front";"Back";"Extra"
"<b>What does SortedListInsert([4, 7, 9], 8) return?</b><br><br>a) [4, 7, 8, 9]<br>b) [4, 8, 7, 9]<br>c) [4, 7, 9, 8]<br>d) [8, 4, 7, 9]";"[4, 7, 8, 9]";"<b>Explanation:</b> 8 is inserted before 9 to maintain sort order.<br><br><b>Correct Answer(s):</b> [4, 7, 8, 9]"
"<b>What is the worst-case time complexity of repeatedly using SortedListInsert to sort n elements?</b><br><br>a) O(n)<br>b) O(n log n)<br>c) O(n^2)<br>d) O(1)";"O(n^2)";"<b>Explanation:</b> Each insert can take up to n steps. Repeating for n elements leads to O(n^2).<br><br><b>Correct Answer(s):</b> O(n^2)"
"<b>If list is [1, 3, 5, 7] and x = 0, where is x inserted by SortedListInsert?</b><br><br>a) At the end<br>b) At index 0<br>c) After 1<br>d) Before 5";"At index 0";"<b>Explanation:</b> Since 0 is less than all values, it is inserted at the start.<br><br><b>Correct Answer(s):</b> At index 0"
"<b>What is the result of InsertionSort([6, 4, 2])?</b><br><br>a) [2, 4, 6]<br>b) [6, 4, 2]<br>c) [4, 2, 6]<br>d) [6, 2, 4]";"[2, 4, 6]";"<b>Explanation:</b> Each element is inserted in the right place, keeping the list sorted.<br><br><b>Correct Answer(s):</b> [2, 4, 6]"
"<b>Which invariant holds during each iteration of InsertionSort?</b><br><br>a) The list becomes reverse sorted<br>b) The first part of the list is always sorted<br>c) The list contains no duplicates<br>d) The inserted element goes to the end";"The first part of the list is always sorted";"<b>Explanation:</b> InsertionSort maintains a sorted sublist at the beginning.<br><br><b>Correct Answer(s):</b> The first part of the list is always sorted"
"<b>What do 'confirm' and 'reject' lists represent in hypothesis testing pseudocode?</b><br><br>a) Sorting results<br>b) Students who pass/fail<br>c) Matching and mismatching IDs<br>d) Quartile scores";"Matching and mismatching IDs";"<b>Explanation:</b> 'Confirm' holds IDs that match the hypothesis, 'Reject' holds those that don't.<br><br><b>Correct Answer(s):</b> Matching and mismatching IDs"
"<b>Which data structure is best for checking if a student ID exists in a large dataset of 10,000 students?</b><br><br>a) A sorted list<br>b) A set or hash map<br>c) An unsorted list<br>d) A queue";"A set or hash map";"<b>Explanation:</b> Sets/hash maps provide average O(1) lookup time, which is most efficient for large datasets.<br><br><b>Correct Answer(s):</b> A set or hash map"
"<b>How do you get the second element from a list L using 'first' and 'rest'?</b><br><br>a) first(rest(L))<br>b) rest(first(L))<br>c) rest(rest(L))<br>d) first(first(L))";"first(rest(L))";"<b>Explanation:</b> rest(L) gives the tail of the list, and first() of that tail is the second element.<br><br><b>Correct Answer(s):</b> first(rest(L))"
"<b>What is the base case for a recursive function that finds the length of a list?</b><br><br>a) When the list has one element<br>b) When the list is empty<br>c) When the list is sorted<br>d) It has no base case";"When the list is empty";"<b>Explanation:</b> An empty list has a length of 0, which terminates the recursion.<br><br><b>Correct Answer(s):</b> When the list is empty"
"<b>What is the primary purpose of sorting a list of grades before assigning quartiles?</b><br><br>a) To make the list easier to read<br>b) To ensure quartiles are based on rank<br>c) To remove duplicate scores<br>d) To speed up the program";"To ensure quartiles are based on rank";"<b>Explanation:</b> Quartiles are rank-based divisions, so the data must be sorted first.<br><br><b>Correct Answer(s):</b> To ensure quartiles are based on rank"
"<b>What will 'member(5, [1, [5], 3])' return?</b><br><br>a) True<br>b) False<br>c) Error<br>d) 1";"False";"<b>Explanation:</b> The list contains the list [5], not the number 5 as a direct element.<br><br><b>Correct Answer(s):</b> False"
"<b>What is the result of 'last([1, 2, 3, 4])'?</b><br><br>a) 1<br>b) 4<br>c) [4]<br>d) 3";"4";"<b>Explanation:</b> The 'last' function returns the final element of a list.<br><br><b>Correct Answer(s):</b> 4"
"<b>If you build a list by appending elements to the end, what is the complexity of adding one element?</b><br><br>a) O(1)<br>b) O(log n)<br>c) O(n)<br>d) O(n^2)";"O(n)";"<b>Explanation:</b> To append, you must traverse the entire list to find the end, making it an O(n) operation.<br><br><b>Correct Answer(s):</b> O(n)"
"<b>Which operation is faster for linked lists?</b><br><br>a) Appending to the end<br>b) Prepending to the beginning<br>c) Accessing the 50th element<br>d) Finding the median";"Prepending to the beginning";"<b>Explanation:</b> Prepending (adding to the head) is an O(1) operation as it only requires updating the head pointer.<br><br><b>Correct Answer(s):</b> Prepending to the beginning"
"<b>What is the best-case time complexity for InsertionSort?</b><br><br>a) O(n^2)<br>b) O(n log n)<br>c) O(n)<br>d) O(1)";"O(n)";"<b>Explanation:</b> The best case occurs when the list is already sorted. Each element is compared only once.<br><br><b>Correct Answer(s):</b> O(n)"
"<b>In the expression 'U = U ++ [x]', what is the type of U and [x]?</b><br><br>a) Both are elements<br>b) Both are lists<br>c) U is a list, [x] is an element<br>d) U is an element, [x] is a list";"Both are lists";"<b>Explanation:</b> The '++' operator concatenates two lists. [x] creates a list containing the single element x.<br><br><b>Correct Answer(s):</b> Both are lists"
"<b>What does 'first(rest(rest([10, 20, 30, 40])))' return?</b><br><br>a) 10<br>b) 20<br>c) 30<br>d) 40";"30";"<b>Explanation:</b> rest() is applied twice, resulting in [30, 40]. 'first' of that is 30.<br><br><b>Correct Answer(s):</b> 30"
"<b>What is a predicate in the context of list filtering?</b><br><br>a) The list itself<br>b) A function that returns a boolean value<br>c) The first element of the list<br>d) A sorted list";"A function that returns a boolean value";"<b>Explanation:</b> A predicate is a function used to test elements for a certain condition (evaluating to true or false).<br><br><b>Correct Answer(s):</b> A function that returns a boolean value"
"<b>What is the defining property of a set?</b><br><br>a) All elements are sorted<br>b) It can contain lists<br>c) All elements are unique<br>d) It has a fixed size";"All elements are unique";"<b>Explanation:</b> Sets are collections of distinct elements; duplicates are not allowed.<br><br><b>Correct Answer(s):</b> All elements are unique"
"<b>To find the union of two lists A and B, what is the most straightforward approach?</b><br><br>a) Concatenate A and B, then remove duplicates<br>b) Find the intersection first<br>c) Sort both lists<br>d) Use binary search";"Concatenate A and B, then remove duplicates";"<b>Explanation:</b> The simplest method is to combine the lists and then filter out any repeated elements.<br><br><b>Correct Answer(s):</b> Concatenate A and B, then remove duplicates"
"<b>What is the time complexity of finding an element in an unsorted list of size n?</b><br><br>a) O(1)<br>b) O(log n)<br>c) O(n)<br>d) O(n^2)";"O(n)";"<b>Explanation:</b> In the worst case, you have to check every element until you find the one you're looking for.<br><br><b>Correct Answer(s):</b> O(n)"
"<b>What is the time complexity of finding an element in a sorted list using binary search?</b><br><br>a) O(1)<br>b) O(log n)<br>c) O(n)<br>d) O(n^2)";"O(log n)";"<b>Explanation:</b> Binary search halves the search space with each step, making it very efficient.<br><br><b>Correct Answer(s):</b> O(log n)"
"<b>If you have a list of student records, what data structure would be best to quickly look up a student's grade by their ID?</b><br><br>a) A list of lists<br>b) A hash map or dictionary<br>c) A sorted list of grades<br>d) A set of student IDs";"A hash map or dictionary";"<b>Explanation:</b> A hash map allows for direct, fast lookups using the student ID as a key.<br><br><b>Correct Answer(s):</b> A hash map or dictionary"
"<b>What does the 'map' function do?</b><br><br>a) Creates a geographic map<br>b) Applies a function to each element of a list, returning a new list<br>c) Checks if an element is in a list<br>d) Sorts the list";"Applies a function to each element of a list, returning a new list";"<b>Explanation:</b> 'map' transforms a list by applying a given function to all of its elements.<br><br><b>Correct Answer(s):</b> Applies a function to each element of a list, returning a new list"
"<b>What does the 'filter' function do?</b><br><br>a) Removes all elements from a list<br>b) Returns a new list with elements that satisfy a predicate<br>c) Sorts the list based on a condition<br>d) Applies a function to each element";"Returns a new list with elements that satisfy a predicate";"<b>Explanation:</b> 'filter' creates a new list containing only the elements for which a given predicate function returns true.<br><br><b>Correct Answer(s):</b> Returns a new list with elements that satisfy a predicate"
"<b>What is a higher-order function?</b><br><br>a) A function that is very complex<br>b) A function that operates on numbers greater than 100<br>c) A function that takes another function as an argument or returns a function<br>d) A function that is defined first in the code";"A function that takes another function as an argument or returns a function";"<b>Explanation:</b> 'map' and 'filter' are examples of higher-order functions because they take a function as one of their arguments.<br><br><b>Correct Answer(s):</b> A function that takes another function as an argument or returns a function"
"<b>What is the result of 'rest([])'?</b><br><br>a) 0<br>b) An error<br>c) An empty list<br>d) null";"An error";"<b>Explanation:</b> Applying 'rest' to an empty list is typically an undefined operation and should result in an error.<br><br><b>Correct Answer(s):</b> An error"
"<b>How can you get the last element of a list L recursively?</b><br><br>a) if rest(L) is empty, return first(L)<br>b) if first(L) is empty, return L<br>c) return last(rest(L))<br>d) return first(L)";"if rest(L) is empty, return first(L)";"<b>Explanation:</b> The recursion continues down the list until the tail is empty; the 'first' of the final non-empty list is the last element.<br><br><b>Correct Answer(s):</b> if rest(L) is empty, return first(L)"
"<b>What is a potential problem with deeply nested recursive functions?</b><br><br>a) They are hard to read<br>b) They run too fast<br>c) Stack overflow error<br>d) They use too much heap memory";"Stack overflow error";"<b>Explanation:</b> Each recursive call adds a frame to the call stack, which has a finite size.<br><br><b>Correct Answer(s):</b> Stack overflow error"
"<b>How would you flatten a list of lists like [[1, 2], [3], [4, 5]]?</b><br><br>a) By sorting it<br>b) By using the 'first' function repeatedly<br>c) By concatenating the sublists<br>d) It is not possible";"By concatenating the sublists";"<b>Explanation:</b> A common way is to recursively concatenate the first sublist with the flattened version of the rest of the list of lists.<br><br><b>Correct Answer(s):</b> By concatenating the sublists"
"<b>What is data abstraction?</b><br><br>a) Using abstract variable names<br>b) Hiding the complex implementation details of a data structure<br>c) Storing data in the cloud<br>d) Converting data to binary";"Hiding the complex implementation details of a data structure";"<b>Explanation:</b> It allows us to use data structures like lists (with 'first', 'rest') without needing to know how they are stored in memory.<br><br><b>Correct Answer(s):</b> Hiding the complex implementation details of a data structure"
"<b>What is the main trade-off when choosing a data structure?</b><br><br>a) Readability vs. writability<br>b) Time complexity vs. space complexity<br>c) Integers vs. strings<br>d) Recursive vs. iterative solutions";"Time complexity vs. space complexity";"<b>Explanation:</b> Often, a data structure that allows for faster operations (time) will require more memory (space), and vice versa.<br><br><b>Correct Answer(s):</b> Time complexity vs. space complexity"
"<b>In a list of key-value pairs like [['id1', 90], ['id2', 85]], how would you access the score 90?</b><br><br>a) first(first(L))<br>b) first(rest(first(L)))<br>c) rest(first(first(L)))<br>d) rest(rest(L))";"first(rest(first(L)))";"<b>Explanation:</b> first(L) is ['id1', 90]. rest(...) of that is [90]. first(...) of that is 90.<br><br><b>Correct Answer(s):</b> first(rest(first(L)))"
"<b>How would you check if a list is a palindrome?</b><br><br>a) Check if the first and last elements are the same<br>b) Compare the list to its reverse<br>c) Sort the list and check for duplicates<br>d) Count the number of elements";"Compare the list to its reverse";"<b>Explanation:</b> A list is a palindrome if it reads the same forwards and backward. The easiest check is to see if L is equal to reverse(L).<br><br><b>Correct Answer(s):</b> Compare the list to its reverse"
"<b>What is the output of SortedListInsert(10, [2, 4, 6, 8])?</b><br><br>a) [10, 2, 4, 6, 8]<br>b) [2, 4, 6, 8, 10]<br>c) [2, 4, 10, 6, 8]<br>d) Error";"[2, 4, 6, 8, 10]";"<b>Explanation:</b> Since 10 is the largest element, it is inserted at the end of the sorted list.<br><br><b>Correct Answer(s):</b> [2, 4, 6, 8, 10]"
"<b>Which of these is NOT a good use case for a list?</b><br><br>a) Storing a sequence of moves in a game<br>b) Storing a student's grades over time<br>c) Extremely fast lookups in a huge, unordered collection<br>d) A to-do list";"Extremely fast lookups in a huge, unordered collection";"<b>Explanation:</b> Lists have O(n) lookup time. A hash map or set (O(1) average) would be far better.<br><br><b>Correct Answer(s):</b> Extremely fast lookups in a huge, unordered collection"
"<b>What does 'difference(A, B)' for two sets A and B produce?</b><br><br>a) All elements that are in both A and B<br>b) All elements from A and B combined<br>c) Elements that are in A but not in B<br>d) Elements that are in B but not in A";"Elements that are in A but not in B";"<b>Explanation:</b> Set difference returns a new set containing only the elements from the first set that are not present in the second set.<br><br><b>Correct Answer(s):</b> Elements that are in A but not in B"
"<b>How can you represent a 2D grid or matrix using lists?</b><br><br>a) As a single, flat list<br>b) As a list of lists<br>c) As a set<br>d) It is not possible";"As a list of lists";"<b>Explanation:</b> A list of lists is a natural way to represent a matrix, where each inner list corresponds to a row.<br><br><b>Correct Answer(s):</b> As a list of lists"
"<b>What is the result of 'first(rest([[1,2],[3,4],[5,6]]))'?</b><br><br>a) 1<br>b) 2<br>c) [1,2]<br>d) [3,4]";"[3,4]";"<b>Explanation:</b> rest(...) on the main list results in [[3,4],[5,6]]. The 'first' element of that new list is [3,4].<br><br><b>Correct Answer(s):</b> [3,4]"
"<b>If you have a sorted list, what is the most efficient way to find the maximum value?</b><br><br>a) Check the first element<br>b) Check the last element<br>c) Iterate through the whole list<br>d) Use binary search";"Check the last element";"<b>Explanation:</b> In a standard ascending sorted list, the maximum value is always the last element, which is an O(1) access if the list structure allows it (or O(n) to traverse).<br><br><b>Correct Answer(s):</b> Check the last element"
"<b>Why is 'member' a recursive function?</b><br><br>a) It has to be<br>b) It's a natural fit: check the head, if not a match, check the rest (a smaller problem)<br>c) For better performance<br>d) To use less memory";"It's a natural fit: check the head, if not a match, check the rest (a smaller problem)";"<b>Explanation:</b> The problem of checking membership in a list can be broken down into checking the first element and then solving the same problem for the rest of the list.<br><br><b>Correct Answer(s):</b> It's a natural fit: check the head, if not a match, check the rest (a smaller problem)"
"<b>What is the purpose of an accumulator in a recursive function?</b><br><br>a) To count the number of recursive calls<br>b) To pass an intermediate result down through the calls<br>c) To make the function harder to read<br>d) To store the base case";"To pass an intermediate result down through the calls";"<b>Explanation:</b> An accumulator is used to build up the result as the recursion progresses, often allowing for tail-call optimization.<br><br><b>Correct Answer(s):</b> To pass an intermediate result down through the calls"
"<b>How would you merge two sorted lists, A and B, into a single sorted list?</b><br><br>a) Concatenate them and then sort the result<br>b) Repeatedly compare the heads of A and B and move the smaller one to the result list<br>c) Use the 'union' operation<br>d) Use binary search";"Repeatedly compare the heads of A and B and move the smaller one to the result list";"<b>Explanation:</b> This is the fundamental step of the merge sort algorithm. It's more efficient than a full sort after concatenation.<br><br><b>Correct Answer(s):</b> Repeatedly compare the heads of A and B and move the smaller one to the result list"
"<b>What is the primary characteristic of a queue data structure?</b><br><br>a) Last-In, First-Out (LIFO)<br>b) First-In, First-Out (FIFO)<br>c) All elements are sorted<br>d) Random access";"First-In, First-Out (FIFO)";"<b>Explanation:</b> A queue operates like a line of people; the first one to get in is the first one to be served.<br><br><b>Correct Answer(s):</b> First-In, First-Out (FIFO)"
"<b>What is the primary characteristic of a stack data structure?</b><br><br>a) Last-In, First-Out (LIFO)<br>b) First-In, First-Out (FIFO)<br>c) All elements are unique<br>d) It must contain numbers";"Last-In, First-Out (LIFO)";"<b>Explanation:</b> A stack operates like a pile of plates; the last one you put on top is the first one you take off.<br><br><b>Correct Answer(s):</b> Last-In, First-Out (LIFO)"
"<b>In a list of student scores, how would you find the lowest score?</b><br><br>a) Sort the list and take the first element<br>b) Iterate through the list, keeping track of the minimum value seen<br>c) Use a hash map<br>d) Both A and B are valid and efficient";"Both A and B are valid and efficient";"<b>Explanation:</b> Sorting and then picking the first element works (O(n log n)). Iterating to find the minimum also works (O(n)) and is often more direct if you don't need the full sorted list.<br><br><b>Correct Answer(s):</b> Both A and B are valid and efficient"
"<b>What is the time complexity of accessing the k-th element in a standard linked list?</b><br><br>a) O(1)<br>b) O(log k)<br>c) O(k)<br>d) O(n)";"O(k)";"<b>Explanation:</b> You must traverse the first k-1 elements from the head of the list to reach the k-th element.<br><br><b>Correct Answer(s):</b> O(k)"
"<b>If a function's only recursive call is the very last operation it performs, it is called...</b><br><br>a) A higher-order function<br>b) A predicate<br>c) Tail-recursive<br>d) An accumulator";"Tail-recursive";"<b>Explanation:</b> Tail-recursive functions can be optimized by compilers to avoid using extra stack space for the recursive call.<br><br><b>Correct Answer(s):</b> Tail-recursive"
"<b>Which of these sorting algorithms exhibits O(n^2) worst-case complexity?</b><br><br>a) Merge Sort<br>b) Quick Sort<br>c) Heap Sort<br>d) Insertion Sort";"Insertion Sort";"<b>Explanation:</b> Insertion Sort, Bubble Sort, and Selection Sort all have O(n^2) worst-case performance. Merge Sort and Heap Sort are O(n log n).<br><br><b>Correct Answer(s):</b> Insertion Sort"
