"Front";"Back";"Extra"
"The procedure `Insert(X, books)` is designed to insert a book `X` into a list of books `books` that is already sorted in ascending order by the number of pages.<br><pre>1. Procedure Insert(X, books)
2.   sBooks = []
3.   inserted = False
4.   foreach Y in books {
5.     if (X.Pages <= last(Y) and not(inserted)) {
6.       sBooks = sBooks ++ [[X.SeqNo, X.Pages]]
7.       inserted = True
8.     }
9.     sBooks = sBooks ++ [Y]
10.  }
11.  if (not(inserted)) {
12.    sBooks = sBooks ++ [[X.SeqNo, X.Pages]]
13.  }
14.  return(sBooks)
15. End Procedure Insert</pre>What is the primary purpose of the `inserted` flag in this procedure?";"Correct: c)";"<b>Explanation:</b> The `inserted` flag is initialized to `False` and set to `True` the moment the book `X` is placed into `sBooks` within the loop. The condition `not(inserted)` prevents `X` from being inserted multiple times if there are several books with more pages. The final check after the loop handles the case where `X` is larger than all other books.<ul><li>a) To ensure the `foreach` loop runs at least once.</li><li>b) To track if the list `books` was empty before the procedure call.</li><li>c) To ensure that the new book `X` is inserted into `sBooks` only once.</li><li>d) To count how many books have the same number of pages as `X`.</li></ul>"
"Using the `Insert(X, books)` procedure, what happens if the input list `books` is empty?";"Correct: b)";"<b>Explanation:</b> If `books` is empty, the `foreach` loop on line 4 is skipped. The procedure moves to line 11. Since `inserted` is still `False`, the condition `not(inserted)` is true, and `X` is appended to `sBooks` on line 12. The procedure then returns `sBooks`, which contains only `X`.<ul><li>a) The procedure returns an empty list.</li><li>b) The new book `X` is added to `sBooks` after the loop, and a list containing only `X` is returned.</li><li>c) The procedure enters an infinite loop.</li><li>d) An error occurs because `foreach` cannot be used on an empty list.</li></ul>"
"In the `Insert(X, books)` procedure, which line is responsible for handling the case where the new book `X` has more pages than any book in the `books` list?";"Correct: d)";"<b>Explanation:</b> If `X.Pages` is greater than the pages of all books in the `books` list, the condition on line 5 will never be true. Consequently, `inserted` will remain `False` throughout the loop. Line 11 checks for this exact scenario and appends `X` to the end of `sBooks` on line 12.<ul><li>a) Line 5</li><li>b) Line 6</li><li>c) Line 9</li><li>d) Line 12</li></ul>"
"Consider the `Insert(X, books)` procedure. If `X.Pages = 350` and `books = [[5, 220], [10, 350], [20, 400]]`, at which point is `X` inserted into `sBooks`?";"Correct: a)";"<b>Explanation:</b> The loop iterates: 1) `Y=[5, 220]`: `350 <= 220` is false. `sBooks` becomes `[[5, 220]]`. 2) `Y=[10, 350]`: `350 <= 350` is true. `X` is inserted. `sBooks` becomes `[[5, 220], [X], [10, 350]]`. `inserted` is now `True`. 3) `Y=[20, 400]`: The first part of the condition on line 5 is true, but `not(inserted)` is false, so `X` is not inserted again. `sBooks` becomes `[[5, 220], [X], [10, 350], [20, 400]]`.<ul><li>a) Before the element `[10, 350]` is appended to `sBooks`.</li><li>b) After the element `[10, 350]` is appended to `sBooks`.</li><li>c) After the loop finishes, via the check on line 11.</li><li>d) It is never inserted because a book with 350 pages already exists.</li></ul>"
"What is the role of `last(Y)` in the condition on line 5 of the `Insert(X, books)` procedure?";"Correct: c)";"<b>Explanation:</b> Each element `Y` in the `books` list is a pair `[SeqNo, Pages]`. The `last(Y)` function extracts the second element of this pair, which is the number of pages. This is necessary to compare `X.Pages` with the page count of the book `Y`.<ul><li>a) It retrieves the last book from the entire `books` list.</li><li>b) It retrieves the sequence number of the book `Y`.</li><li>c) It retrieves the page count from the pair `Y`.</li><li>d) It checks if `Y` is the last element in the `books` list.</li></ul>"
"If the `and not(inserted)` part were removed from line 5 in `Insert(X, books)`, what would be the potential issue?";"Correct: b)";"<b>Explanation:</b> Without `and not(inserted)`, the condition `X.Pages <= last(Y)` would be true for every book `Y` that has more pages than `X`. This would cause `X` to be inserted into `sBooks` multiple times, which is incorrect for a sorted insertion.<ul><li>a) The code would be more efficient.</li><li>b) The book `X` could be inserted into `sBooks` multiple times.</li><li>c) The procedure would fail if `books` is empty.</li><li>d) The final `if` statement on line 11 would always be false.</li></ul>"
"In `Insert(X, books)`, why is `Y` appended to `sBooks` on line 9 in every iteration?";"Correct: d)";"<b>Explanation:</b> The goal is to build a new sorted list `sBooks` that contains all the original books from `books` plus the new book `X`. Line 9 ensures that every book from the original list is copied over to the new list in the correct order.<ul><li>a) To remove `Y` from the original `books` list.</li><li>b) To check for duplicate books.</li><li>c) It is only appended if the condition on line 5 is false.</li><li>d) To copy all elements from the original `books` list to the new `sBooks` list.</li></ul>"
"What would `Insert(X, books)` return if `X = [12, 500]` and `books = [[5, 220], [10, 350], [20, 400]]`?";"Correct: a)";"<b>Explanation:</b> `X.Pages` (500) is greater than the page count of every book in `books`. The condition on line 5 is never met, so `inserted` remains `False`. The loop copies all of `books` into `sBooks`. Finally, the condition on line 11 is true, and `X` is appended at the end.<ul><li>a) `[[5, 220], [10, 350], [20, 400], [12, 500]]`</li><li>b) `[[12, 500], [5, 220], [10, 350], [20, 400]]`</li><li>c) `[[5, 220], [10, 350], [12, 500], [20, 400]]`</li><li>d) `[[5, 220], [10, 350], [20, 400]]`</li></ul>"
"If the condition on line 5 of `Insert(X, books)` was changed to `X.Pages < last(Y)`, how would this affect the behavior for books with identical page counts?";"Correct: c)";"<b>Explanation:</b> Using `<` instead of `<=` means that if `X` has the same number of pages as a book `Y`, `X` will be inserted *after* `Y`. The original `<=` ensures `X` is inserted *before* any existing books with the same page count, making the sort stable.<ul><li>a) It would have no effect.</li><li>b) It would cause an error.</li><li>c) The new book `X` would be inserted after existing books with the same page count.</li><li>d) The new book `X` would not be inserted if a book with the same page count exists.</li></ul>"
"What is the purpose of initializing `sBooks = []` on line 2 of `Insert(X, books)`?";"Correct: a)";"<b>Explanation:</b> The procedure constructs a new list `sBooks` from scratch. It must be initialized as an empty list so that elements (both from the original `books` list and the new book `X`) can be appended to it using the `++` operator.<ul><li>a) To create a new list to build the result, leaving the original `books` list unmodified.</li><li>b) To clear the original `books` list.</li><li>c) To check if the procedure has been called before.</li><li>d) To store a temporary copy of `X`.</li></ul>"
"In the `Insert(X, books)` procedure, if we are inserting `X` where `X.Pages = 100` into `books = [[5, 50], [10, 150]]`, what is the value of `sBooks` after the first iteration of the `foreach` loop?";"Correct: b)";"<b>Explanation:</b> In the first iteration, `Y` is `[5, 50]`. The condition `100 <= 50` is false. `X` is not inserted. Then, `Y` (`[5, 50]`) is appended to `sBooks` on line 9. So, `sBooks` is `[[5, 50]]`.<ul><li>a) `[]`</li><li>b) `[[5, 50]]`</li><li>c) `[[X], [5, 50]]`</li><li>d) `[[5, 50], [X]]`</li></ul>"
"If the line `sBooks = sBooks ++ [Y]` was moved from line 9 to be inside the `if` block on line 5 (i.e., becoming line 8), what would be the outcome?";"Correct: d)";"<b>Explanation:</b> If line 9 were moved, the elements of `books` would only be copied to `sBooks` at the moment `X` is inserted. Any elements before the insertion point would be lost, and the elements after would not be processed correctly. The resulting list would be incorrect and incomplete.<ul><li>a) The procedure would work correctly but less efficiently.</li><li>b) The procedure would work correctly but more efficiently.</li><li>c) `X` would not be inserted correctly.</li><li>d) The resulting list `sBooks` would be incomplete.</li></ul>"
"Consider `Insert(X, books)`. If `X.SeqNo` is 25 and `X.Pages` is 300, and `books` is `[[10, 200], [20, 300], [30, 400]]`, what is the final returned list?";"Correct: a)";"<b>Explanation:</b> The loop proceeds. When `Y` is `[20, 300]`, the condition `300 <= 300` is true. `X` (`[25, 300]`) is inserted. `sBooks` becomes `[[10, 200], [25, 300]]`. Then `Y` (`[20, 300]`) is appended, making `sBooks` `[[10, 200], [25, 300], [20, 300]]`. Finally, `[30, 400]` is appended. The result maintains the sorted order by pages.<ul><li>a) `[[10, 200], [25, 300], [20, 300], [30, 400]]`</li><li>b) `[[10, 200], [20, 300], [25, 300], [30, 400]]`</li><li>c) `[[25, 300], [10, 200], [20, 300], [30, 400]]`</li><li>d) `[[10, 200], [20, 300], [30, 400]]`</li></ul>"
"Which line ensures that the procedure `Insert(X, books)` does not modify the original `books` list passed to it?";"Correct: b)";"<b>Explanation:</b> Line 2 creates a new, separate list called `sBooks`. All modifications and appends are made to `sBooks`. The original `books` list is only read from in the `foreach` loop, never written to. This prevents side effects.<ul><li>a) Line 14 (return)</li><li>b) Line 2 (sBooks = [])</li><li>c) Line 4 (foreach)</li><li>d) Line 9 (sBooks = sBooks ++ [Y])</li></ul>"
"If the `return` statement on line 14 of `Insert(X, books)` was changed to `return(books)`, what would the procedure return?";"Correct: c)";"<b>Explanation:</b> The procedure would perform all the calculations to create the correctly sorted `sBooks` list, but at the very end, it would discard that result and return the original, unmodified `books` list that was passed in as a parameter.<ul><li>a) The newly sorted list including `X`.</li><li>b) An empty list.</li><li>c) The original, unmodified `books` list.</li><li>d) The book `X`.</li></ul>"
"Consider the procedure that inserts an element `x` into a sorted list `l`.<br><pre>1. Procedure SortedListInsert(l, x)
2.   newList = []
3.   inserted = False
4.   foreach z in l {
5.     if (not(inserted)) {
6.       if (x < z) {
7.         newList = newList ++ [x]
8.         inserted = True
9.       }
10.    }
11.    newList = newList ++ [z]
12.  }
13.  if (not(inserted)) {
14.    newList = newList ++ [x]
15.  }
16.  return(newList)
17. End SortedListInsert</pre>What is the content of `newList` if the procedure is called with `l = [10, 20, 40, 50]` and `x = 5`?";"Correct: b)";"<b>Explanation:</b> The `foreach` loop starts with `z = 10`. The condition `x < z` (i.e., `5 < 10`) is immediately true. `x` (which is 5) is appended to `newList`, and `inserted` becomes `True`. The procedure then appends the rest of the elements from `l` (10, 20, 40, 50) to `newList`, resulting in `[5, 10, 20, 40, 50]`.<ul><li>a) `[10, 20, 40, 50, 5]`</li><li>b) `[5, 10, 20, 40, 50]`</li><li>c) `[10, 5, 20, 40, 50]`</li><li>d) `[5]`</li></ul>"
"In `SortedListInsert`, what happens if `x` is larger than all elements in `l`?";"Correct: a)";"<b>Explanation:</b> If `x` is the largest element, the condition `x < z` on line 6 will never be true for any `z` in `l`. The `foreach` loop will complete, having copied all of `l` into `newList`, but `inserted` will remain `False`. The `if` condition on line 13 will then be true, and `x` will be appended to the end of `newList`.<ul><li>a) `x` is appended at the end of `newList` by the code on lines 13-14.</li><li>b) `x` is inserted at the beginning of `newList`.</li><li>c) The procedure returns `newList` without `x`.</li><li>d) An error occurs.</li></ul>"
"What is the final value of `newList` if `SortedListInsert` is called with `l = [10, 20, 30]` and `x = 25`?";"Correct: c)";"<b>Explanation:</b> 1. `z=10`: `25 < 10` is false. `newList` becomes `[10]`. 2. `z=20`: `25 < 20` is false. `newList` becomes `[10, 20]`. 3. `z=30`: `25 < 30` is true. `x` (25) is appended, `newList` becomes `[10, 20, 25]`. `inserted` is set to `True`. Then `z` (30) is appended, making `newList` `[10, 20, 25, 30]`.<ul><li>a) `[10, 20, 30, 25]`</li><li>b) `[10, 25, 20, 30]`</li><li>c) `[10, 20, 25, 30]`</li><li>d) `[25, 10, 20, 30]`</li></ul>"
"In `SortedListInsert`, if `l` is empty, which lines of code are executed after line 3?";"Correct: d)";"<b>Explanation:</b> If `l` is empty, the `foreach` loop on line 4 does not execute. The code jumps directly to line 13. Since `inserted` is `False`, line 14 is executed, appending `x` to the empty `newList`. Finally, line 16 returns `newList`.<ul><li>a) Lines 4, 11, 16</li><li>b) Lines 5, 6, 7, 8, 11</li><li>c) Only line 16</li><li>d) Lines 13, 14, 16</li></ul>"
"What is the purpose of the `not(inserted)` check on line 5 of `SortedListInsert`?";"Correct: a)";"<b>Explanation:</b> This check ensures that the logic for inserting `x` (lines 6-9) is only considered as long as `x` has not yet been placed in `newList`. Once `inserted` becomes `True`, this entire block is skipped for all subsequent elements `z`, making the process more efficient by simply copying the rest of the elements.<ul><li>a) To prevent `x` from being inserted more than once and to improve efficiency.</li><li>b) To handle the case where `l` is empty.</li><li>c) To ensure `z` is always larger than `x`.</li><li>d) To count the number of elements in `l`.</li></ul>"
"If the comparison on line 6 of `SortedListInsert` were `x <= z`, how would the output change for `l = [10, 20, 20, 30]` and `x = 20`?";"Correct: a)";"<b>Explanation:</b> With `x <= z`, when `z` is the first `20`, the condition `20 <= 20` is true. `x` would be inserted *before* the first existing `20`. The original `<` ensures `x` is inserted after all existing `20`s (i.e., when `z` becomes `30`). The `<=` operator makes the sort stable for elements inserted from an unsorted list.<ul><li>a) `x` would be inserted before the existing `20`s.</li><li>b) `x` would be inserted after the existing `20`s.</li><li>c) The output would be the same.</li><li>d) `x` would not be inserted.</li></ul>"
"In `SortedListInsert`, what does the variable `z` represent in each iteration of the loop?";"Correct: c)";"<b>Explanation:</b> The `foreach z in l` statement iterates through the list `l`. In each iteration, the variable `z` holds the current element from the list `l` that is being processed.<ul><li>a) The index of the current element in `l`.</li><li>b) The entire list `l`.</li><li>c) The current element being processed from `l`.</li><li>d) The new element `x` to be inserted.</li></ul>"
"What is the state of `newList` just before the `foreach` loop begins in `SortedListInsert`?";"Correct: b)";"<b>Explanation:</b> Line 2, `newList = []`, is executed before the loop on line 4 begins. This initializes `newList` as an empty list, ready to be populated.<ul><li>a) It is undefined.</li><li>b) It is an empty list `[]`.</li><li>c) It contains a copy of `l`.</li><li>d) It contains `x`.</li></ul>"
"In `SortedListInsert`, if `x` is equal to an element `z` in the list, where is `x` inserted relative to `z`?";"Correct: d)";"<b>Explanation:</b> The condition for insertion is `x < z`. If `x` is equal to `z`, this condition is false. Therefore, `x` will not be inserted at that point. The loop will continue, and `z` will be appended to `newList`. `x` will be inserted later, when a `z` is found that is strictly greater than `x`. This means `x` is inserted after all equal elements.<ul><li>a) Before `z`.</li><li>b) It replaces `z`.</li><li>c) The procedure exits with an error.</li><li>d) After `z`.</li></ul>"
"Which part of the `SortedListInsert` procedure ensures that all original elements of `l` are present in the final `newList`?";"Correct: c)";"<b>Explanation:</b> Line 11, `newList = newList ++ [z]`, is outside the `if` blocks but inside the `foreach` loop. This ensures that every element `z` from the original list `l` is appended to `newList` during the iteration, preserving all original elements.<ul><li>a) Lines 7-8</li><li>b) Lines 13-14</li><li>c) Line 11</li><li>d) Line 2</li></ul>"
"If line 11 in `SortedListInsert` were accidentally deleted, what would `newList` contain at the end?";"Correct: a)";"<b>Explanation:</b> Without line 11, no elements from the original list `l` would be copied to `newList`. The only element that could possibly be added is `x` (on line 7 or 14). Therefore, the returned list would contain at most the single element `x`.<ul><li>a) Only the element `x`, if it was inserted.</li><li>b) All elements of `l`, but not `x`.</li><li>c) An empty list.</li><li>d) The procedure would not change `newList`.</li></ul>"
"What is the value of the `inserted` flag when the `foreach` loop finishes, if `l = [10, 20]` and `x = 30`?";"Correct: b)";"<b>Explanation:</b> Since `x = 30` is greater than both 10 and 20, the condition `x < z` on line 6 is never met. The `inserted` flag is initialized to `False` on line 3 and is never changed inside the loop.<ul><li>a) True</li><li>b) False</li><li>c) Undefined</li><li>d) 1</li></ul>"
"In `SortedListInsert`, if `l = [5, 15, 25]` and `x = 15`, what is the final returned list?";"Correct: c)";"<b>Explanation:</b> 1. `z=5`: `15 < 5` is false. `newList` becomes `[5]`. 2. `z=15`: `15 < 15` is false. `newList` becomes `[5, 15]`. 3. `z=25`: `15 < 25` is true. `x` (15) is appended, `newList` becomes `[5, 15, 15]`. `inserted` becomes `True`. Then `z` (25) is appended, making `newList` `[5, 15, 15, 25]`.<ul><li>a) `[5, 15, 25]`</li><li>b) `[5, 15, 25, 15]`</li><li>c) `[5, 15, 15, 25]`</li><li>d) `[15, 5, 15, 25]`</li></ul>"
"Why is it necessary to have the `if (not(inserted))` check on lines 13-15 of `SortedListInsert`?";"Correct: d)";"<b>Explanation:</b> This block handles the specific case where the element `x` to be inserted is greater than all the elements currently in the list `l`. In this situation, the insertion condition inside the loop is never met, and `x` must be appended at the very end after the loop has finished.<ul><li>a) To handle negative numbers.</li><li>b) To handle duplicate numbers.</li><li>c) To handle an empty input list `l`.</li><li>d) To handle the case where `x` is the largest element.</li></ul>"
"If `l = [100]` and `x = 50`, what is the value of `newList` immediately after line 8 in `SortedListInsert` is executed?";"Correct: a)";"<b>Explanation:</b> The loop starts with `z=100`. The condition `50 < 100` is true. Line 7 appends `x` (50) to `newList`, so `newList` becomes `[50]`. Line 8 then sets `inserted` to `True`. The question asks for the state of `newList` right after this point.<ul><li>a) `[50]`</li><li>b) `[50, 100]`</li><li>c) `[100]`</li><li>d) `[]`</li></ul>"
"The `InsertionSort` procedure uses the `SortedListInsert` procedure to sort a list.<br><pre>1. Procedure InsertionSort(l)
2.   sortedList = []
3.   foreach z in l {
4.     sortedList = SortedListInsert(sortedList, z)
5.   }
6.   return(sortedList)
7. End InsertionSort</pre>What is the state of `sortedList` after the third iteration of the `foreach` loop if the input is `l = [40, 10, 30, 20]`?";"Correct: a)";"<b>Explanation:</b> - **Iteration 1 (z=40):** `sortedList` becomes `[40]`. - **Iteration 2 (z=10):** `sortedList` becomes `[10, 40]`. - **Iteration 3 (z=30):** `sortedList` becomes `[10, 30, 40]`. After the third iteration, `sortedList` contains the first three elements of `l` in sorted order.<ul><li>a) `[10, 30, 40]`</li><li>b) `[40, 10, 30]`</li><li>c) `[10, 40]`</li><li>d) `[]`</li></ul>"
"In `InsertionSort`, what is the value of `sortedList` just before the `foreach` loop begins?";"Correct: c)";"<b>Explanation:</b> Line 2 initializes `sortedList` to an empty list. This is the state of the variable right before the loop on line 3 starts its first iteration. This empty list is the base case for the `SortedListInsert` procedure.<ul><li>a) A copy of `l`.</li><li>b) The first element of `l`.</li><li>c) An empty list `[]`.</li><li>d) Undefined.</li></ul>"
"If `l = [5, 2, 8]`, how many times is `SortedListInsert` called by `InsertionSort`?";"Correct: b)";"<b>Explanation:</b> The `foreach` loop in `InsertionSort` iterates once for each element in the input list `l`. Since `l` has three elements (5, 2, and 8), the loop will run three times, and `SortedListInsert` will be called three times.<ul><li>a) 2</li><li>b) 3</li><li>c) 4</li><li>d) It depends on the values in the list.</li></ul>"
"What is the 'invariant' property of the `sortedList` variable inside the `InsertionSort` procedure?";"Correct: d)";"<b>Explanation:</b> An invariant is a property that holds true before and after each iteration of a loop. In this case, `sortedList` starts as sorted (an empty list is sorted) and after each call to `SortedListInsert`, it remains sorted. This property is maintained throughout the execution of the procedure.<ul><li>a) It is always empty.</li><li>b) It is always in reverse sorted order.</li><li>c) It always contains the same number of elements as `l`.</li><li>d) It is always sorted.</li></ul>"
"If the input list `l` to `InsertionSort` is already sorted, what is the behavior of the algorithm?";"Correct: a)";"<b>Explanation:</b> If `l` is already sorted, each call to `SortedListInsert` will insert the new element `z` at the end of `sortedList`, as `z` will always be the largest element seen so far. The algorithm still performs all the comparisons but does not need to shift elements. It works correctly but does not terminate early.<ul><li>a) It works correctly and produces a sorted list.</li><li>b) It produces a list in reverse sorted order.</li><li>c) It is significantly faster because it skips the loop.</li><li>d) It results in an error.</li></ul>"
"What would happen in `InsertionSort` if `sortedList` was initialized to a copy of `l` instead of `[]`?";"Correct: c)";"<b>Explanation:</b> If `sortedList` started as a copy of `l`, the procedure would then iterate through `l` again, inserting each element of `l` into the already full (and unsorted) `sortedList`. The result would be a list with twice the number of elements and would not be correctly sorted.<ul><li>a) The sort would be faster.</li><li>b) The result would be the same.</li><li>c) The final list would be incorrect and contain duplicate elements.</li><li>d) The procedure would not modify the list.</li></ul>"
"In `InsertionSort`, the variable `z` holds the element from `l` being inserted. What is the value of `z` during the second iteration of the loop for `l = [50, 25, 75]`?";"Correct: b)";"<b>Explanation:</b> The `foreach` loop iterates through `l` in order. The first iteration uses `z = 50`. The second iteration uses the second element of `l`, which is `z = 25`.<ul><li>a) 50</li><li>b) 25</li><li>c) 75</li><li>d) `[50, 25]`</li></ul>"
"If `SortedListInsert` had a bug and did not insert the element `x`, what would `InsertionSort(l)` return?";"Correct: a)";"<b>Explanation:</b> If `SortedListInsert` failed to insert `x`, then in each iteration of `InsertionSort`, the call would effectively do nothing. `sortedList` would remain `[]` throughout the execution, and an empty list would be returned.<ul><li>a) An empty list.</li><li>b) The original list `l`.</li><li>c) The first element of `l`.</li><li>d) An error.</li></ul>"
"The final `return(sortedList)` statement in `InsertionSort` is executed at what point?";"Correct: d)";"<b>Explanation:</b> The `return` statement is on line 6, which is located after the `foreach` loop. It is executed only after the loop has completed all of its iterations, meaning every element from `l` has been processed and inserted into `sortedList`.<ul><li>a) During each iteration of the loop.</li><li>b) Only if the list `l` is not empty.</li><li>c) Before the loop begins.</li><li>d) After the `foreach` loop has finished completely.</li></ul>"
"If `l = [3, 1, 2]`, what is the value of `sortedList` passed to `SortedListInsert` in the final iteration of the `InsertionSort` loop?";"Correct: b)";"<b>Explanation:</b> - Iteration 1 (z=3): `SortedListInsert([], 3)` is called. `sortedList` becomes `[3]`. - Iteration 2 (z=1): `SortedListInsert([3], 1)` is called. `sortedList` becomes `[1, 3]`. - Iteration 3 (z=2): This is the final iteration. The value of `sortedList` at the beginning of this iteration is `[1, 3]`. This is what is passed to `SortedListInsert`.<ul><li>a) `[3, 1]`</li><li>b) `[1, 3]`</li><li>c) `[1, 2, 3]`</li><li>d) `[]`</li></ul>"
"How does `InsertionSort` handle an empty list `l` as input?";"Correct: a)";"<b>Explanation:</b> If `l` is empty, the `foreach` loop on line 3 never executes. The procedure proceeds directly from line 2 (`sortedList = []`) to line 6 (`return(sortedList)`). It correctly returns an empty list.<ul><li>a) It correctly returns an empty list.</li><li>b) It causes an error.</li><li>c) It enters an infinite loop.</li><li>d) It returns `None`.</li></ul>"
"What is the main logical operation happening on line 4 of `InsertionSort`?";"Correct: d)";"<b>Explanation:</b> Line 4 takes the current `sortedList`, calls `SortedListInsert` to get a new, larger sorted list, and then updates `sortedList` to be this new list. This is a process of incrementally building the final sorted list by repeatedly replacing the old version with a new one.<ul><li>a) Comparing two elements.</li><li>b) Removing an element from `l`.</li><li>c) Checking if `sortedList` is empty.</li><li>d) Incrementally building a sorted list by reassigning `sortedList` in each iteration.</li></ul>"
"If `l` contains duplicate values, for example `l = [20, 10, 20]`, what will `InsertionSort` produce?";"Correct: c)";"<b>Explanation:</b> `InsertionSort` will process each element, including duplicates. The `SortedListInsert` procedure correctly places each element, even if it's a duplicate, into the sorted list. The final output will be a sorted list containing all original elements, including any duplicates. The result for `[20, 10, 20]` would be `[10, 20, 20]`.<ul><li>a) A list with duplicates removed.</li><li>b) An error.</li><li>c) A sorted list that preserves the duplicates.</li><li>d) An infinite loop.</li></ul>"
"In `InsertionSort`, does the original list `l` get modified by the procedure?";"Correct: b)";"<b>Explanation:</b> The procedure only reads from `l` using the `foreach` loop. It never writes to `l` or reassigns it. All modifications happen on the separate `sortedList` variable. This means `InsertionSort` has no side effects on its input list.<ul><li>a) Yes, it is emptied as elements are processed.</li><li>b) No, it is only read from and remains unchanged.</li><li>c) Yes, it becomes sorted in place.</li><li>d) It depends on the contents of `l`.</li></ul>"
"What is the primary disadvantage of `InsertionSort` compared to more advanced sorting algorithms?";"Correct: a)";"<b>Explanation:</b> For each of the `n` elements in the list, `SortedListInsert` may have to iterate through the already sorted portion, which can be up to `n` elements long. This leads to a complexity of roughly n*n operations, which is inefficient for very large lists compared to algorithms like Merge Sort or Quick Sort.<ul><li>a) Its performance is slow for large lists (O(n^2) complexity).</li><li>b) It does not work with duplicate values.</li><li>c) It requires a large amount of extra memory.</li><li>d) It cannot sort lists of strings.</li></ul>"
"Consider the `SimpleGradeAssignment` procedure, which assigns grades to a sorted list `l` of `[StudentId, Marks]` pairs.<br><pre>1. Procedure SimpleGradeAssignment(l)
2.   classSize = length(l)
3.   q4 = classSize / 4
4.   q3 = classSize / 2
5.   q2 = 3 * classSize / 4
6.   gradeA = [], gradeB = [], gradeC = [], gradeD = []
7.   position = 0
8.   foreach x in l {
9.     if (position > q2) {
10.      gradeA = gradeA ++ [first(x)]
11.    }
12.    if (position > q3 and position <= q2) {
13.      gradeB = gradeB ++ [first(x)]
14.    }
15.    if (position > q4 and position <= q3) {
16.      gradeC = gradeC ++ [first(x)]
17.    }
18.    if (position <= q4) {
19.      gradeD = gradeD ++ [first(x)]
20.    }
21.    position = position + 1
22.  }
23.  return([gradeA, gradeB, gradeC, gradeD])
24. End SimpleGradeAssignment</pre>If `l` has 20 elements (positions 0-19), which range of `position` values will result in a student being assigned to `gradeB`?";"Correct: b)";"<b>Explanation:</b> With `classSize = 20`, the quartiles are `q4 = 5`, `q3 = 10`, and `q2 = 15`. The condition for `gradeB` is `position > q3 and position <= q2`, which translates to `position > 10` and `position <= 15`. This corresponds to positions 11, 12, 13, 14, and 15.<ul><li>a) `position > 15`</li><li>b) `position > 10` and `position <= 15`</li><li>c) `position > 5` and `position <= 10`</li><li>d) `position <= 5`</li></ul>"
"In `SimpleGradeAssignment`, what is the purpose of the `position` variable?";"Correct: c)";"<b>Explanation:</b> The `position` variable acts as a counter that tracks the index of the current element `x` in the sorted list `l`. This is necessary because the grade assignment is based on the element's rank (position) in the sorted list, not its actual mark.<ul><li>a) To store the student's final grade.</li><li>b) To count the total number of students.</li><li>c) To keep track of the current element's index in the sorted list `l`.</li><li>d) To store the student's ID.</li></ul>"
"If `classSize` is 30 in `SimpleGradeAssignment`, what will be the value of `q3`?";"Correct: a)";"<b>Explanation:</b> The procedure calculates `q3` as `classSize / 2`. If `classSize` is 30, then `q3` will be `30 / 2 = 15`. This represents the halfway point in the list, separating the bottom half (grades C and D) from the top half (grades A and B).<ul><li>a) 15</li><li>b) 7.5</li><li>c) 22.5</li><li>d) 30</li></ul>"
"Why is `first(x)` used in lines 10, 13, 16, and 19 of `SimpleGradeAssignment`?";"Correct: d)";"<b>Explanation:</b> The input list `l` contains elements that are pairs of the form `[StudentId, Marks]`. The variable `x` holds one such pair. The procedure's goal is to create lists of student IDs for each grade. The `first(x)` function correctly extracts the `StudentId` to be appended to the appropriate grade list.<ul><li>a) To get the student's marks.</li><li>b) To check if `x` is a list.</li><li>c) It is a mistake; it should be `last(x)`.</li><li>d) To extract the student's ID from the `[StudentId, Marks]` pair.</li></ul>"
"What does the `SimpleGradeAssignment` procedure return?";"Correct: b)";"<b>Explanation:</b> The `return` statement on line 23 constructs a new list. This list contains four elements, where each element is one of the grade lists (`gradeA`, `gradeB`, `gradeC`, `gradeD`). This is an example of a nested list or a list of lists.<ul><li>a) A single list containing all student IDs.</li><li>b) A list containing four other lists: one for each grade.</li><li>c) The average mark of the class.</li><li>d) The student with the highest grade.</li></ul>"
"If the `if` conditions in `SimpleGradeAssignment` were not mutually exclusive (e.g., if they were all just `if (position > q_value)`), what would be the issue?";"Correct: a)";"<b>Explanation:</b> If the conditions were not exclusive, a single student could be assigned to multiple grade lists. For example, a position of 16 would satisfy `position > q2`, `position > q3`, and `position > q4`, potentially adding the student to grades A, B, and C, which is incorrect.<ul><li>a) A student could be assigned to multiple grades simultaneously.</li><li>b) The procedure would be more efficient.</li><li>c) The `position` variable would not increment correctly.</li><li>d) It would have no negative effect.</li></ul>"
"What is a key assumption about the input list `l` for the `SimpleGradeAssignment` procedure to work as intended?";"Correct: c)";"<b>Explanation:</b> The entire logic of assigning grades based on quartiles depends on the list being sorted by marks. If the list were unsorted, the `position` would not correspond to the student's rank, and the grade assignments would be meaningless.<ul><li>a) The list must contain an even number of students.</li><li>b) The list must not contain duplicate marks.</li><li>c) The list must be sorted by marks in ascending order.</li><li>d) The list must contain student names instead of IDs.</li></ul>"
"In `SimpleGradeAssignment`, if `classSize = 10`, what is the condition for being assigned `gradeD`?";"Correct: d)";"<b>Explanation:</b> If `classSize = 10`, then `q4 = 10 / 4 = 2.5`. The condition for `gradeD` is `position <= q4`. Therefore, students at positions 0, 1, and 2 would be assigned grade D.<ul><li>a) `position <= 10`</li><li>b) `position <= 7.5`</li><li>c) `position <= 5`</li><li>d) `position <= 2.5`</li></ul>"
"What would be the effect of initializing `position = 1` instead of `position = 0` in `SimpleGradeAssignment`?";"Correct: b)";"<b>Explanation:</b> If `position` started at 1, the position values would range from 1 to `classSize`. This would shift all the quartile boundaries by one, potentially misclassifying students at the edges of the grade boundaries and miscounting the total number of students processed.<ul><li>a) It would have no effect.</li><li>b) It would shift the grade boundaries, leading to incorrect assignments.</li><li>c) It would cause the first student to be skipped.</li><li>d) It would make the procedure more accurate.</li></ul>"
"If the input list `l` to `SimpleGradeAssignment` is empty, what is the returned value?";"Correct: a)";"<b>Explanation:</b> If `l` is empty, `classSize` is 0, and the quartiles are 0. The `foreach` loop does not run. The procedure returns the list `[gradeA, gradeB, gradeC, gradeD]`, where each of these is still the empty list it was initialized to.<ul><li>a) A list containing four empty lists.</li><li>b) An error.</li><li>c) `None`.</li><li>d) An empty list `[]`.</li></ul>"
"The logic in `SimpleGradeAssignment` assigns grades based on quartiles. What is a potential flaw of this 'simple' approach, as mentioned in the lectures?";"Correct: c)";"<b>Explanation:</b> The main flaw is that it uses hard quartile boundaries based on position. If two students have the exact same mark but fall on either side of a quartile boundary (e.g., positions 10 and 11), they will receive different grades, which is unfair. A more robust system would handle such ties.<ul><li>a) It is too slow for large lists.</li><li>b) It cannot handle lists with an odd number of students.</li><li>c) It can assign different grades to students with identical marks if they fall on a quartile boundary.</li><li>d) It requires the list to be sorted, which is inefficient.</li></ul>"
"In `SimpleGradeAssignment`, which grade corresponds to the top 25% of students?";"Correct: a)";"<b>Explanation:</b> The list `l` is sorted in ascending order of marks. Therefore, the students with the highest marks are at the end of the list (highest positions). The condition `position > q2` (where `q2` is the 75th percentile) correctly identifies the top 25% of students for `gradeA`.<ul><li>a) gradeA</li><li>b) gradeB</li><li>c) gradeC</li><li>d) gradeD</li></ul>"
"What data structure is returned by the `SimpleGradeAssignment` procedure?";"Correct: d)";"<b>Explanation:</b> The procedure returns a single list, `[gradeA, gradeB, gradeC, gradeD]`. However, each of the elements within this list is also a list (of student IDs). This structure is known as a list of lists or a nested list.<ul><li>a) A simple list of numbers.</li><li>b) A dictionary.</li><li>c) Four separate lists.</li><li>d) A list of lists.</li></ul>"
"If the line `position = position + 1` were removed from `SimpleGradeAssignment`, what would happen?";"Correct: c)";"<b>Explanation:</b> If `position` were never incremented, it would remain 0 for every iteration of the loop. According to the conditions, every student would be assigned to `gradeD` (since `0 <= q4` will always be true for a non-empty list), and the procedure would likely enter an infinite loop if the list is not empty.<ul><li>a) The procedure would work correctly.</li><li>b) Only the first student would be graded.</li><li>c) An infinite loop would occur and/or all students would get grade D.</li><li>d) No students would be graded.</li></ul>"
"In `SimpleGradeAssignment`, if `l` has 30 students, how many students will be in `gradeA`?";"Correct: b)";"<b>Explanation:</b> `classSize = 30`. `q2 = 3 * 30 / 4 = 22.5`. The condition for grade A is `position > 22.5`. This applies to positions 23 through 29 (a total of 7 positions). Therefore, 7 students will receive grade A.<ul><li>a) 8</li><li>b) 7</li><li>c) 7.5</li><li>d) 15</li></ul>"
"Given a list `L = [""a"", ""b"", ""c"", ""d"", ""e""]`, what is the result of the operation `first(rest(rest(L)))`?";"Correct: a)";"<b>Explanation:</b> The operation is evaluated from the inside out: 1. `rest(L)` results in the list `[""b"", ""c"", ""d"", ""e""]`. 2. `rest` of that result is `[""c"", ""d"", ""e""]`. 3. `first` of that final list is the element `""c""`. The `first` function returns a single element, not a list.<ul><li>a) `""c""`</li><li>b) `[""c""]`</li><li>c) `[""c"", ""d"", ""e""]`</li><li>d) `""b""`</li></ul>"
"If `L = [10, 20, 30, 40]`, what is `init(L)`?";"Correct: c)";"<b>Explanation:</b> The `init` function returns all elements of the list *except for the last one*. Therefore, `init([10, 20, 30, 40])` is `[10, 20, 30]`.<ul><li>a) `[10]`</li><li>b) `[20, 30, 40]`</li><li>c) `[10, 20, 30]`</li><li>d) `40`</li></ul>"
"What is the result of `last(init(L))` for `L = [1, 2, 3, 4, 5]`?";"Correct: b)";"<b>Explanation:</b> First, `init(L)` is evaluated to `[1, 2, 3, 4]`. Then, `last` is applied to this new list, which returns the last element, `4`.<ul><li>a) `5`</li><li>b) `4`</li><li>c) `[4]`</li><li>d) `3`</li></ul>"
"If a list `M` has only one element, e.g., `M = [100]`, what is `rest(M)`?";"Correct: a)";"<b>Explanation:</b> The `rest` function returns all elements after the first. If there is only one element, there are no elements after the first, so an empty list `[]` is returned.<ul><li>a) `[]`</li><li>b) `100`</li><li>c) `None`</li><li>d) An error occurs.</li></ul>"
"What is the result of `first(L) ++ rest(L)` for any non-empty list `L`?";"Correct: d)";"<b>Explanation:</b> This operation is not valid. `first(L)` returns a single element, while `rest(L)` returns a list. The `++` operator is for concatenating two lists. You cannot concatenate an element and a list directly. The correct way to reconstruct the list would be `[first(L)] ++ rest(L)`.<ul><li>a) The original list `L`.</li><li>b) A list with the first element duplicated.</li><li>c) An empty list.</li><li>d) An error or undefined behavior.</li></ul>"
"If `L = [5]`, what is `init(L)`?";"Correct: b)";"<b>Explanation:</b> Similar to the `rest` function on a single-element list, `init` returns all elements *before* the last one. Since there are no elements before the last one, it returns an empty list.<ul><li>a) `5`</li><li>b) `[]`</li><li>c) An error occurs.</li><li>d) `None`</li></ul>"
"Given `L = [""x"", ""y""]`, what is `last(rest(L))`?";"Correct: a)";"<b>Explanation:</b> First, `rest(L)` evaluates to `[""y""]`. Then, `last` is applied to `[""y""]`, which returns the single element `""y""`.<ul><li>a) `""y""`</li><li>b) `""x""`</li><li>c) `[""y""]`</li><li>d) An error occurs.</li></ul>"
"Which sequence of operations on a list `L` of length 5 will result in a list containing only the third element of `L`?";"Correct: c)";"<b>Explanation:</b> `rest(rest(L))` removes the first two elements, resulting in a list of the last three. `init(init(...))` on that result then removes the last two elements, leaving only the first element of that sublist, which was the third element of the original list. `first(rest(rest(L)))` would return the element itself, not a list containing it.<ul><li>a) `rest(init(L))`</li><li>b) `first(rest(L))`</li><li>c) `init(init(rest(rest(L))))`</li><li>d) `last(rest(L))`</li></ul>"
"What is the value of `length(init(L))` compared to `length(L)` for a non-empty list `L`?";"Correct: b)";"<b>Explanation:</b> The `init` function removes exactly one element (the last one) from the list. Therefore, the length of the resulting list will always be one less than the length of the original list.<ul><li>a) They are the same.</li><li>b) `length(init(L))` is `length(L) - 1`.</li><li>c) `length(init(L))` is `1`.</li><li>d) It is undefined.</li></ul>"
"If `L` is an empty list `[]`, what is the result of `first(L)`?";"Correct: d)";"<b>Explanation:</b> Applying `first`, `last`, `rest`, or `init` to an empty list is an undefined operation, as there is no first or last element to retrieve or remove. This would typically result in an error.<ul><li>a) `[]`</li><li>b) `0`</li><li>c) `None`</li><li>d) An error or undefined behavior.</li></ul>"
"What is the result of `[first(L)] ++ rest(L)` for any non-empty list `L`?";"Correct: a)";"<b>Explanation:</b> This is the correct way to reconstruct a list from its parts. `first(L)` gets the first element. `[first(L)]` creates a new list containing just that element. This is then concatenated with `rest(L)`, which is the list of all other elements, perfectly reconstructing the original list `L`.<ul><li>a) The original list `L`.</li><li>b) An error.</li><li>c) A list with the first element at the end.</li><li>d) An empty list.</li></ul>"
"For `L = [a, b, c, d]`, what is `init(rest(L))`?";"Correct: c)";"<b>Explanation:</b> `rest(L)` is `[b, c, d]`. `init` of this result is `[b, c]`. This operation effectively removes both the first and the last elements of the original list.<ul><li>a) `[a, b, c]`</li><li>b) `[b, c, d]`</li><li>c) `[b, c]`</li><li>d) `[c, d]`</li></ul>"
"Which function would you use to get the second element of a list `L`?";"Correct: b)";"<b>Explanation:</b> To get the second element, you first need to remove the first element, which is done with `rest(L)`. This gives you a new list starting with the original second element. You then take the `first` element of this new list.<ul><li>a) `rest(first(L))`</li><li>b) `first(rest(L))`</li><li>c) `last(init(L))`</li><li>d) `rest(rest(L))`</li></ul>"
"Which function would you use to get the second-to-last element of a list `L`?";"Correct: a)";"<b>Explanation:</b> To get the second-to-last element, you first need to remove the last element, which is done with `init(L)`. This gives you a new list ending with the original second-to-last element. You then take the `last` element of this new list.<ul><li>a) `last(init(L))`</li><li>b) `init(last(L))`</li><li>c) `first(init(L))`</li><li>d) `init(init(L))`</li></ul>"
"If `length(L) = N`, what is `length(rest(init(L)))`?";"Correct: d)";"<b>Explanation:</b> `init(L)` produces a list of length `N-1`. `rest` of that list removes one more element, producing a list of length `N-2`. This assumes `N` is at least 2.<ul><li>a) `N`</li><li>b) `N-1`</li><li>c) `N+1`</li><li>d) `N-2`</li></ul>"
"The following pseudocode checks a hypothesis about student grades.<br><pre>1.  confirm = [], reject = []
2.  foreach x in mathsAGrades {
3.    found = False
4.    foreach y in physicsAGrades {
5.      if (x == y) {
6.        confirm = confirm ++ [x]
7.        found = True
8.        exitloop
9.      }
10.   }
11.   if (not(found)) {
12.     reject = reject ++ [x]
13.   }
14. }</pre>A student `x` from `mathsAGrades` is added to the `reject` list under which of the following conditions?";"Correct: a), d)";"<b>Explanation:</b> The `found` flag is set to `True` only if a match `x == y` is found inside the inner loop. The student `x` is added to the `reject` list only if the `found` flag remains `False` after the inner loop completes. This happens if no match is found. If `physicsAGrades` is empty, the inner loop never runs, `found` remains `False`, and any student `x` from `mathsAGrades` will be added to `reject`. Therefore, both (a) and (d) are correct conditions.<ul><li>a) The student `x` is not found in the `physicsAGrades` list.</li><li>b) The student `x` is found in the `physicsAGrades` list.</li><li>c) The `mathsAGrades` list is empty.</li><li>d) The `physicsAGrades` list is empty, but `mathsAGrades` is not.</li></ul>"
"In the hypothesis testing code, what is the purpose of `exitloop` on line 8?";"Correct: b)";"<b>Explanation:</b> Once a match for student `x` is found in the `physicsAGrades` list, there is no need to continue searching the rest of that list for the same student. `exitloop` terminates the inner `foreach` loop prematurely as an optimization, saving unnecessary comparisons.<ul><li>a) To terminate the outer `foreach` loop.</li><li>b) To terminate the inner `foreach` loop once a match is found.</li><li>c) To add the student to the `reject` list.</li><li>d) To reset the `found` flag to `False`.</li></ul>"
"If a student is in `mathsAGrades` and also in `physicsAGrades`, which list will their ID be added to?";"Correct: a)";"<b>Explanation:</b> If a student `x` from `mathsAGrades` is found in `physicsAGrades`, the `if (x == y)` condition on line 5 becomes true. Line 6 then appends `x` to the `confirm` list. The `found` flag is set to `True`, so the `if (not(found))` block is skipped.<ul><li>a) `confirm`</li><li>b) `reject`</li><li>c) Both `confirm` and `reject`</li><li>d) Neither list</li></ul>"
"What does the `found` variable track within the outer loop of the hypothesis testing code?";"Correct: c)";"<b>Explanation:</b> `found` is reset to `False` for each new student `x` from `mathsAGrades`. It is set to `True` only if that specific `x` is found in the `physicsAGrades` list. It tracks the status of the search for the *current* student `x`.<ul><li>a) Whether any student has been confirmed yet.</li><li>b) The total number of confirmed students.</li><li>c) Whether the current student `x` has been found in the `physicsAGrades` list.</li><li>d) Whether the `physicsAGrades` list is empty.</li></ul>"
"Consider the hypothesis: 'Students with a B in Maths get at least a B in Physics'. How would the pseudocode need to be modified?";"Correct: d)";"<b>Explanation:</b> To test this hypothesis, the outer loop would iterate through `mathsBGrades`. The inner logic would need to search for each student in *both* `physicsBGrades` and `physicsAGrades`.<ul><li>a) The outer loop should iterate through `physicsBGrades`.</li><li>b) The inner loop should only check against `physicsBGrades`.</li><li>c) The `confirm` and `reject` lists should be swapped.</li><li>d) The outer loop should be `foreach x in mathsBGrades`, and the inner logic must check against both `physicsAGrades` and `physicsBGrades`.</li></ul>"
"If the `exitloop` statement was removed from the hypothesis testing code, would the logic still be correct?";"Correct: a)";"<b>Explanation:</b> Yes, the logic would still be correct. The `found` flag would still be set to `True` on the first match, and the `if (not(found))` check after the loop would still work correctly. The only difference is that the inner loop would continue searching unnecessarily after a match has already been found, making it less efficient.<ul><li>a) Yes, but it would be less efficient.</li><li>b) No, it would add students to both lists.</li><li>c) No, it would never add students to the `reject` list.</li><li>d) Yes, and it would be more efficient.</li></ul>"
"What is the initial value of the `confirm` list before the loops start in the hypothesis testing code?";"Correct: b)";"<b>Explanation:</b> Line 1 explicitly initializes both `confirm` and `reject` to be empty lists (`[]`). This is necessary to ensure they are clean before any students are added to them.<ul><li>a) Undefined</li><li>b) `[]`</li><li>c) The list of all students.</li><li>d) `False`</li></ul>"
"The hypothesis testing code is an example of what common computational pattern?";"Correct: c)";"<b>Explanation:</b> The code iterates through one list (`mathsAGrades`) and for each element, it searches for a corresponding element in a second list (`physicsAGrades`). This is a classic pattern for finding the intersection or common elements between two sets or lists.<ul><li>a) Sorting</li><li>b) Counting</li><li>c) Finding the intersection of two lists.</li><li>d) Calculating an average.</li></ul>"
"If `mathsAGrades = [101, 102]` and `physicsAGrades = [102, 103]`, what is the final content of the `confirm` list?";"Correct: a)";"<b>Explanation:</b> - **Outer loop (x=101):** 101 is not in `physicsAGrades`. `found` remains `False`. 101 is added to `reject`. - **Outer loop (x=102):** 102 is found in `physicsAGrades`. `found` becomes `True`. 102 is added to `confirm`. The final `confirm` list is `[102]`.<ul><li>a) `[102]`</li><li>b) `[101]`</li><li>c) `[101, 102]`</li><li>d) `[]`</li></ul>"
"In the hypothesis testing code, `x` and `y` represent what type of data?";"Correct: d)";"<b>Explanation:</b> The grade assignment procedures created lists of student IDs. Therefore, `mathsAGrades` and `physicsAGrades` are lists of student IDs, and `x` and `y` hold these IDs during the iteration.<ul><li>a) Student names</li><li>b) Student marks</li><li>c) `[ID, Mark]` pairs</li><li>d) Student IDs</li></ul>"
"What would be the result of the hypothesis testing code if `mathsAGrades` is empty?";"Correct: c)";"<b>Explanation:</b> If `mathsAGrades` is empty, the outer `foreach` loop on line 2 will not execute at all. The procedure will finish, and both `confirm` and `reject` will remain the empty lists they were initialized as.<ul><li>a) An error.</li><li>b) `confirm` will contain all students from `physicsAGrades`.</li><li>c) Both `confirm` and `reject` will be empty.</li><li>d) An infinite loop.</li></ul>"
"The final step of the hypothesis test is to compare `length(confirm)` with `length(confirm) + length(reject)`. What does this ratio represent?";"Correct: b)";"<b>Explanation:</b> `length(confirm)` is the number of students who support the hypothesis. `length(confirm) + length(reject)` is the total number of students tested (all students in `mathsAGrades`). The ratio is the proportion of tested students for whom the hypothesis holds true.<ul><li>a) The total number of students in the class.</li><li>b) The percentage of students with an A in Maths for whom the hypothesis is true.</li><li>c) The number of students who failed Physics.</li><li>d) The average grade difference.</li></ul>"
"How could you modify the hypothesis testing code to find students who are in `mathsAGrades` but *not* in `physicsAGrades`?";"Correct: a)";"<b>Explanation:</b> The `reject` list is specifically designed to collect students for whom the `found` flag remains `False`, meaning they were in `mathsAGrades` but a match was not found in `physicsAGrades`. This is the set difference.<ul><li>a) The `reject` list already contains this result.</li><li>b) Swap the `confirm` and `reject` lists.</li><li>c) The `confirm` list contains this result.</li><li>d) It is not possible with this code structure.</li></ul>"
"If the line `found = False` was moved to before the outer loop (i.e., before line 2), how would it affect the logic?";"Correct: d)";"<b>Explanation:</b> If `found` was not reset for each `x`, then as soon as the first confirming student was found, `found` would become `True` and stay `True` for all subsequent students. This would prevent any more students from being correctly added to the `reject` list, leading to an incorrect result.<ul><li>a) It would have no effect.</li><li>b) It would be more efficient.</li><li>c) It would prevent any student from being added to the `confirm` list.</li><li>d) It would produce an incorrect result for the `reject` list after the first match is found.</li></ul>"
"What is the fundamental comparison being made on line 5 of the hypothesis testing code?";"Correct: c)";"<b>Explanation:</b> The line `if (x == y)` compares the student ID from the Maths A-grade list (`x`) with a student ID from the Physics A-grade list (`y`) to see if they refer to the same student.<ul><li>a) Comparing a student's Maths mark to their Physics mark.</li><li>b) Checking if two lists are identical.</li><li>c) Checking if a student who got an A in Maths is the same student who got an A in Physics.</li><li>d) Comparing the length of the two grade lists.</li></ul>"
"Consider the pseudocode:<br><pre>1. L = []
2. A = ""None""
3. Read the first row X in Table 1
4. A = X.PartOfSpeech
5. Move X to Table 2
6. while (Table 1 has more rows) {
7.   Read the first row X in Table 1
8.   if (X.PartOfSpeech == ""Noun"") {
9.     if (A == ""Adjective"") {
10.      L = L ++ [X.Word]
11.    }
12.  }
13.  A = X.PartOfSpeech
14.  Move X to Table 2
15. }</pre>What does the variable `A` store during the execution of the `while` loop?";"Correct: a)";"<b>Explanation:</b> `A` is updated at the end of each iteration (line 13) with the `PartOfSpeech` of the current row `X`. In the *next* iteration, when a new `X` is read, `A` still holds the value from the *previous* row. This allows the code to compare the current row's type to the previous row's type.<ul><li>a) The PartOfSpeech of the *previous* row.</li><li>b) The PartOfSpeech of the *current* row `X`.</li><li>c) The list of all adjectives.</li><li>d) The current word being processed.</li></ul>"
"In the pseudocode line logic example, why are lines 3-5 necessary before the main `while` loop?";"Correct: b)";"<b>Explanation:</b> The logic inside the loop needs to compare the current word's `PartOfSpeech` with the previous one's. For the very first word processed inside the loop, its 'previous' word is the one read before the loop starts. This is a common pattern to handle the first element of a sequence correctly.<ul><li>a) To initialize the list `L`.</li><li>b) To 'prime' the loop by setting the initial value for `A` based on the very first word in the table.</li><li>c) To check if the table is empty.</li><li>d) To add the first word to the list `L`.</li></ul>"
"What specific condition must be met for a word to be added to the list `L` in the pseudocode line logic example?";"Correct: d)";"<b>Explanation:</b> The code has nested `if` statements. The outer `if` on line 8 checks if the current word `X` is a ""Noun"". The inner `if` on line 9 checks if the *previous* word (whose `PartOfSpeech` is stored in `A`) was an ""Adjective"". Both must be true to add the noun to the list.<ul><li>a) The current word is an adjective.</li><li>b) The previous word was a noun.</li><li>c) The current word is an adjective and the previous word was a noun.</li><li>d) The current word is a noun and the previous word was an adjective.</li></ul>"
"If the ""Words"" table contained the sequence: `(Word: ""big"", PoS: ""Adjective""), (Word: ""cat"", PoS: ""Noun""), (Word: ""ran"", PoS: ""Verb"")`, what would be the final content of `L`?";"Correct: a)";"<b>Explanation:</b> 1. **Before loop:** `A` becomes ""Adjective"". 2. **Loop 1 (X is cat/Noun):** `X` is a Noun. `A` is ""Adjective"". Condition is true. `L` becomes `[""cat""]`. `A` is updated to ""Noun"". 3. **Loop 2 (X is ran/Verb):** `X` is not a Noun. The `if` block is skipped. `A` is updated to ""Verb"". The final list is `[""cat""]`.<ul><li>a) `[""cat""]`</li><li>b) `[""big"", ""cat""]`</li><li>c) `[""ran""]`</li><li>d) `[]`</li></ul>"
"In the pseudocode line logic example, what is the role of line 13: `A = X.PartOfSpeech`?";"Correct: c)";"<b>Explanation:</b> This line is crucial for the logic to work in the *next* iteration. It saves the `PartOfSpeech` of the current word so that when the next word is processed, it can be compared against the one that came immediately before it.<ul><li>a) It adds the PartOfSpeech to the list `L`.</li><li>b) It checks if the current word is an adjective.</li><li>c) It updates the state for the next iteration by saving the current PartOfSpeech.</li><li>d) It resets the variable `A` to ""None"".</li></ul>"
"If line 5 (`Move X to Table 2`) was omitted from the pre-loop setup in the pseudocode line logic example, what would happen?";"Correct: b)";"<b>Explanation:</b> If the first row was not moved after being read, the `while` loop would read it again as its first element. This would result in the first word being processed twice, which is incorrect.<ul><li>a) It would have no effect on the logic.</li><li>b) The first word of the table would be processed twice.</li><li>c) The loop would not execute.</li><li>d) The list `L` would be empty.</li></ul>"
"What kind of logical error would occur in the pseudocode line logic example if line 13 were placed before line 8?";"Correct: d)";"<b>Explanation:</b> If `A` were updated with the current `PartOfSpeech` *before* the check, the `if (A == ""Adjective"")` condition would be checking if the *current* word is an adjective, not the previous one. The logic would fail to identify nouns that follow adjectives.<ul><li>a) A syntax error.</li><li>b) An infinite loop.</li><li>c) The list `L` would contain adjectives instead of nouns.</li><li>d) The comparison would be incorrect, as `A` would hold the current, not the previous, PartOfSpeech.</li></ul>"
"The pseudocode line logic example demonstrates a common technique for processing sequences. What is this technique?";"Correct: a)";"<b>Explanation:</b> The code processes a sequence (words in a table) one element at a time while keeping track of the immediately preceding element to check for a relationship between adjacent elements.<ul><li>a) Examining adjacent elements in a sequence by remembering the previous element.</li><li>b) Sorting a list based on a specific criterion.</li><li>c) Counting the frequency of different items.</li><li>d) Finding the maximum value in a sequence.</li></ul>"
"If the table in the pseudocode line logic example was not sorted by sequence number, would the logic still be correct?";"Correct: b)";"<b>Explanation:</b> The logic relies on processing words in the order they appear in the sentence. If the table is not sorted by sequence number, the notion of a 'previous' word becomes meaningless, and the code would fail to identify adjacent adjective-noun pairs correctly.<ul><li>a) Yes, the logic is independent of the table order.</li><li>b) No, the logic requires the rows to be processed in their natural sequence.</li><li>c) Yes, but it would be less efficient.</li><li>d) It would only work if the table was sorted in reverse order.</li></ul>"
"What is the value of `A` right after line 4 is executed in the pseudocode line logic example?";"Correct: c)";"<b>Explanation:</b> Line 3 reads the first row `X` from the table. Line 4 then assigns the `PartOfSpeech` of that specific first row to the variable `A`.<ul><li>a) ""None""</li><li>b) The first word from the table.</li><li>c) The PartOfSpeech of the first word in the table.</li><li>d) An empty string.</li></ul>"
"If the condition on line 9 of the pseudocode line logic example was changed to `if (A == ""Noun"")`, what would the list `L` contain?";"Correct: a)";"<b>Explanation:</b> The modified code would check if the current word is a noun (line 8) and if the previous word was also a noun (modified line 9). Therefore, it would collect a list of nouns that immediately follow another noun.<ul><li>a) Nouns that immediately follow another noun.</li><li>b) Nouns that immediately follow an adjective.</li><li>c) Adjectives that immediately follow a noun.</li><li>d) It would be empty as a noun cannot follow a noun.</li></ul>"
"In the pseudocode line logic example, the code is looking for a specific two-word pattern. What is it?";"Correct: d)";"<b>Explanation:</b> The code checks if the current word is a noun and the previous word was an adjective. This means it is explicitly searching for the pattern 'Adjective' followed immediately by 'Noun'.<ul><li>a) Noun, Verb</li><li>b) Adjective, Adjective</li><li>c) Noun, Noun</li><li>d) Adjective, Noun</li></ul>"
"What would be the effect on the pseudocode line logic example if the table contained only one row?";"Correct: b)";"<b>Explanation:</b> If there is only one row, lines 1-5 would execute, reading that single row. The `while (Table 1 has more rows)` condition on line 6 would then be false, so the loop would never run. The final list `L` would remain empty.<ul><li>a) An error would occur.</li><li>b) The `while` loop would not execute, and `L` would be empty.</li><li>c) The single word would be added to `L`.</li><li>d) It would enter an infinite loop.</li></ul>"
"The pseudocode line logic example uses a `while` loop to iterate through a table. Which other construct, introduced in this week's lectures, could be used to iterate through a list of words?";"Correct: c)";"<b>Explanation:</b> The `foreach` loop is specifically designed to iterate over each element in a collection like a list, which is a more direct way to handle this if the words were already in a list data structure.<ul><li>a) `if-else`</li><li>b) `return`</li><li>c) `foreach`</li><li>d) `procedure`</li></ul>"
"If line 10 in the pseudocode line logic example was `L = L ++ [A]`, what would the list contain?";"Correct: a)";"<b>Explanation:</b> If the condition on lines 8 and 9 is met, it means the current word is a noun and the previous was an adjective. The modified line 10 would append `A`, which holds the *PartOfSpeech* of the previous word (""Adjective""), to the list `L`, not the word itself. The list would contain a series of the string ""Adjective"".<ul><li>a) A list of the string ""Adjective"".</li><li>b) A list of nouns.</li><li>c) A list of the words that are adjectives.</li><li>d) An error would occur.</li></ul>"
