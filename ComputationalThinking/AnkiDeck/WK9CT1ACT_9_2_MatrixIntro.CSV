"Front";"Back";"Extra"
"Which of the following statements are correct regarding a matrix with 'm' rows and 'n' columns, as described in the lecture?<ul><li>a) It is a two-dimensional table.</li><li>b) It supports random access to its elements.</li><li>c) By convention, its rows and columns are numbered starting from 0.</li><li>d) All of the above.</li></ul>";"Correct: d)";"<b>Explanation:</b> The lecture defines a matrix as a two-dimensional table that supports random access (accessing any element matrix[i][j] takes a constant amount of time). It also explicitly states the convention of numbering rows from 0 to m-1 and columns from 0 to n-1.<br><b>Distractor Rationale:</b><ul><li>a) This is correct, but not the most complete answer.</li><li>b) This is correct, but not the most complete answer.</li><li>c) This is correct, but not the most complete answer.</li></ul>"
"For a matrix with 'm' rows and 'n' columns, represented as matrix[i][j], which of the following correctly defines the valid range for indices 'i' and 'j'?<ul><li>a) 0 ≤ i < m and 0 ≤ j < n</li><li>b) 1 ≤ i ≤ m and 1 ≤ j ≤ n</li><li>c) 0 ≤ i ≤ m and 0 ≤ j ≤ n</li><li>d) 0 ≤ i < m-1 and 0 ≤ j < n-1</li></ul>";"Correct: a)";"<b>Explanation:</b> The lecture follows the standard computing convention where collections are 0-indexed. For 'm' rows, the indices are 0, 1, ..., m-1, which is captured by 0 ≤ i < m. Similarly, for 'n' columns, the indices are 0, 1, ..., n-1, captured by 0 ≤ j < n.<br><b>Distractor Rationale:</b><ul><li>b) This represents 1-based indexing, which is common in mathematics but not in the context of this lecture's pseudocode.</li><li>c) This would imply 'm+1' rows and 'n+1' columns, which is incorrect.</li><li>d) This incorrectly excludes the last row (m-1) and the last column (n-1).</li></ul>"
"In the CreateMatrix procedure shown in the lecture, what is the default initial value assigned to each element mat[i][j]?<ul><li>a) 1</li><li>b) An empty dictionary {}</li><li>c) null</li><li>d) 0</li></ul>";"Correct: d)";"<b>Explanation:</b> The pseudocode for CreateMatrix contains the line mat[i][j] = 0 within its inner loop. This explicitly initializes every element of the newly created matrix to the value 0.<br><b>Distractor Rationale:</b><ul><li>a) The value is explicitly set to 0, not 1.</li><li>b) An empty dictionary is created for each row (mat[i] = {}), but not for each individual element.</li><li>c) The value is explicitly set to 0, not null.</li></ul>"
"Consider the following pseudocode:<br><pre>Procedure sumMatrix(M)
Sum = 0
foreach c in columns(M) {
foreach r in rows(M) {
if (c == r) {
Sum = Sum + M[r][c]
}
}
}
return(Sum)
End sumMatrix</pre>What does the variable Sum represent upon the procedure's completion?<ul><li>a) The summation of all elements in matrix M.</li><li>b) The summation of the principal diagonal elements of matrix M.</li><li>c) The summation of the anti-diagonal elements of matrix M.</li><li>d) The summation of the first row's elements.</li></ul>";"Correct: b)";"<b>Explanation:</b> The procedure iterates through all elements but only adds an element M[r][c] to Sum when the condition c == r (column index equals row index) is true. This condition is only met for elements on the principal diagonal (e.g., M[0][0], M[1][1], M[2][2]).<br><b>Distractor Rationale:</b><ul><li>a) To sum all elements, the if (c == r) condition would need to be removed.</li><li>c) The anti-diagonal would require a condition like r + c == n - 1, where n is the size of the matrix.</li><li>d) This would require a condition like r == 0.</li></ul>"
"In the sumMatrix pseudocode, if the if block were modified as follows:<br><pre>if (c > r) {
M[r][c] = 0
}</pre>What type of matrix would M become?<ul><li>a) An upper triangular matrix.</li><li>b) A lower triangular matrix.</li><li>c) A diagonal matrix.</li><li>d) An identity matrix.</li></ul>";"Correct: b)";"<b>Explanation:</b> The condition c > r identifies all elements where the column index is greater than the row index. These are precisely the elements located in the upper triangle of the matrix (above the main diagonal). Setting them to 0 leaves only the main diagonal and the lower triangle with their original values, thus forming a lower triangular matrix.<br><b>Distractor Rationale:</b><ul><li>a) An upper triangular matrix would be formed if the condition was r > c, setting the lower triangle elements to 0.</li><li>c) A diagonal matrix would require setting both the upper and lower triangles to 0 (r != c).</li><li>d) An identity matrix is a diagonal matrix with all diagonal elements being 1. This procedure only sets values to 0.</li></ul>"
"In the original sumMatrix pseudocode, what would be the effect of adding an exitloop statement inside the if block, immediately after Sum = Sum + M[r][c]?<ul><li>a) It will give the same value of Sum and reduce computing time.</li><li>b) It will give a different value of Sum.</li><li>c) It will give the same value of Sum but take more computing time.</li><li>d) It will cause a syntax error.</li></ul>";"Correct: a)";"<b>Explanation:</b> The if (c == r) condition is true only once for each iteration of the outer loop (the foreach c loop). Once the diagonal element for a given column c is found and added, the exitloop will terminate the inner foreach r loop. The outer loop will then proceed to the next column. Since there's only one element to find per inner loop, exiting early doesn't change the final sum but avoids unnecessary iterations, thus reducing computation time.<br><b>Distractor Rationale:</b><ul><li>b) The final sum will be identical because the loop is only exited after the required value has been added.</li><li>c) The computation time is reduced, not increased, by avoiding redundant checks.</li><li>d) exitloop is a valid construct in the context of the lecture's pseudocode.</li></ul>"
"Why is a nested dictionary a suitable data structure for implementing a matrix as discussed in the lecture?<ul><li>a) Because dictionaries store values in a sorted sequence.</li><li>b) Because the outer dictionary's keys can represent rows and the inner dictionary's keys can represent columns, providing two-dimensional random access.</li><li>c) Because dictionaries are the only way to store numerical data.</li><li>d) Because dictionaries prevent any modification to their values once created.</li></ul>";"Correct: b)";"<b>Explanation:</b> The lecture explains that a matrix can be implemented as a dictionary of dictionaries. matrix[i] accesses the outer dictionary to get the dictionary for row 'i'. Then, [j] accesses the inner dictionary to get the element at column 'j'. This structure naturally mimics the [row][column] access pattern and leverages the dictionary's random access capability.<br><b>Distractor Rationale:</b><ul><li>a) Dictionaries do not store keys or values in a guaranteed sorted order; a sort() procedure is needed for that.</li><li>c) Lists and other data structures can also store numerical data.</li><li>d) Dictionary values are mutable.</li></ul>"
"What is the primary purpose of the helper functions rows(M) and columns(M) as defined in the lecture?<ul><li>a) To count the total number of elements in the matrix M.</li><li>b) To return the list of row and column indices in a guaranteed ascending order for systematic processing.</li><li>c) To delete a specified row or column from the matrix M.</li><li>d) To return the raw, unsorted keys of the underlying dictionaries.</li></ul>";"Correct: b)";"<b>Explanation:</b> The lecture states that keys(d) produces a list in an arbitrary order. To ensure matrices are processed systematically (e.g., from row 0 to the last row), the rows() and columns() functions are introduced as shorthands for sort(keys(M)) and sort(keys(M[0])) respectively. This improves readability and guarantees order.<br><b>Distractor Rationale:</b><ul><li>a) The number of rows is length(rows(M)), but the function's primary purpose is to provide the ordered list of indices itself.</li><li>c) These are for iteration, not modification.</li><li>d) Their purpose is specifically to avoid the arbitrary order of raw keys by sorting them.</li></ul>"
"How is a directed edge from a student 'i' to a student 'j' represented in a mentoring graph matrix M?<ul><li>a) M[i][j] is set to 0 and M[j][i] is set to 1.</li><li>b) Both M[i][j] and M[j][i] are set to 1.</li><li>c) M[i][j] is set to 1.</li><li>d) The entire row i is set to 1.</li></ul>";"Correct: c)";"<b>Explanation:</b> The convention described is that M[i][j] = 1 represents a relationship from 'i' to 'j'. For a directed graph like the mentoring graph, this single entry is sufficient. M[j][i] = 1 would represent an edge in the opposite direction, from 'j' to 'i'.<br><b>Distractor Rationale:</b><ul><li>a) This incorrectly represents the relationship. M[i][j] = 0 would mean no edge from i to j.</li><li>b) This would represent an undirected edge, or two separate directed edges, one in each direction.</li><li>d) This would incorrectly imply that student 'i' has an edge to every other student.</li></ul>"
"In the CreateMentorGraph procedure, an edge is created from student i to student j if marks[i] - marks[j] is between 10 and 20. Why does this result in a directed graph?<ul><li>a) Because the procedure uses a matrix, and all matrices represent directed graphs.</li><li>b) Because if marks[i] is greater than marks[j], it is impossible for marks[j] to also be greater than marks[i].</li><li>c) Because the graph can only have a maximum of 20 edges.</li><li>d) Because the marks are stored in a dictionary.</li></ul>";"Correct: b)";"<b>Explanation:</b> The condition for an edge from i to j requires marks[i] > marks[j]. The condition for an edge from j to i would require marks[j] > marks[i]. These two conditions are mutually exclusive for any given pair of students in a single subject. Therefore, an edge can exist in one direction at most, which is the definition of a directed graph.<br><b>Distractor Rationale:</b><ul><li>a) Matrices can represent both directed and undirected graphs. An undirected graph would have a symmetric matrix where M[i][j] == M[j][i].</li><li>c) The number of edges is not what determines if a graph is directed.</li><li>d) The storage mechanism does not determine the graph's properties.</li></ul>"
"Consider the procedure to find popular students, which aims to avoid duplicate mentor counts. If student j can be mentored by student i in both Maths and Physics, how does the improved pseudocode ensure student i is only counted once as a mentor for j?<ul><li>a) It stores the mentors for j as keys in a nested dictionary, and a key can only exist once.</li><li>b) It subtracts 1 from the popularity count every time a duplicate is found.</li><li>c) It only checks the Maths graph and ignores Physics and Chemistry.</li><li>d) It stores mentors in a list and sorts it to remove duplicates.</li></ul>";"Correct: a)";"<b>Explanation:</b> The improved procedure uses a nested dictionary mentors[j]. When it finds that i can mentor j, it executes mentors[j][i] = True. Even if this line is executed again for a different subject, it only reassigns the value to the same key i within the mentors[j] dictionary. The number of unique mentors is then found by length(keys(mentors[j])), which correctly counts the unique keys.<br><b>Distractor Rationale:</b><ul><li>b) The code does not contain logic for subtracting counts.</li><li>c) The code explicitly iterates through all three subject graphs.</li><li>d) While sorting could be part of a de-duplication strategy, the lecture's pseudocode uses the inherent uniqueness of dictionary keys, which is more direct.</li></ul>"
"When creating a similarity graph, an undirected edge is created between students i and j if their mark difference is within 10 for all subjects. How is this represented in the similarityGraph matrix M?<ul><li>a) M[i][j] is set to 1, and M[j][i] is set to 0.</li><li>b) The procedure sets M[i][j] = 1, and a separate loop sets M[j][i] = 1.</li><li>c) The check for i and j will set M[i][j] = 1. Later, the check for j and i will naturally set M[j][i] = 1.</li><li>d) A special value of -1 is used for undirected edges.</li></ul>";"Correct: c)";"<b>Explanation:</b> The condition for similarity is symmetric: if the absolute difference of marks between i and j is within the threshold, the absolute difference between j and i is identical. The procedure iterates through all pairs. When it processes (i, j), it sets M[i][j] = 1. When it later processes the pair (j, i), the same condition will be met, and it will set M[j][i] = 1, resulting in a symmetric matrix that correctly represents an undirected graph.<br><b>Distractor Rationale:</b><ul><li>a) This would represent a directed edge.</li><li>b) There is no separate loop; the symmetry arises naturally from the single nested loop structure that checks all pairs.</li><li>d) The lecture uses only 0 and 1 to represent the absence or presence of an edge.</li></ul>"
"In the CreateMatrix(rows, cols) procedure, what is the purpose of the outer loop while (i < rows)?<ul><li>a) To initialize each individual element mat[i][j] to 0.</li><li>b) To iterate through each column of the matrix.</li><li>c) To create an empty dictionary mat[i] = {} for each row.</li><li>d) To return the final matrix.</li></ul>";"Correct: c)";"<b>Explanation:</b> The outer loop, controlled by the row index i, is responsible for processing each row. The first action inside this loop is mat[i] = {}, which creates the nested dictionary that will hold all the elements for that specific row.<br><b>Distractor Rationale:</b><ul><li>a) Initializing individual elements is the job of the inner loop (while (j < cols)).</li><li>b) Iterating through columns is the job of the inner loop.</li><li>d) The return statement is outside of all loops.</li></ul>"
"If you wanted to modify the sumMatrix procedure to sum the elements of the anti-diagonal (from top-right to bottom-left), what would the if condition be for a square matrix M of size n x n?<ul><li>a) if (c + r == n)</li><li>b) if (c + r == n - 1)</li><li>c) if (c == n - r)</li><li>d) if (r > c)</li></ul>";"Correct: b)";"<b>Explanation:</b> For a 0-indexed n x n matrix, the anti-diagonal elements are those where the sum of the row and column index is n-1. For example, in a 3x3 matrix (n=3), the anti-diagonal elements are M[0][2], M[1][1], and M[2][0]. In all cases, r + c = 2, which is n-1.<br><b>Distractor Rationale:</b><ul><li>a) This would be incorrect for a 0-indexed matrix. For a 3x3 matrix, this would look for r+c=3, which includes elements like M[1][2] and M[2][1], which are not on the anti-diagonal.</li><li>c) This is equivalent to c + r == n, which is incorrect.</li><li>d) This condition selects all elements in the lower triangle of the matrix.</li></ul>"
"Which of the following describes column-wise processing of a matrix?<ul><li>a) foreach r in rows(M) { foreach c in columns(M) { ... } }</li><li>b) foreach c in columns(M) { foreach r in rows(M) { ... } }</li><li>c) foreach r in rows(M) { ... }</li><li>d) foreach c in columns(M) { ... }</li></ul>";"Correct: b)";"<b>Explanation:</b> Column-wise processing means fixing a column and then iterating through all the rows within that column, before moving to the next column. The pseudocode foreach c in columns(M) { foreach r in rows(M) { ... } } perfectly represents this, as the outer loop iterates through columns and the inner loop iterates through rows.<br><b>Distractor Rationale:</b><ul><li>a) This represents row-wise processing, where the outer loop iterates through rows.</li><li>c) This only iterates through the rows, not the elements within them.</li><li>d) This only iterates through the columns, not the elements within them.</li></ul>"
"In the context of the student dataset, if CreateMentorGraph is called on the Physics marks, and mentorGraph[5][12] is 1, what does this signify?<ul><li>a) Student 12 can mentor student 5 in Physics.</li><li>b) Student 5 and student 12 have identical marks in Physics.</li><li>c) The difference in Physics marks between student 5 and student 12 is less than 10.</li><li>d) Student 5 can mentor student 12 in Physics.</li></ul>";"Correct: d)";"<b>Explanation:</b> The matrix representation M[i][j] = 1 indicates an edge from i to j. In this case, mentorGraph[5][12] = 1 means there is a mentoring edge from student 5 to student 12. This implies that student 5's Physics marks are 10 to 20 points higher than student 12's.<br><b>Distractor Rationale:</b><ul><li>a) This would be represented by mentorGraph[12][5] = 1.</li><li>b) This would result in a mark difference of 0, so no edge would be created.</li><li>c) A difference of less than 10 would not meet the condition for a mentoring edge.</li></ul>"
"If a similarityGraph matrix is symmetric (i.e., M[i][j] == M[j][i] for all i,j), what does this imply about the graph it represents?<ul><li>a) The graph is directed.</li><li>b) The graph has no edges.</li><li>c) The graph is undirected.</li><li>d) The graph is a single cycle.</li></ul>";"Correct: c)";"<b>Explanation:</b> A symmetric matrix means that if there is an edge from i to j, there is always an edge from j to i. This is the definition of an undirected graph, where relationships are mutual.<br><b>Distractor Rationale:</b><ul><li>a) A directed graph may have edges in one direction but not the other, resulting in an asymmetric matrix.</li><li>b) A graph with no edges would be a matrix of all zeros, which is technically symmetric, but symmetry itself doesn't imply no edges.</li><li>d) A cycle is a specific pattern within a graph; symmetry describes a property of all its edges, not a specific structure.</li></ul>"
"To find study pairs, the pseudocode checks if mathMentorGraph[i][j] == 1 and phyMentorGraph[j][i] == 1. What does this condition identify?<ul><li>a) Two students who can both mentor each other in both subjects.</li><li>b) A pair where student i can mentor student j in Maths, and student j can mentor student i in Physics.</li><li>c) A pair where student i can mentor student j in both Maths and Physics.</li><li>d) Two students who are not compatible for a study group.</li></ul>";"Correct: b)";"<b>Explanation:</b> mathMentorGraph[i][j] == 1 means there is an edge from i to j in the Maths graph (i can mentor j). phyMentorGraph[j][i] == 1 means there is an edge from j to i in the Physics graph (j can mentor i). The condition finds pairs with this reciprocal mentoring relationship across two different subjects.<br><b>Distractor Rationale:</b><ul><li>a) This would require four conditions to be met: mathMentorGraph[i][j], mathMentorGraph[j][i], phyMentorGraph[i][j], and phyMentorGraph[j][i].</li><li>c) This would be mathMentorGraph[i][j] == 1 and phyMentorGraph[i][j] == 1.</li><li>d) This condition is specifically designed to find compatible pairs.</li></ul>"