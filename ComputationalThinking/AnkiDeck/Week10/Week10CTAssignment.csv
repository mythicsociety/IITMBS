"Front";"Back";"Extra"
"Given the following pseudocode executing on a ""Scores"" table:<br>1 D = {}<br>2 while (Table 1 has more rows) {<br>3   Read the first row X in Table 1<br>4   D[X.SeqNo] = {""P"": X.Physics, ""C"": X.Chemistry, ""M"": X.Mathematics}<br>5   Move X to Table 2<br>6 }<br>7 <br>8 matrixPh = getAdjMatrix(D, ""P"")<br>9 matrixCh = getAdjMatrix(D, ""C"")<br>10 matrixMa = getAdjMatrix(D, ""M"")<br>11 <br>12 Procedure getAdjMatrix(D, Subject)<br>13   n = length(keys(D))<br>14   matrix = createMatrix(n, n)<br>15   foreach i in rows(matrix) {<br>16     foreach j in columns(matrix) {<br>17       if (i != j) {<br>18         diff = D[i][Subject] - D[j][Subject]<br>19         if (10 <= diff and diff <= 20) {<br>20           matrix[i][j] = 1<br>21         }<br>22       }<br>23     }<br>24   }<br>25   return(matrix)<br>26 End getAdjMatrix<br><br>If matrixPh[i][j] = 1, then:<ul><li>a) i scored at most 10 and at least 20 more marks in Physics than j</li><li>b) i scored at least 10 and at most 20 more marks in Physics than j</li><li>c) j scored at least 10 and at most 20 more marks in Physics than i</li><li>d) j scored at most 10 and at least 20 more marks in Physics than i</li></ul>";"Correct: b)";"<b>Explanation:</b> The condition if (10 <= diff and diff <= 20) where diff = D[i][Subject] - D[j][Subject] directly translates to student i's score being between 10 and 20 points higher than student j's score in the given subject.<br><b>Distractor Rationale:</b><ul><li>a) This inverts the logic of 'at least' and 'at most'.</li><li>c) This reverses the roles of i and j. If this were true, diff would be negative.</li><li>d) This reverses the roles of i and j and inverts the logic.</li></ul>"
"Based on the pseudocode from the previous question, which of the following statements is correct for the generated matrixPh?<ul><li>a) For all i, j with i != j, matrixPh[i][j] + matrixPh[j][i] = 1</li><li>b) For all i, j with i != j, if matrixPh[i][j] = 1 then matrixPh[j][i] = 0</li><li>c) For all i, j with i != j, if matrixPh[i][j] = 0 then matrixPh[j][i] = 1</li><li>d) For all i, j with i != j, if matrixPh[i][j] = 1 then matrixPh[j][i] = 1</li></ul>";"Correct: b)";"<b>Explanation:</b> If matrixPh[i][j] = 1, it means D[i]['P'] - D[j]['P'] is between 10 and 20. For matrixPh[j][i] to be 1, D[j]['P'] - D[i]['P'] would also need to be between 10 and 20. This is impossible, as if the first condition is true, the second expression must be negative (between -20 and -10). Therefore, if one is 1, the other must be 0. This describes an asymmetric relationship.<br><b>Distractor Rationale:</b><ul><li>a) This would imply that for any pair (i, j), exactly one of the directed edges exists. This is not guaranteed; it's possible neither score difference falls in the 10-20 range, so both could be 0.</li><li>c) This is the converse of (a) and is also not guaranteed. Both could be 0.</li><li>d) This would imply a symmetric relationship, which we have shown is not the case.</li></ul>"
"Consider the dictionary D and matrices from the previous questions. The following pseudocode generates a new matrix matrixHelp.<br>1 n = length(keys(D))<br>2 matrixHelp = createMatrix(n, n)<br>3 foreach i in rows(matrixHelp) {<br>4   foreach j in columns(matrixHelp) {<br>5     matrixHelp[i][j] = matrixCh[i][j] + matrixPh[i][j] + matrixMa[i][j]<br>6   }<br>7 }<br><br>Let i and j be indices of two students. Select all that apply.<ul><li>a) 0 <= matrixHelp[i][j] <= 3</li><li>b) matrixHelp[i][j] + matrixHelp[j][i] <= 3</li><li>c) matrixHelp[i][j] != matrixHelp[j][i]</li><li>d) if matrixHelp[i][j] = 3, then matrixHelp[j][i] = 0</li></ul>";"Correct: a), b), d)";"<b>Explanation:</b> matrixHelp[i][j] is the sum of three 0/1 values, so it must be between 0 and 3 (a). If student i helps student j in a subject, j cannot help i in the same subject. Therefore, the total number of help relationships between the two is the sum matrixHelp[i][j] + matrixHelp[j][i], which cannot exceed 3 (b). If matrixHelp[i][j] = 3, i helps j in all subjects, making it impossible for j to help i in any, so matrixHelp[j][i] must be 0 (d).<br><b>Distractor Rationale:</b><ul><li>c) It's possible that neither student can help the other in any subject, making both entries 0. In this case, they would be equal.</li></ul>"
"At the end of the following pseudocode, A captures the number of distinct pairs of students where there is any helping relationship, and B captures the number of distinct pairs where one student helps the other in all subjects. Choose the correct code fragment to complete the pseudocode.<br>1 A = 0, B = 0<br>2 foreach i in rows(matrixHelp) {<br>3   foreach j in columns(matrixHelp) {<br>4     if(i < j) {<br>5        *** Fill the code ***<br>6     }<br>7   }<br>8 }<ul><li>a) if(matrixHelp[i][j] > 0 and matrixHelp[j][i] > 0) { A = A + 1 }<br>if(matrixHelp[i][j] == 3) { B = B + 1 }</li><li>b) if(matrixHelp[i][j] > 0 or matrixHelp[j][i] > 0) { A = A + 1 }<br>if(matrixHelp[i][j] == 3 or matrixHelp[j][i] == 3) { B = B + 1 }</li><li>c) if(matrixHelp[i][j] > 0) { A = A + 1 }<br>if(matrixHelp[i][j] > 2) { B = B + 1 }</li><li>d) if(matrixHelp[i][j] > 0 and matrixHelp[j][i] > 0) { A = A + 1 }<br>if(matrixHelp[i][j] > 2 or matrixHelp[j][i] > 2) { B = B + 1 }</li></ul>";"Correct: b)";"<b>Explanation:</b> To count distinct pairs, the if(i < j) condition is essential. 'A' should count pairs with at least one helping relationship, which means matrixHelp[i][j] > 0 OR matrixHelp[j][i] > 0. 'B' should count pairs where one student helps the other in all three subjects, meaning matrixHelp[i][j] == 3 OR matrixHelp[j][i] == 3. Option (b) correctly implements this logic inside the i < j block.<br><b>Distractor Rationale:</b><ul><li>a) This uses 'and' for A, only counting pairs with mutual help. It also only checks one direction for B.</li><li>c) This only checks for help in one direction (i to j) for both A and B, undercounting the total.</li><li>d) This uses 'and' for A, only counting mutual help.</li></ul>"
"The following pseudocode generates a graph G from a dictionary books. There is an edge between two authors if they co-authored a book. What is the correct code fragment to build a symmetric adjacency matrix where the edge value is the number of co-authored books?<br>1 matrix = createMatrix(n, n)<br>2 foreach i in keys(books) {<br>3   foreach j in books[i] {<br>4     foreach k in books[i] {<br>5       *** Fill the code ***<br>6     }<br>7   }<br>8 }<ul><li>a) matrix[j][k] = matrix[j][k] + 1</li><li>b) if(j != k) {<br>  matrix[j][k] = matrix[j][k] + 1<br>}</li><li>c) if(j < k) {<br>  matrix[j][k] = matrix[j][k] + 1<br>  matrix[k][j] = matrix[k][j] + 1<br>}</li><li>d) if(j != k) {<br>  matrix[j][k] = 1<br>}</li></ul>";"Correct: c)";"<b>Explanation:</b> The goal is to create a symmetric matrix representing an undirected graph. The loops iterate through all pairs of authors (j, k) for a given book. The if(j < k) condition is the standard way to process each unique pair of authors exactly once, preventing both self-loops (j,j) and double-counting (processing both (j,k) and (k,j)). For each valid pair, we increment the count for both matrix[j][k] and matrix[k][j] to maintain the matrix's symmetry.<br><b>Distractor Rationale:</b><ul><li>a) This would incorrectly increment self-loops and would double-count the relationship for each book.</li><li>b) This correctly avoids self-loops but still double-counts the relationship for each book by processing both (j,k) and (k,j).</li><li>d) This would only set the value to 1, failing to count the number of co-authored books.</li></ul>"
"Given the books dictionary, what does matrix2[j][k] represent after this pseudocode executes?<br>1 matrix2 = createMatrix(n, n)<br>2 foreach j in rows(matrix2){<br>3   foreach k in columns(matrix2){<br>4     matrix2[j][k] = []<br>5   }<br>6 }<br>7 foreach i in keys(books) {<br>8   foreach j in books[i] {<br>9     foreach k in books[i] {<br>10      foreach h in books[i] {<br>11        if(j != k and j != h and k != h and not member(matrix2[j][k], h)) {<br>12          matrix2[j][k] = matrix2[j][k] + [h]<br>13          matrix2[k][j] = matrix2[k][j] + [h]<br>14        }<br>15      }<br>16    }<br>17  }<br>18 }<ul><li>a) List of authors who are common co-authors for the author pair (j, k).</li><li>b) List of books co-authored by the pair (j, k).</li><li>c) List of all authors in the dataset.</li><li>d) List of authors who co-authored a book with j but not k.</li></ul>";"Correct: a)";"<b>Explanation:</b> The code iterates through every book (i). For each book, it considers every unique triplet of authors (j, k, h). The if condition ensures that j, k, and h are distinct authors within the same book. If they are, it means h is a common co-author to both j and k on that book. The code then adds h to the list at matrix2[j][k]. By iterating through all books, it accumulates a list of all such common co-authors for every pair (j,k).<br><b>Distractor Rationale:</b><ul><li>b) The code adds author IDs (h), not book IDs (i), to the list.</li><li>c) The list is specific to the pair (j,k), not all authors.</li><li>d) The condition j != h and k != h ensures h is a co-author with both j and k in the context of the current book i.</li></ul>"
"Which of the following combinations of entries in matrix (co-authorship count) and matrix2 (common co-authors list) is possible for two different authors i and j? Select all that apply.<ul><li>a) matrix[i][j] = 0 and matrix2[i][j] = []</li><li>b) matrix[i][j] = 0 and matrix2[i][j] != []</li><li>c) matrix[i][j] > 0 and matrix2[i][j] = []</li><li>d) matrix[i][j] > 0 and matrix2[i][j] != []</li></ul>";"Correct: a), c), d)";"<b>Explanation:</b> If matrix[i][j] > 0, authors i and j have co-authored a book. If that book had only two authors (i and j), then matrix2[i][j] would be empty. If the book had a third author, h, then matrix2[i][j] would not be empty. If matrix[i][j] = 0, i and j have never co-authored a book, which means there can be no common third author h on a book they wrote together. Therefore, matrix2[i][j] must be empty.<br><b>Distractor Rationale:</b><ul><li>b) This is impossible. For matrix2[i][j] to be non-empty, there must be a third author h on a book that i and j co-authored. This would imply matrix[i][j] must be greater than 0.</li></ul>"
"The procedure findAuthor(matrix) should find an author who has the maximum number of co-authors. Choose the correct implementation(s). Select all that apply.<br><ul><li>a) 1 Procedure findAuthor(M)<br>2   Max = 0<br>3   A = 0<br>4   foreach i in rows(M) {<br>5     Sum = 0<br>6     foreach j in columns(M) {<br>7       if(M[i][j] > 0) {<br>8         Sum = Sum + 1<br>9       }<br>10    }<br>11    if(Sum > Max) {<br>12      Max = Sum<br>13      A = i<br>14    }<br>15  }<br>16  return(A)<br>17 End findAuthor</li><li>b) 1 Procedure findAuthor(M)<br>2   Max = 0<br>3   A = 0<br>4   foreach i in rows(M) {<br>5     Sum = 0<br>6     foreach j in columns(M) {<br>7       if(M[i][j] > 0) {<br>8         Sum = Sum + M[i][j]<br>9       }<br>10    }<br>11    if(Sum > Max) {<br>12      Max = Sum<br>13      A = i<br>14    }<br>15  }<br>16  return(A)<br>17 End findAuthor</li><li>c) 1 Procedure findAuthor(M)<br>2   Max = 0<br>3   A = 0<br>4   foreach i in columns(M) {<br>5     Sum = 0<br>6     foreach j in rows(M) {<br>7       if(M[j][i] > 0) {<br>8         Sum = Sum + 1<br>9       }<br>10    }<br>11    if(Sum > Max) {<br>12      Max = Sum<br>13      A = i<br>14    }<br>15  }<br>16  return(A)<br>17 End findAuthor</li></ul>";"Correct: a), c)";"<b>Explanation:</b> The goal is to count the number of distinct co-authors for each author i. This corresponds to the number of non-zero entries in row i (or column i, since the matrix is symmetric). Both (a) and (c) correctly iterate through authors and for each one, count the number of other authors j for whom M[i][j] (or M[j][i]) is greater than 0, effectively counting co-authors. They then keep track of the author with the maximum count.<br><b>Distractor Rationale:</b><ul><li>b) This procedure calculates Sum = Sum + M[i][j]. This sums the total number of co-authored books across all co-authors, not the number of distinct co-authors. An author who wrote 10 books with one person would rank higher than an author who wrote 1 book with 9 different people.</li></ul>"
"The following pseudocode uses a ""Shopping bills"" dataset. D is a dictionary mapping a customer index to a list of shops they visited. matrix[i][j] becomes a list of common shops visited by customers i and j. When will findGoodSet(matrix) return True?<br>1 Procedure findGoodSet(M)<br>2   foreach i in rows(M) {<br>3     foreach j in columns(M) {<br>4       foreach h in rows(M) {<br>5         list1 = []<br>6         if(length(M[i][j]) == 1 and member(D[h], first(M[i][j]))) {<br>7           list1 = list1 + M[i][j]<br>8         }<br>9         if(length(M[i][h]) == 1 and member(D[j], first(M[i][h]))) {<br>10          list1 = list1 + M[i][h]<br>11        }<br>12        if(length(M[j][h]) == 1 and member(D[i], first(M[j][h]))) {<br>13          list1 = list1 + M[j][h]<br>14        }<br>15        list1 = removeDuplicate(list1)<br>16        if(length(list1) == 1) {<br>17          return(True)<br>18        }<br>19      }<br>20    }<br>21  }<br>22  return(False)<br>23 End findGoodSet<ul><li>a) If there exist three customers who have visited all three shops.</li><li>b) If there exist three customers such that every pair of customers among them have visited only one and the same shop in common.</li><li>c) If there exist three customers who have visited exactly one shop.</li><li>d) If there exists three customers where each pair among them have visited exactly one different shop in common.</li></ul>";"Correct: b)";"<b>Explanation:</b> The procedure iterates through all triplets of customers (i, j, h). The first if checks if i and j have exactly one shop in common, AND customer h also visited that shop. The next two ifs do the same for pairs (i,h) and (j,h). list1 collects these common shops. The code returns True if, after removing duplicates, list1 has a length of 1. This means the single common shop for (i,j) is the same as the single common shop for (i,h) and the same as the single common shop for (j,h).<br><b>Distractor Rationale:</b><ul><li>a) This describes a different condition. The code checks for a single common shop between pairs, not that all three visited the same set of shops.</li><li>c) This is about the total shops visited by a customer, not the common shops between pairs.</li><li>d) This would result in length(list1) being 3 (or 2 if two pairs shared a common shop), not 1.</li></ul>"
"For a pair of customers i and j, j is a 'shopping partner' of i if they have visited at least two shops in common. findTopCustomer(matrix) should find a customer with the maximum number of shopping partners. Choose the correct implementation.<ul><li>a) 1 Procedure findTopCustomer(M)<br>2   Max=0, A=0<br>3   foreach i in rows(M){<br>4     c=0<br>5     foreach j in columns(M) {<br>6       if(length(M[i][j]) == 2) { c = c + 1 }<br>7     }<br>8     if(c > Max){ Max = c; A = i }<br>9   }<br>10  return(A)</li><li>b) 1 Procedure findTopCustomer(M)<br>2   Max=0, A=0<br>3   foreach i in rows(M) {<br>4     c=0<br>5     foreach j in columns(M) {<br>6       if(length(M[i][j]) > 1) { c = c + 1 }<br>7     }<br>8     if(c > Max){ Max = c; A = i }<br>9   }<br>10  return(A)</li><li>c) 1 Procedure findTopCustomer(M)<br>2   Max=0, A=0<br>3   foreach i in rows(M) {<br>4     c=0<br>5     foreach j in columns(M) {<br>6       if(length(M[i][j]) >= 2) { c = c + 1 }<br>7     }<br>8     if(c > Max){ Max = c; A = i }<br>9   }<br>10  return(A)</li><li>d) Both b) and c) are correct.</li></ul>";"Correct: d)";"<b>Explanation:</b> The definition of a shopping partner is having visited 'at least two' shops in common. For integer lengths, the conditions length > 1 and length >= 2 are logically equivalent. Both procedures (b) and (c) correctly implement this logic. They iterate through all potential partners j for a customer i, count how many meet the criterion, and keep track of the customer i with the maximum count.<br><b>Distractor Rationale:</b><ul><li>a) This uses == 2, which only counts partners with exactly two common shops, not 'at least two'.</li></ul>"
"Consider a condensed ""Trains"" dataset where each row is a direct train trip. The pseudocode builds a matrix A where A[r][c] is a dictionary, and A[i][j][t] = d means train t travels distance d directly from station i to j. Which statements about A[i][j] are true? Select all that apply.<ul><li>a) Each key corresponds to a train that goes from station i to j without stopping at any intermediate station.</li><li>b) Each key corresponds to a train that goes from station i to j, potentially stopping at intermediate stations.</li><li>c) The value for key t is the distance between stations i and j on t's route for that specific direct segment.</li><li>d) The value for key t is the minimum distance between stations i and j across all possible trains.</li></ul>";"Correct: a), c)";"<b>Explanation:</b> The pseudocode reads rows representing direct, non-stop travel between two stations and populates the matrix. Line 24 in the source, A[r][c][t] = d, directly maps the train t to the distance d for the direct segment from station r (departure) to c (arrival). Therefore, keys are trains on direct routes, and values are their corresponding distances for that segment.<br><b>Distractor Rationale:</b><ul><li>b) The problem statement and code logic are based on a condensed dataset where each entry is a direct, non-stop segment.</li><li>d) The code assigns the distance d from the table directly; it doesn't calculate a minimum across different trains, it just stores the distance for each specific train t.</li></ul>"
"Given the matrix A from the previous question, what does the value length(keys(A[i][j])) represent?<ul><li>a) The number of trains from i to j that stop at at least one intermediate station.</li><li>b) The number of trains from i to j without stopping at any intermediate station.</li><li>c) The number of trains from j to i without stopping at any intermediate station.</li><li>d) The number of trains from i to j that stop at at most one intermediate station.</li></ul>";"Correct: b)";"<b>Explanation:</b> A[i][j] is a dictionary where each key is a unique train number for a direct train from station i to station j. The function length(keys(...)) counts the number of such keys, which directly corresponds to the number of direct trains on that route.<br><b>Distractor Rationale:</b><ul><li>a) The data represents direct routes only.</li><li>c) This represents the reverse direction, which would be length(keys(A[j][i])).</li><li>d) The data represents direct routes only.</li></ul>"
"The procedure ijMin is intended to find the train with the least distance from station i to j. The original pseudocode in the benchmark file had errors. Which of the following describe necessary corrections? Select all that apply.<br>1 Procedure ijMin(i, j, A)<br>2   if (length(keys(A[i][j])) == 0) {<br>3     return(-1)<br>4   }<br>5   train = first(keys(A[i][j]))<br>6   min = A[i][j][train]<br>7   foreach k in keys(A[i][j]) {<br>8     dist = A[i][j][k]<br>9     if(dist < min) {<br>10      min = dist<br>11      train = k<br>12    }<br>13  }<br>14  return(train)<br>15 End ijMin<ul><li>a) The return value on line 3 for a non-existent route should be the integer -1, not the boolean False.</li><li>b) The loop on line 7 must iterate over the keys of the dictionary A[i][j], not its rows.</li><li>c) The procedure should handle the case where multiple trains have the same minimum distance.</li><li>d) The initialization on lines 5 and 6 is incorrect and should be inside the loop.</li></ul>";"Correct: a), b)";"<b>Explanation:</b> The question asks to identify corrections from the original benchmark problem. The original returned False instead of the specified -1 (a). The original loop iterated over rows(A[i][j]) which is incorrect for a dictionary; it must iterate over keys(A[i][j]) (b).<br><b>Distractor Rationale:</b><ul><li>c) While a valid consideration for a more robust implementation, the primary goal is to find a train with the minimum distance, which this logic does. It's not a functional error in the context of the original problem.</li><li>d) The initialization pattern is standard and functionally correct, although it processes the first element twice. It's not an error that needs correction.</li></ul>"
"After executing the following pseudocode, which statements are true? Select all that apply.<br>1 iToJ = False<br>2 if(length(keys(A[i][j])) != 0) {<br>3   iToJ = True<br>4 }<br>5 jToi = False<br>6 if(length(keys(A[j][i])) != 0) {<br>7   jToi = True<br>8 }<br>9 iBothJ = False<br>10 if(iToJ and jToi) {<br>11  iBothJ = True<br>12 }<ul><li>a) If iToJ is True and jToi is True, then iBothJ is True</li><li>b) If iBothJ is True, then iToJ is True and jToi is True</li><li>c) If iBothJ is False, then iToJ is False or jToi is False</li><li>d) If iBothJ is False, then iToJ is False and jToi is False</li></ul>";"Correct: a), b), c)";"<b>Explanation:</b> (a) is true by the definition in lines 10-12. (b) is the contrapositive of the same definition: iBothJ can only be true if both iToJ and jToi are true. (c) is also logically equivalent (by De Morgan's laws): not (iToJ and jToi) is the same as (not iToJ) or (not jToi).<br><b>Distractor Rationale:</b><ul><li>d) This is not necessarily true. iBothJ will be false if only one of iToJ or jToi is true (e.g., if there's a one-way route).</li></ul>"
"What is true about the return value of someProc(train, stn, A) from the benchmark file? Select all that apply.<br>1 Procedure someProc(train, stn, A)<br>2   foreach r in rows(A) {<br>3     if(iskey(A[r][stn], train)) {<br>4       foreach c in columns(A) {<br>5         if(iskey(A[stn][c], train)) {<br>6           return(False)<br>7         }<br>8       }<br>9       return(True)<br>10    }<br>11  }<br>12  return(False)<br>13 End someProc<ul><li>a) It returns True if stn is the starting station for train.</li><li>b) It returns False if stn is the starting station for train.</li><li>c) It returns True if stn is the ending station for train.</li><li>d) It returns False if stn is an intermediate station on train's route.</li></ul>";"Correct: b), c), d)";"<b>Explanation:</b> Let's trace the logic: The outer loop finds if the train arrives at stn. If it does, the inner loop checks if it departs from stn.<br> - If stn is an intermediate stop, it both arrives and departs, so the inner if is true, and it returns False. (d) is correct.<br> - If stn is the ending station, it arrives but never departs. The inner loop finishes, and it returns True. (c) is correct.<br> - If stn is the starting station, it never arrives. The outer loop finishes, and it returns False. (b) is correct.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect; it returns False for the starting station.</li></ul>"
"A graph of stations is represented by a matrix direct. B[i][j]=1 if station j is reachable from i. The oneMoreHop(B, direct) procedure extends the reachability by one hop. Select the correct logic to find paths of length h+1 given paths of length h (B) and paths of length 1 (direct).<ul><li>a) if(B[r][k] == 1 and B[k][c] == 1) { B_new[r][c] = 1 }</li><li>b) if(B[r][k] == 1 and direct[k][c] == 1) { B_new[r][c] = 1 }</li><li>c) if(direct[r][k] == 1 and direct[k][c] == 1) { B_new[r][c] = 1 }</li><li>d) if(B[r][c] == 1) { B_new[r][c] = 1 }</li></ul>";"Correct: b)";"<b>Explanation:</b> The fundamental logic of extending paths by one hop is to take an existing path of length up to h (from r to an intermediate station k, represented by B[r][k] == 1) and append a single direct edge (from k to c, represented by direct[k][c] == 1). This correctly computes paths of length up to h+1.<br><b>Distractor Rationale:</b><ul><li>a) This is matrix multiplication of B with itself (B-squared). This finds paths of length up to 2h, not h+1.</li><li>c) This only calculates paths of exactly 2 hops, ignoring all previously found longer paths in B.</li><li>d) This only copies the old matrix and doesn't find any new paths.</li></ul>"
"Consider the graph below. Matrix B is computed for reachability using the transitive closure algorithm. What is the value of sum after executing the given pseudocode?<br><br>1 sum = 0<br>2 foreach r in rows(B) {<br>3   foreach c in columns(B) {<br>4     sum = sum + B[r][c]<br>5   }<br>6 }<ul><li>a) 5</li><li>b) 10</li><li>c) 20</li><li>d) 25</li></ul>";"Correct: d)";"<b>Explanation:</b> The graph is a single strong component (a cycle). This means that from any node, you can eventually reach every other node, including itself, by following the directed edges. The reachability matrix B (the transitive closure) will therefore be completely full of 1s. Since there are 5 nodes, the matrix is 5x5. The sum of all elements in a 5x5 matrix of 1s is 5 * 5 = 25.<br><b>Distractor Rationale:</b><ul><li>a) This would be the sum of the diagonal if only self-reachability was counted.</li><li>b) Incorrect calculation.</li><li>c) This would be the sum if the diagonal was all 0s, which is incorrect for reachability.</li></ul>"
"The procedure doSomething(trains) creates a matrix cstn where cstn[i][j] is the number of common stations between train i and train j. If cstn[i][j] is 0 for i != j, what can be concluded?<ul><li>a) There is no route between stations with indices i and j using one hop.</li><li>b) There are no common trains between the stations with indices i and j.</li><li>c) There are no common stations on the route of trains with indices i and j.</li><li>d) None of the above.</li></ul>";"Correct: c)";"<b>Explanation:</b> The procedure is explicitly defined to calculate comNum(trains[t1], trains[t2]), which is the number of common stations. The indices i and j of the matrix cstn correspond to the trains t1 and t2. Therefore, if the result is 0, it means the two trains share no common stations on their respective routes.<br><b>Distractor Rationale:</b><ul><li>a) This conclusion is about stations, but the matrix indices i and j represent trains.</li><li>b) This is nonsensical; i and j are the trains themselves.</li><li>d) (c) is a direct and correct conclusion from the problem description.</li></ul>"
"Procedures trainBoarding1 and trainBoarding2 should return True if a given train t has at least one common station with all other trains. Which procedure works as intended?<br><b>trainBoarding1:</b><br>1 Procedure trainBoarding1(t, trains)<br>2   cMat, index = doSomething(trains)<br>3   k = index[t]<br>4   foreach i in columns(cMat) {<br>5     if(i != k and cMat[k][i] == 0) {<br>6       return False<br>7     }<br>8   }<br>9   return True<br>10 End trainBoarding1<br><br><b>trainBoarding2:</b><br>1 Procedure trainBoarding2(t, trains)<br>2   count = 0<br>3   foreach t2 in keys(trains) {<br>4     if(comNum(trains[t], trains[t2]) > 0) {<br>5       count = count + 1<br>6     }<br>7   }<br>8   if(count == length(keys(trains))) {<br>9     return(True)<br>10  }<br>11  return(False)<br>12 End trainBoarding2<ul><li>a) Only procedure trainBoarding1 works correctly.</li><li>b) Only procedure trainBoarding2 works correctly.</li><li>c) Both procedures work correctly.</li><li>d) Neither of them works correctly.</li></ul>";"Correct: c)";"<b>Explanation:</b> trainBoarding1 uses the pre-computed matrix. It iterates through all other trains i and checks if the number of common stations (cMat[k][i]) is 0. If it finds any train with 0 common stations, it correctly returns False. If the loop completes, it means all other trains had at least one common station, so it returns True. trainBoarding2 does the same logic but computes it on the fly. It counts how many trains (including itself) have a common station with t. It returns True only if this count equals the total number of trains. Both correctly implement the required logic.<br><b>Distractor Rationale:</b><ul><li>a) trainBoarding2 is also correct.</li><li>b) trainBoarding1 is also correct.</li><li>d) Both are correct.</li></ul>"
"In the context of train networks, what is the primary difference between a graph where nodes are stations and a graph where nodes are trains?<ul><li>a) There is no functional difference; they represent the same information.</li><li>b) A station-node graph shows direct travel paths, while a train-node graph shows potential transfer points between train routes.</li><li>c) A station-node graph is always undirected, while a train-node graph is always directed.</li><li>d) A station-node graph is used for calculating distance, while a train-node graph is used for calculating travel time.</li></ul>";"Correct: b)";"<b>Explanation:</b> When nodes are stations, an edge (A, B) represents the ability to travel between station A and station B. When nodes are trains, an edge (T1, T2) represents the existence of a common station where a passenger could transfer from train T1 to train T2. They model two different aspects of the network: physical routes vs. logical connections between services.<br><b>Distractor Rationale:</b><ul><li>a) They represent fundamentally different relationships.</li><li>c) Both graph types can be either directed or undirected depending on what is being modeled (e.g., one-way tracks, transfer time constraints).</li><li>d) Both graph types can be augmented with edge labels (weights) to calculate distance or time.</li></ul>"
"What does the transitive closure of a train network graph, where stations are nodes, represent?<ul><li>a) The set of all trains that pass through a single, central station.</li><li>b) All pairs of stations (A, B) such that it is possible to travel from A to B by taking any number of connecting trains.</li><li>c) The shortest possible distance between every pair of stations.</li><li>d) A list of all stations that are starting or ending points, but not intermediate stops.</li></ul>";"Correct: b)";"<b>Explanation:</b> Transitive closure is a fundamental graph concept that identifies all reachable pairs of nodes. If you can get from A to B, and from B to C, the closure includes the 'implied' connection from A to C. Applying this exhaustively to a train network graph reveals all pairs of stations that are reachable from one another, regardless of the number of intermediate train changes.<br><b>Distractor Rationale:</b><ul><li>a) This is a property of a specific station (its connectivity), not the whole graph's reachability.</li><li>c) Transitive closure determines reachability (a yes/no answer), not the optimal path distance. Algorithms like the Floyd-Warshall algorithm build upon this concept to find shortest paths.</li><li>d) This describes terminal stations, which is a subset of nodes, not the connectivity between them.</li></ul>"
"In the context of the 'Trains' dataset, if you model the problem with trains as nodes, what does a directed edge from Train A to Train B most likely represent?<ul><li>a) Train A and Train B travel on the exact same route.</li><li>b) Train A and Train B share a common station, allowing a passenger to transfer from A to B.</li><li>c) Train A is faster than Train B.</li><li>d) Train A has more stops than Train B.</li></ul>";"Correct: b)";"<b>Explanation:</b> When trains are nodes, the relationship (edge) between them is defined by shared stations. An edge signifies a potential transfer point. If the edge is directed, it likely includes time-based logic, meaning you can arrive on Train A and depart on Train B in a valid sequence.<br><b>Distractor Rationale:</b><ul><li>a) This is a possible but very specific condition; the more general representation is a shared station.</li><li>c) Speed is an attribute of the node (train), not the relationship between them.</li><li>d) The number of stops is an attribute of the node (train).</li></ul>"
"You are modifying the oneMoreHop procedure to calculate the shortest distance, creating OneHopDistance. The matrix directdist holds the shortest direct distances. How should onehopdist[i][j] be initialized before the loops begin?<ul><li>a) To 0</li><li>b) To a very large number (infinity)</li><li>c) To directdist[i][j]</li><li>d) To 1</li></ul>";"Correct: c)";"<b>Explanation:</b> The goal is to find the shortest path with at most one hop. Therefore, the initial shortest path is the direct path itself. If a shorter one-hop path is found via an intermediate station k, this initial value will be updated. Initializing to 0 or 1 would lose the direct distance information, and initializing to infinity would incorrectly treat direct paths as non-existent.<br><b>Distractor Rationale:</b><ul><li>a) This would erase all known direct distance information.</li><li>b) This would incorrectly imply that there are no direct connections to begin with.</li><li>d) This would lose the distance information and treat the graph as unweighted.</li></ul>"
"In the OneHopDistance procedure, a new path from i to j via an intermediate station k is found. How is the distance of this new path calculated?<ul><li>a) newdist = min(directdist[i][k], directdist[k][j])</li><li>b) newdist = directdist[i][k] + directdist[k][j]</li><li>c) newdist = (directdist[i][k] + directdist[k][j]) / 2</li><li>d) newdist = directdist[i][j] + directdist[k][j]</li></ul>";"Correct: b)";"<b>Explanation:</b> A path's total distance is the sum of the distances of its constituent edges. The path from i to j via k consists of two segments: the direct path from i to k and the direct path from k to j. The total distance is the sum of their individual distances.<br><b>Distractor Rationale:</b><ul><li>a) This would find the shorter of the two segments, not the total path length.</li><li>c) This calculates the average, which is not meaningful for path distance.</li><li>d) This incorrectly adds the distance from k to j to the existing direct i to j distance.</li></ul>"
"After calculating newdist = directdist[i][k] + directdist[k][j], how should onehopdist[i][j] be updated? Select all that apply.<br><ul><li>a) if(onehopdist[i][j] > 0) { onehopdist[i][j] = min(onehopdist[i][j], newdist) } else { onehopdist[i][j] = newdist }</li><li>b) onehopdist[i][j] = newdist</li><li>c) if(newdist < onehopdist[i][j]) { onehopdist[i][j] = newdist }</li><li>d) if(directdist[i][j] == 0) { onehopdist[i][j] = newdist }</li></ul>";"Correct: a)";"<b>Explanation:</b> This logic correctly handles both cases for updating the shortest path. If a path from i to j already exists (onehopdist[i][j] > 0), we must update it only if the newly found path is shorter (min(onehopdist[i][j], newdist)). If no path existed before (else, meaning onehopdist[i][j] was 0), the new path is automatically the shortest one found so far, so we assign newdist to it.<br><b>Distractor Rationale:</b><ul><li>b) This would unconditionally overwrite the existing shortest path, even if the new path is longer.</li><li>c) This fails to handle the case where onehopdist[i][j] is initially 0 (no path known).</li><li>d) This only updates if there was no direct path, ignoring cases where a one-hop path might be shorter than a different, already-found one-hop path.</li></ul>"
"If you run the shortest path algorithm (like Floyd-Warshall) for N-1 iterations on an N-station network, what does the final matrix dist[i][j] contain?<ul><li>a) 1 if a path exists, 0 otherwise.</li><li>b) The number of hops in the shortest path from i to j.</li><li>c) The distance of the shortest path from i to j, considering paths with up to N-1 hops.</li><li>d) The distance of the longest possible simple path from i to j.</li></ul>";"Correct: c)";"<b>Explanation:</b> Iteratively updating distances by considering all intermediate nodes builds up the shortest path. After N-1 iterations (for an N-node graph), the algorithm has considered all possible simple paths (paths without loops) between any two nodes. The resulting matrix contains the minimum distance for the shortest of these paths.<br><b>Distractor Rationale:</b><ul><li>a) This describes reachability (transitive closure), not the shortest path distance.</li><li>b) The algorithm calculates the sum of weights (distances), not the number of edges (hops).</li><li>d) The algorithm is designed to find the minimum distance, not the maximum.</li></ul>"
"Why is it sufficient to stop the iterative shortest path algorithm after N-1 iterations for an N-node graph?<ul><li>a) Because any path longer than N-1 hops must be a direct route.</li><li>b) Because any path with N or more hops must contain a cycle, which is unnecessary for finding the shortest path between two nodes.</li><li>c) Because computers can't handle more than N-1 levels of nested loops.</li><li>d) Because after N-1 iterations, all distances become 0.</li></ul>";"Correct: b)";"<b>Explanation:</b> A simple path (one that does not repeat vertices) can have at most N-1 edges in an N-node graph. If a path has more edges than that, by the pigeonhole principle, it must have revisited at least one node, creating a cycle. A cycle is a non-optimal way to get from a start to an end point, so these longer paths can be ignored when searching for the shortest path.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect; longer paths are the opposite of direct routes.</li><li>c) This is a false statement about computational limits.</li><li>d) This is incorrect; distances are calculated, not zeroed out.</li></ul>"
"Consider a graph where trains are nodes and an edge exists if they share a station. What information would be a useful label for an edge between Train A and Train B? Select all that apply.<ul><li>a) The name of the common station(s).</li><li>b) The number of stations Train A has.</li><li>c) The shortest travel time between the two trains (i.e., waiting time at the transfer station).</li><li>d) The total distance covered by Train B.</li></ul>";"Correct: a), c)";"<b>Explanation:</b> The edge represents the transfer itself. Therefore, useful labels are details about that transfer. The name of the station tells you where to transfer (a). The waiting time tells you the cost of the transfer (c), which is crucial for planning a journey.<br><b>Distractor Rationale:</b><ul><li>b) The number of stations is a property of the node (Train A), not the edge (the transfer).</li><li>d) The total distance is a property of the node (Train B), not the edge.</li></ul>"
"If directdist[i][j] = 150 and onehopdist[i][j] = 120, what does this imply?<ul><li>a) The direct train from i to j covers 150 km, but there is a path through an intermediate station k that totals 120 km.</li><li>b) A logical error has occurred, as the one-hop distance cannot be less than the direct distance.</li><li>c) The direct train covers 120 km, and the one-hop path covers 150 km.</li><li>d) Traveling from i to j requires at least one stop.</li></ul>";"Correct: a)";"<b>Explanation:</b> directdist stores the shortest direct route. onehopdist stores the shortest route with at most one hop. If the onehopdist value is smaller, it means the algorithm found a path i -> k -> j whose combined distance (directdist[i][k] + directdist[k][j]) is less than the distance of the direct train route from i to j. This is common in real-world networks (e.g., flying from A to C might be cheaper than the direct flight A to B if you go via a hub at C). Oops, I made a mistake in my reasoning. In the context of the provided pseudocode, onehopdist is initialized with directdist. It is then only updated with min(onehopdist[i][j], newdist). This means onehopdist can never be greater than directdist. Let me re-evaluate the question and choices. The question presents a hypothetical outcome. The most logical interpretation of the variable names is that directdist[i][j] is the length of the direct edge, and onehopdist[i][j] is the length of the shortest path with one hop. In some networks, it's possible for a path through an intermediate point to be shorter (e.g., a mountain pass). So (a) is the correct interpretation of the data, even if it seems counter-intuitive for a simple distance model.<br><b>Distractor Rationale:</b><ul><li>b) While it seems like an error, it's physically possible in some network topologies, so it's not a guaranteed logical error without more context.</li><li>c) This reverses the meaning of the variables.</li><li>d) This is not necessarily true; a direct route of 150km exists.</li></ul>"
"You want to find the station that acts as the biggest 'hub' by having the most direct, unique train lines passing through it (arriving or departing). Which approach would work?<ul><li>a) Create a station-node graph and find the node with the highest out-degree.</li><li>b) Create a train-node graph and find the node with the highest degree.</li><li>c) Create a station-node graph and find the node with the highest sum of incoming and outgoing edge weights.</li><li>d) Create a station-node graph and find the node with the highest degree (in-degree + out-degree).</li></ul>";"Correct: d)";"<b>Explanation:</b> In a station-node graph, an edge represents a direct train route. The in-degree of a station node is the number of routes arriving there, and the out-degree is the number of routes departing. The total degree (in-degree + out-degree) represents the total number of unique train services connected to that station, which is a good measure of it being a 'hub'.<br><b>Distractor Rationale:</b><ul><li>a) This only counts departing trains, ignoring arrivals.</li><li>b) The degree of a train-node represents how many other trains it connects with, not how many lines pass through a station.</li><li>c) This would sum distances or other weights, not the number of connections.</li></ul>"
"What is a primary advantage of representing a graph as an adjacency matrix for computational tasks?<ul><li>a) It is more space-efficient than an adjacency list for sparse graphs (graphs with few edges).</li><li>b) Checking for the existence of a specific edge between two nodes (i, j) is very fast (constant time complexity).</li><li>c) Adding or removing a node from the graph is a very efficient operation.</li><li>d) It directly represents the visual layout of the graph.</li></ul>";"Correct: b)";"<b>Explanation:</b> In an adjacency matrix M, checking for an edge between nodes i and j is a simple lookup of the element M[i][j]. This operation takes the same amount of time regardless of the size of the graph (O(1) complexity), which is highly efficient.<br><b>Distractor Rationale:</b><ul><li>a) Adjacency matrices are less space-efficient for sparse graphs because they always store space for every possible edge, even non-existent ones. Adjacency lists are better for sparse graphs.</li><li>c) Adding or removing a node requires resizing and rebuilding the entire matrix, which is very inefficient.</li><li>d) An adjacency matrix is an abstract representation of connectivity and has no inherent visual or geographical information.</li></ul>"
"If a train network is represented as a directed graph, what does a directed edge from station A to station B imply?<ul><li>a) The distance from A to B is the same as from B to A.</li><li>b) There is a train service that travels from A to B, but not necessarily one that travels from B to A.</li><li>c) All trains that go to A must also go to B.</li><li>d) Station A and Station B are in the same city.</li></ul>";"Correct: b)";"<b>Explanation:</b> A directed edge represents a one-way relationship. In a train network, this means there is a defined route segment that starts at A and ends at B. The existence of a return service from B to A would require a separate, explicit edge pointing in the opposite direction.<br><b>Distractor Rationale:</b><ul><li>a) This describes a property of an undirected (or symmetric) graph.</li><li>c) This is an incorrect interpretation; the edge only relates A and B.</li><li>d) This is irrelevant to the graph's logical structure.</li></ul>"
"If cstn[i][j] stores the number of common stations between train i and train j, what does it mean if the matrix cstn is symmetric (cstn[i][j] == cstn[j][i] for all i, j)?<ul><li>a) Every train has a return journey on the same route.</li><li>b) The number of common stations between any two trains i and j is always the same as between j and i.</li><li>c) All trains pass through the same number of stations.</li><li>d) The graph must be a straight line.</li></ul>";"Correct: b)";"<b>Explanation:</b> The operation comNum(trains[i], trains[j]) is commutative; the number of common elements between two sets (or lists) is the same regardless of the order they are considered in. Therefore, the resulting matrix must be symmetric by definition.<br><b>Distractor Rationale:</b><ul><li>a) This is a property of the train routes themselves, not a necessary consequence of the comNum operation.</li><li>c) This is a property of the individual trains (nodes), not the relationship between them.</li><li>d) The symmetry of this specific matrix representation does not constrain the topology of the underlying network.</li></ul>"
"A train delay is detected. To model its propagation, you use a station-node graph. The delay is a property you add to a node at a specific time. What is the next logical step to calculate the delay's impact?<ul><li>a) Increase the distance of all outgoing edges from the delayed station's node.</li><li>b) For the delayed train, identify its next station on the route and calculate its new, later arrival time there.</li><li>c) Delete the delayed train's node from the graph.</li><li>d) Reverse the direction of all edges connected to the delayed station's node.</li></ul>";"Correct: b)";"<b>Explanation:</b> Delay propagates along a train's path. The first step is to determine the immediate consequence: the train will arrive later at its next scheduled stop. This new arrival time then becomes the basis for checking for knock-on effects on other trains at that next station.<br><b>Distractor Rationale:</b><ul><li>a) Distance is a static property of the track; it doesn't change. Time is the variable that changes.</li><li>c) Deleting the node is incorrect; the train is late, not cancelled.</li><li>d) Reversing edges makes no logical sense in this context.</li></ul>"
"After a train's arrival time at Station X is updated due to a delay, how do you check for knock-on delays to other trains at Station X?<ul><li>a) Find all trains that share a common co-author with the delayed train.</li><li>b) Check for any other trains scheduled to depart from Station X soon after the delayed train's new arrival time.</li><li>c) Add the delay time to all other trains passing through Station X, regardless of their schedule.</li><li>d) Assume that if one train is late, all trains are late by the same amount.</li></ul>";"Correct: b)";"<b>Explanation:</b> A knock-on delay occurs if the delayed train occupies a track or platform that another train needs, or if they follow each other closely on the same line segment. The critical check is to compare the delayed train's new schedule at Station X with the original schedules of other trains at the same station to see if conflicts have been created.<br><b>Distractor Rationale:</b><ul><li>a) This refers to a completely different problem (author graph).</li><li>c) This is an oversimplification; a train departing hours later would likely be unaffected.</li><li>d) This is a blanket assumption that ignores the specifics of the schedule.</li></ul>"
"In an edge-labeled graph where direct[i][j] stores a dictionary of trains running directly from i to j, how would you check if a specific train, T, runs directly from i to j?<ul><li>a) if (direct[i][j] == T)</li><li>b) if (isKey(direct[i][j], T))</li><li>c) if (length(direct[i][j]) > 0)</li><li>d) if (direct[i][T] == j)</li></ul>";"Correct: b)";"<b>Explanation:</b> The entry direct[i][j] is a dictionary where the keys are the train numbers. To check if train T is one of those trains, you need to check if T exists as a key within that dictionary. isKey(dictionary, key) is the standard pseudocode function for this.<br><b>Distractor Rationale:</b><ul><li>a) This compares the entire dictionary to a single train number, which will always be false.</li><li>c) This checks if any train runs on the route, not if a specific train T does.</li><li>d) This incorrectly structures the matrix lookup, treating the train number T as a column index.</li></ul>"
"If you build a graph where stations are nodes and edge labels represent travel time in minutes, what does the path A -> B -> C with a total weight of 150 signify?<ul><li>a) It takes 150 minutes to travel from A to C, including any waiting time at station B.</li><li>b) The train travels at 150 km/h.</li><li>c) The direct distance from A to C is 150 km.</li><li>d) There are 150 stations between A and C.</li></ul>";"Correct: a)";"<b>Explanation:</b> In a weighted graph, the weight of a path is the sum of the weights of its edges. If edge labels represent travel time, the path weight represents the total travel time. For a multi-hop journey, this must include the travel time from A to B, the waiting/transfer time at B, and the travel time from B to C.<br><b>Distractor Rationale:</b><ul><li>b) The weight is time, not speed.</li><li>c) The weight is time, not distance.</li><li>d) The weight is time, not a count of stations.</li></ul>"
"Which of these real-world scenarios is LEAST likely to be modeled effectively using a simple, unweighted graph?<ul><li>a) A social network, where an edge means two people are friends.</li><li>b) A map of airline routes, where an edge means there is a direct flight between two cities.</li><li>c) A city road network used by a GPS to find the fastest route from home to work.</li><li>d) The layout of a computer network, where an edge means two computers are directly connected.</li></ul>";"Correct: c)";"<b>Explanation:</b> To find the fastest route, the system needs more than just connectivity information. It needs to know the travel time or speed limit on each road segment. This requires a weighted graph, where edge weights represent time or distance. The other scenarios can be effectively modeled with simple yes/no connections.<br><b>Distractor Rationale:</b><ul><li>a) A simple friends/not-friends relationship is unweighted.</li><li>b) Basic route maps are often unweighted (flight exists/does not exist).</li><li>d) Basic network topology is unweighted (connected/not connected).</li></ul>"
"When modeling train routes, why might a graph be non-symmetric (i.e., have direct[i][j] = 1 but direct[j][i] = 0)? Select all that apply.<ul><li>a) The train service is one-way only.</li><li>b) The return journey is considered a different train with a different number.</li><li>c) The track is physically a one-way loop.</li><li>d) The distance from i to j is different from j to i.</li></ul>";"Correct: a), c)";"<b>Explanation:</b> A non-symmetric or directed graph represents one-way relationships. This can occur in transport networks if a service is explicitly one-way (a), or if the physical infrastructure is a one-way loop (c), like some city metro lines or ring roads.<br><b>Distractor Rationale:</b><ul><li>b) If the return journey is a different train, it would simply create a second, separate edge from j to i, resulting in a symmetric relationship (an edge in both directions), just represented by different labels.</li><li>d) Different distances don't prevent the existence of a return route; the graph would still be symmetric, just with different weights on the opposing edges.</li></ul>"
"What is the time complexity of finding all the immediate neighbors of a node i in an adjacency matrix representation of a graph with N nodes?<ul><li>a) O(1) - Constant time</li><li>b) O(log N) - Logarithmic time</li><li>c) O(N) - Linear time</li><li>d) O(N^2) - Quadratic time</li></ul>";"Correct: c)";"<b>Explanation:</b> To find all neighbors of node i, you must inspect every entry in the i-th row of the matrix. Since there are N columns in that row, you must perform N checks. Therefore, the time taken is directly proportional to the number of nodes, N.<br><b>Distractor Rationale:</b><ul><li>a) This is the complexity for checking a single edge, not finding all neighbors.</li><li>b) This complexity is typical of search algorithms on sorted data structures like binary search trees, not matrix row scans.</li><li>d) This is the complexity for iterating through the entire matrix, not just one row.</li></ul>"
"What does the transitive closure of a train network graph, where stations are nodes, represent?<ul><li>a) The set of all trains that pass through a single, central station.</li><li>b) All pairs of stations (A, B) such that it is possible to travel from A to B by taking any number of connecting trains.</li><li>c) The shortest possible distance between every pair of stations.</li><li>d) A list of all stations that are starting or ending points, but not intermediate stops.</li></ul>";"Correct: b)";"<b>Explanation:</b> Transitive closure is a fundamental graph concept that identifies all reachable pairs of nodes. If you can get from A to B, and from B to C, the closure includes the 'implied' connection from A to C. Applying this exhaustively to a train network graph reveals all pairs of stations that are reachable from one another, regardless of the number of intermediate train changes.<br><b>Distractor Rationale:</b><ul><li>a) This is a property of a specific station (its connectivity), not the whole graph's reachability.</li><li>c) Transitive closure determines reachability (a yes/no answer), not the optimal path distance. Algorithms like the Floyd-Warshall algorithm build upon this concept to find shortest paths.</li><li>d) This describes terminal stations, which is a subset of nodes, not the connectivity between them.</li></ul>"
"In the context of the 'Trains' dataset, if you model the problem with trains as nodes, what does a directed edge from Train A to Train B most likely represent?<ul><li>a) Train A and Train B travel on the exact same route.</li><li>b) Train A and Train B share a common station, allowing a passenger to transfer from A to B.</li><li>c) Train A is faster than Train B.</li><li>d) Train A has more stops than Train B.</li></ul>";"Correct: b)";"<b>Explanation:</b> When trains are nodes, the relationship (edge) between them is defined by shared stations. An edge signifies a potential transfer point. If the edge is directed, it likely includes time-based logic, meaning you can arrive on Train A and depart on Train B in a valid sequence.<br><b>Distractor Rationale:</b><ul><li>a) This is a possible but very specific condition; the more general representation is a shared station.</li><li>c) Speed is an attribute of the node (train), not the relationship between them.</li><li>d) The number of stops is an attribute of the node (train).</li></ul>"
"You are modifying the oneMoreHop procedure to calculate the shortest distance, creating OneHopDistance. The matrix directdist holds the shortest direct distances. How should onehopdist[i][j] be initialized before the loops begin?<ul><li>a) To 0</li><li>b) To a very large number (infinity)</li><li>c) To directdist[i][j]</li><li>d) To 1</li></ul>";"Correct: c)";"<b>Explanation:</b> The goal is to find the shortest path with at most one hop. Therefore, the initial shortest path is the direct path itself. If a shorter one-hop path is found via an intermediate station k, this initial value will be updated. Initializing to 0 or 1 would lose the direct distance information, and initializing to infinity would incorrectly treat direct paths as non-existent.<br><b>Distractor Rationale:</b><ul><li>a) This would erase all known direct distance information.</li><li>b) This would incorrectly imply that there are no direct connections to begin with.</li><li>d) This would lose the distance information and treat the graph as unweighted.</li></ul>"
"In the OneHopDistance procedure, a new path from i to j via an intermediate station k is found. How is the distance of this new path calculated?<ul><li>a) newdist = min(directdist[i][k], directdist[k][j])</li><li>b) newdist = directdist[i][k] + directdist[k][j]</li><li>c) newdist = (directdist[i][k] + directdist[k][j]) / 2</li><li>d) newdist = directdist[i][j] + directdist[k][j]</li></ul>";"Correct: b)";"<b>Explanation:</b> A path's total distance is the sum of the distances of its constituent edges. The path from i to j via k consists of two segments: the direct path from i to k and the direct path from k to j. The total distance is the sum of their individual distances.<br><b>Distractor Rationale:</b><ul><li>a) This would find the shorter of the two segments, not the total path length.</li><li>c) This calculates the average, which is not meaningful for path distance.</li><li>d) This incorrectly adds the distance from k to j to the existing direct i to j distance.</li></ul>"
"After calculating newdist = directdist[i][k] + directdist[k][j], how should onehopdist[i][j] be updated? Select all that apply.<br><ul><li>a) if(onehopdist[i][j] > 0) { onehopdist[i][j] = min(onehopdist[i][j], newdist) } else { onehopdist[i][j] = newdist }</li><li>b) onehopdist[i][j] = newdist</li><li>c) if(newdist < onehopdist[i][j]) { onehopdist[i][j] = newdist }</li><li>d) if(directdist[i][j] == 0) { onehopdist[i][j] = newdist }</li></ul>";"Correct: a)";"<b>Explanation:</b> This logic correctly handles both cases for updating the shortest path. If a path from i to j already exists (onehopdist[i][j] > 0), we must update it only if the newly found path is shorter (min(onehopdist[i][j], newdist)). If no path existed before (else, meaning onehopdist[i][j] was 0), the new path is automatically the shortest one found so far, so we assign newdist to it.<br><b>Distractor Rationale:</b><ul><li>b) This would unconditionally overwrite the existing shortest path, even if the new path is longer.</li><li>c) This fails to handle the case where onehopdist[i][j] is initially 0 (no path known).</li><li>d) This only updates if there was no direct path, ignoring cases where a one-hop path might be shorter than a different, already-found one-hop path.</li></ul>"
"If you run the shortest path algorithm (like Floyd-Warshall) for N-1 iterations on an N-station network, what does the final matrix dist[i][j] contain?<ul><li>a) 1 if a path exists, 0 otherwise.</li><li>b) The number of hops in the shortest path from i to j.</li><li>c) The distance of the shortest path from i to j, considering paths with up to N-1 hops.</li><li>d) The distance of the longest possible simple path from i to j.</li></ul>";"Correct: c)";"<b>Explanation:</b> Iteratively updating distances by considering all intermediate nodes builds up the shortest path. After N-1 iterations (for an N-node graph), the algorithm has considered all possible simple paths (paths without loops) between any two nodes. The resulting matrix contains the minimum distance for the shortest of these paths.<br><b>Distractor Rationale:</b><ul><li>a) This describes reachability (transitive closure), not the shortest path distance.</li><li>b) The algorithm calculates the sum of weights (distances), not the number of edges (hops).</li><li>d) The algorithm is designed to find the minimum distance, not the maximum.</li></ul>"
"Why is it sufficient to stop the iterative shortest path algorithm after N-1 iterations for an N-node graph?<ul><li>a) Because any path longer than N-1 hops must be a direct route.</li><li>b) Because any path with N or more hops must contain a cycle, which is unnecessary for finding the shortest path between two nodes.</li><li>c) Because computers can't handle more than N-1 levels of nested loops.</li><li>d) Because after N-1 iterations, all distances become 0.</li></ul>";"Correct: b)";"<b>Explanation:</b> A simple path (one that does not repeat vertices) can have at most N-1 edges in an N-node graph. If a path has more edges than that, by the pigeonhole principle, it must have revisited at least one node, creating a cycle. A cycle is a non-optimal way to get from a start to an end point, so these longer paths can be ignored when searching for the shortest path.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect; longer paths are the opposite of direct routes.</li><li>c) This is a false statement about computational limits.</li><li>d) This is incorrect; distances are calculated, not zeroed out.</li></ul>"
"Consider a graph where trains are nodes and an edge exists if they share a station. What information would be a useful label for an edge between Train A and Train B? Select all that apply.<ul><li>a) The name of the common station(s).</li><li>b) The number of stations Train A has.</li><li>c) The shortest travel time between the two trains (i.e., waiting time at the transfer station).</li><li>d) The total distance covered by Train B.</li></ul>";"Correct: a), c)";"<b>Explanation:</b> The edge represents the transfer itself. Therefore, useful labels are details about that transfer. The name of the station tells you where to transfer (a). The waiting time tells you the cost of the transfer (c), which is crucial for planning a journey.<br><b>Distractor Rationale:</b><ul><li>b) The number of stations is a property of the node (Train A), not the edge (the transfer).</li><li>d) The total distance is a property of the node (Train B), not the edge.</li></ul>"
"If directdist[i][j] = 150 and onehopdist[i][j] = 120, what does this imply?<ul><li>a) The direct train from i to j covers 150 km, but there is a path through an intermediate station k that totals 120 km.</li><li>b) A logical error has occurred, as the one-hop distance cannot be less than the direct distance.</li><li>c) The direct train covers 120 km, and the one-hop path covers 150 km.</li><li>d) Traveling from i to j requires at least one stop.</li></ul>";"Correct: a)";"<b>Explanation:</b> directdist stores the shortest direct route. onehopdist stores the shortest route with at most one hop. If the onehopdist value is smaller, it means the algorithm found a path i -> k -> j whose combined distance (directdist[i][k] + directdist[k][j]) is less than the distance of the direct train route from i to j. This is common in real-world networks (e.g., flying from A to C might be cheaper than the direct flight A to B if you go via a hub at C). Oops, I made a mistake in my reasoning. In the context of the provided pseudocode, onehopdist is initialized with directdist. It is then only updated with min(onehopdist[i][j], newdist). This means onehopdist can never be greater than directdist. Let me re-evaluate the question and choices. The question presents a hypothetical outcome. The most logical interpretation of the variable names is that directdist[i][j] is the length of the direct edge, and onehopdist[i][j] is the length of the shortest path with one hop. In some networks, it's possible for a path through an intermediate point to be shorter (e.g., a mountain pass). So (a) is the correct interpretation of the data, even if it seems counter-intuitive for a simple distance model.<br><b>Distractor Rationale:</b><ul><li>b) While it seems like an error, it's physically possible in some network topologies, so it's not a guaranteed logical error without more context.</li><li>c) This reverses the meaning of the variables.</li><li>d) This is not necessarily true; a direct route of 150km exists.</li></ul>"
"You want to find the station that acts as the biggest 'hub' by having the most direct, unique train lines passing through it (arriving or departing). Which approach would work?<ul><li>a) Create a station-node graph and find the node with the highest out-degree.</li><li>b) Create a train-node graph and find the node with the highest degree.</li><li>c) Create a station-node graph and find the node with the highest sum of incoming and outgoing edge weights.</li><li>d) Create a station-node graph and find the node with the highest degree (in-degree + out-degree).</li></ul>";"Correct: d)";"<b>Explanation:</b> In a station-node graph, an edge represents a direct train route. The in-degree of a station node is the number of routes arriving there, and the out-degree is the number of routes departing. The total degree (in-degree + out-degree) represents the total number of unique train services connected to that station, which is a good measure of it being a 'hub'.<br><b>Distractor Rationale:</b><ul><li>a) This only counts departing trains, ignoring arrivals.</li><li>b) The degree of a train-node represents how many other trains it connects with, not how many lines pass through a station.</li><li>c) This would sum distances or other weights, not the number of connections.</li></ul>"
"What is a primary advantage of representing a graph as an adjacency matrix for computational tasks?<ul><li>a) It is more space-efficient than an adjacency list for sparse graphs (graphs with few edges).</li><li>b) Checking for the existence of a specific edge between two nodes (i, j) is very fast (constant time complexity).</li><li>c) Adding or removing a node from the graph is a very efficient operation.</li><li>d) It directly represents the visual layout of the graph.</li></ul>";"Correct: b)";"<b>Explanation:</b> In an adjacency matrix M, checking for an edge between nodes i and j is a simple lookup of the element M[i][j]. This operation takes the same amount of time regardless of the size of the graph (O(1) complexity), which is highly efficient.<br><b>Distractor Rationale:</b><ul><li>a) Adjacency matrices are less space-efficient for sparse graphs because they always store space for every possible edge, even non-existent ones. Adjacency lists are better for sparse graphs.</li><li>c) Adding or removing a node requires resizing and rebuilding the entire matrix, which is very inefficient.</li><li>d) An adjacency matrix is an abstract representation of connectivity and has no inherent visual or geographical information.</li></ul>"
"If a train network is represented as a directed graph, what does a directed edge from station A to station B imply?<ul><li>a) The distance from A to B is the same as from B to A.</li><li>b) There is a train service that travels from A to B, but not necessarily one that travels from B to A.</li><li>c) All trains that go to A must also go to B.</li><li>d) Station A and Station B are in the same city.</li></ul>";"Correct: b)";"<b>Explanation:</b> A directed edge represents a one-way relationship. In a train network, this means there is a defined route segment that starts at A and ends at B. The existence of a return service from B to A would require a separate, explicit edge pointing in the opposite direction.<br><b>Distractor Rationale:</b><ul><li>a) This describes a property of an undirected (or symmetric) graph.</li><li>c) This is an incorrect interpretation; the edge only relates A and B.</li><li>d) This is irrelevant to the graph's logical structure.</li></ul>"
"If cstn[i][j] stores the number of common stations between train i and train j, what does it mean if the matrix cstn is symmetric (cstn[i][j] == cstn[j][i] for all i, j)?<ul><li>a) Every train has a return journey on the same route.</li><li>b) The number of common stations between any two trains i and j is always the same as between j and i.</li><li>c) All trains pass through the same number of stations.</li><li>d) The graph must be a straight line.</li></ul>";"Correct: b)";"<b>Explanation:</b> The operation comNum(trains[i], trains[j]) is commutative; the number of common elements between two sets (or lists) is the same regardless of the order they are considered in. Therefore, the resulting matrix must be symmetric by definition.<br><b>Distractor Rationale:</b><ul><li>a) This is a property of the train routes themselves, not a necessary consequence of the comNum operation.</li><li>c) This is a property of the individual trains (nodes), not the relationship between them.</li><li>d) The symmetry of this specific matrix representation does not constrain the topology of the underlying network.</li></ul>"
"A train delay is detected. To model its propagation, you use a station-node graph. The delay is a property you add to a node at a specific time. What is the next logical step to calculate the delay's impact?<ul><li>a) Increase the distance of all outgoing edges from the delayed station's node.</li><li>b) For the delayed train, identify its next station on the route and calculate its new, later arrival time there.</li><li>c) Delete the delayed train's node from the graph.</li><li>d) Reverse the direction of all edges connected to the delayed station's node.</li></ul>";"Correct: b)";"<b>Explanation:</b> Delay propagates along a train's path. The first step is to determine the immediate consequence: the train will arrive later at its next scheduled stop. This new arrival time then becomes the basis for checking for knock-on effects on other trains at that next station.<br><b>Distractor Rationale:</b><ul><li>a) Distance is a static property of the track; it doesn't change. Time is the variable that changes.</li><li>c) Deleting the node is incorrect; the train is late, not cancelled.</li><li>d) Reversing edges makes no logical sense in this context.</li></ul>"
"After a train's arrival time at Station X is updated due to a delay, how do you check for knock-on delays to other trains at Station X?<ul><li>a) Find all trains that share a common co-author with the delayed train.</li><li>b) Check for any other trains scheduled to depart from Station X soon after the delayed train's new arrival time.</li><li>c) Add the delay time to all other trains passing through Station X, regardless of their schedule.</li><li>d) Assume that if one train is late, all trains are late by the same amount.</li></ul>";"Correct: b)";"<b>Explanation:</b> A knock-on delay occurs if the delayed train occupies a track or platform that another train needs, or if they follow each other closely on the same line segment. The critical check is to compare the delayed train's new schedule at Station X with the original schedules of other trains at the same station to see if conflicts have been created.<br><b>Distractor Rationale:</b><ul><li>a) This refers to a completely different problem (author graph).</li><li>c) This is an oversimplification; a train departing hours later would likely be unaffected.</li><li>d) This is a blanket assumption that ignores the specifics of the schedule.</li></ul>"
"In an edge-labeled graph where direct[i][j] stores a dictionary of trains running directly from i to j, how would you check if a specific train, T, runs directly from i to j?<ul><li>a) if (direct[i][j] == T)</li><li>b) if (isKey(direct[i][j], T))</li><li>c) if (length(direct[i][j]) > 0)</li><li>d) if (direct[i][T] == j)</li></ul>";"Correct: b)";"<b>Explanation:</b> The entry direct[i][j] is a dictionary where the keys are the train numbers. To check if train T is one of those trains, you need to check if T exists as a key within that dictionary. isKey(dictionary, key) is the standard pseudocode function for this.<br><b>Distractor Rationale:</b><ul><li>a) This compares the entire dictionary to a single train number, which will always be false.</li><li>c) This checks if any train runs on the route, not if a specific train T does.</li><li>d) This incorrectly structures the matrix lookup, treating the train number T as a column index.</li></ul>"
"If you build a graph where stations are nodes and edge labels represent travel time in minutes, what does the path A -> B -> C with a total weight of 150 signify?<ul><li>a) It takes 150 minutes to travel from A to C, including any waiting time at station B.</li><li>b) The train travels at 150 km/h.</li><li>c) The direct distance from A to C is 150 km.</li><li>d) There are 150 stations between A and C.</li></ul>";"Correct: a)";"<b>Explanation:</b> In a weighted graph, the weight of a path is the sum of the weights of its edges. If edge labels represent travel time, the path weight represents the total travel time. For a multi-hop journey, this must include the travel time from A to B, the waiting/transfer time at B, and the travel time from B to C.<br><b>Distractor Rationale:</b><ul><li>b) The weight is time, not speed.</li><li>c) The weight is time, not distance.</li><li>d) The weight is time, not a count of stations.</li></ul>"
"Which of these real-world scenarios is LEAST likely to be modeled effectively using a simple, unweighted graph?<ul><li>a) A social network, where an edge means two people are friends.</li><li>b) A map of airline routes, where an edge means there is a direct flight between two cities.</li><li>c) A city road network used by a GPS to find the fastest route from home to work.</li><li>d) The layout of a computer network, where an edge means two computers are directly connected.</li></ul>";"Correct: c)";"<b>Explanation:</b> To find the fastest route, the system needs more than just connectivity information. It needs to know the travel time or speed limit on each road segment. This requires a weighted graph, where edge weights represent time or distance. The other scenarios can be effectively modeled with simple yes/no connections.<br><b>Distractor Rationale:</b><ul><li>a) A simple friends/not-friends relationship is unweighted.</li><li>b) Basic route maps are often unweighted (flight exists/does not exist).</li><li>d) Basic network topology is unweighted (connected/not connected).</li></ul>"
"When modeling train routes, why might a graph be non-symmetric (i.e., have direct[i][j] = 1 but direct[j][i] = 0)? Select all that apply.<ul><li>a) The train service is one-way only.</li><li>b) The return journey is considered a different train with a different number.</li><li>c) The track is physically a one-way loop.</li><li>d) The distance from i to j is different from j to i.</li></ul>";"Correct: a), c)";"<b>Explanation:</b> A non-symmetric or directed graph represents one-way relationships. This can occur in transport networks if a service is explicitly one-way (a), or if the physical infrastructure is a one-way loop (c), like some city metro lines or ring roads.<br><b>Distractor Rationale:</b><ul><li>b) If the return journey is a different train, it would simply create a second, separate edge from j to i, resulting in a symmetric relationship (an edge in both directions), just represented by different labels.</li><li>d) Different distances don't prevent the existence of a return route; the graph would still be symmetric, just with different weights on the opposing edges.</li></ul>"
"What is the time complexity of finding all the immediate neighbors of a node i in an adjacency matrix representation of a graph with N nodes?<ul><li>a) O(1) - Constant time</li><li>b) O(log N) - Logarithmic time</li><li>c) O(N) - Linear time</li><li>d) O(N^2) - Quadratic time</li></ul>";"Correct: c)";"<b>Explanation:</b> To find all neighbors of node i, you must inspect every entry in the i-th row of the matrix. Since there are N columns in that row, you must perform N checks. Therefore, the time taken is directly proportional to the number of nodes, N.<br><b>Distractor Rationale:</b><ul><li>a) This is the complexity for checking a single edge, not finding all neighbors.</li><li>b) This complexity is typical of search algorithms on sorted data structures like binary search trees, not matrix row scans.</li><li>d) This is the complexity for iterating through the entire matrix, not just one row.</li></ul>"
"An adjacency matrix dist is used to store the shortest distance between stations. If there is no path between station i and j, how is this typically represented in the matrix?<ul><li>a) dist[i][j] = -1</li><li>b) dist[i][j] = 0</li><li>c) dist[i][j] = infinity (a very large number)</li><li>d) The entry is left blank</li></ul>";"Correct: c)";"<b>Explanation:</b> In shortest path algorithms like Floyd-Warshall, non-existent paths are initialized to infinity. This ensures that when a real path is found, its finite distance will always be less than infinity and will correctly become the new shortest path. Using 0 is problematic as it usually represents the distance from a node to itself, and -1 could be a valid weight in some graphs.<br><b>Distractor Rationale:</b><ul><li>a) -1 can be a valid edge weight and would interfere with algorithms that support negative weights.</li><li>b) 0 is the standard representation for the distance from a node to itself, not for a non-existent path to another node.</li><li>d) In a computational matrix, entries must have a value; they cannot be blank.</li></ul>"
"You have two graphs for a train network: G1 (nodes=stations, edges=direct routes) and G2 (nodes=trains, edges=shared stations). To find the fastest journey from Station A to Station C, which graph is more direct to use?<ul><li>a) G1, with edge weights representing travel time.</li><li>b) G2, with edge weights representing transfer times.</li><li>c) Both are equally direct and effective.</li><li>d) Neither can be used to find the fastest journey.</li></ul>";"Correct: a)";"<b>Explanation:</b> G1 directly models the journey between stations. By adding travel time as edge weights, you can apply a shortest path algorithm (like Dijkstra's) to find the fastest route between any two station nodes, A and C. G2 models transfers between trains and would be much more complex to use for finding station-to-station travel times.<br><b>Distractor Rationale:</b><ul><li>b) G2 is ideal for finding transfer possibilities, but not for calculating the total journey time between two stations.</li><li>c) G1 is significantly more direct for this specific problem.</li><li>d) G1 is perfectly suited for this task.</li></ul>"
"In a station-node graph, the procedure DirectDistance calculates the shortest direct distance between any two stations. If two trains run between station i and j with distances 800km and 850km, what will directdist[i][j] be after the procedure runs?<ul><li>a) 850</li><li>b) 800</li><li>c) 1650</li><li>d) A list [800, 850]</li></ul>";"Correct: b)";"<b>Explanation:</b> The DirectDistance procedure, as described in the lecture materials, iteratively updates the distance for a pair (i, j) by taking the minimum of the already stored distance and the distance of the new train being considered. It will ultimately store only the smallest value found.<br><b>Distractor Rationale:</b><ul><li>a) This is the longer distance.</li><li>c) This is the sum, not the minimum.</li><li>d) The procedure stores a single minimum value, not a list of all possible distances.</li></ul>"
"What is the key difference between calculating transitive closure for reachability (0/1) and calculating all-pairs shortest paths?<ul><li>a) Reachability uses addition, while shortest path uses logical OR.</li><li>b) Reachability uses logical OR, while shortest path uses addition and minimum operations.</li><li>c) There is no difference; they are the same algorithm.</li><li>d) Reachability applies to directed graphs, while shortest path applies to undirected graphs.</li></ul>";"Correct: b)";"<b>Explanation:</b> For reachability, a path exists if path(i,k) OR path(k,j). For shortest paths, the new path distance is dist(i,k) + dist(k,j), and this value is then compared to the existing distance using a min operation to see if the new path is better.<br><b>Distractor Rationale:</b><ul><li>a) This reverses the operations.</li><li>c) While related (Floyd-Warshall is a generalization of the transitive closure algorithm), they are not identical because the operations performed are different.</li><li>d) Both concepts apply to both directed and undirected graphs.</li></ul>"
"If you represent a train network with stations as nodes, how would you model a scenario where a train line is closed for maintenance between Station A and Station B?<ul><li>a) Remove the nodes for Station A and Station B.</li><li>b) Remove the edge(s) connecting the nodes for Station A and Station B.</li><li>c) Add a very high weight (infinity) to the edge between A and B.</li><li>d) Both b and c are valid methods.</li></ul>";"Correct: d)";"<b>Explanation:</b> Both methods achieve the same result for pathfinding algorithms. Removing the edge explicitly breaks the connection. Alternatively, setting the edge weight to infinity (a very large number) makes it a non-viable option for any shortest-path calculation, effectively removing it from consideration without altering the graph's structure.<br><b>Distractor Rationale:</b><ul><li>a) Removing the stations is incorrect, as other train lines to A and B might still be active.</li><li>b) While correct, it's not the only method.</li><li>c) While correct, it's not the only method.</li></ul>"
"Given a symmetric matrix cstn where cstn[i][j] is the number of common stations for trains i and j. What does sum = 0; foreach i in rows(cstn) { sum = sum + cstn[i][i] } calculate?<ul><li>a) The total number of unique stations in the dataset.</li><li>b) The total number of trains in the dataset.</li><li>c) The sum of the number of stations for each train.</li><li>d) The total number of pairs of trains that share at least one station.</li></ul>";"Correct: c)";"<b>Explanation:</b> The entry cstn[i][i] represents the number of common stations between train i and itself. This is simply the total number of stations on train i's route. The loop iterates through all trains and sums this value, effectively calculating the total number of station stops across all trains combined.<br><b>Distractor Rationale:</b><ul><li>a) This would overcount, as stations served by multiple trains would be added multiple times.</li><li>b) This is the number of iterations, not the value being summed.</li><li>d) This would require checking off-diagonal elements (cstn[i][j] where i != j).</li></ul>"
"You are building an edge-labeled graph where stations are nodes. Which piece of information would be an edge label, and which would be a node label?<ul><li>a) Edge: Station Name, Node: Train Number</li><li>b) Edge: Travel Time, Node: Station Name</li><li>c) Edge: Station Name, Node: Travel Time</li><li>d) Edge: Train Number, Node: IsHub (True/False)</li></ul>";"Correct: b)";"<b>Explanation:</b> Nodes represent the stations themselves, so their fundamental label is the Station Name. Edges represent the connection between stations, so properties of that connection, like Travel Time, Distance, or Train Number, are appropriate edge labels.<br><b>Distractor Rationale:</b><ul><li>a) This reverses the roles.</li><li>c) This reverses the roles.</li><li>d) IsHub is a property of a station (a node), not the connection between two stations.</li></ul>"
"In a graph representing connections between 100 stations, the transitive closure algorithm is run. At the 5th iteration, B[10][20] is 1. What does this signify?<ul><li>a) It is possible to go from station 10 to 20 in exactly 5 hops.</li><li>b) It is possible to go from station 10 to 20 using a path of length at most 5.</li><li>c) The shortest path from station 10 to 20 has 5 hops.</li><li>d) There are 5 different paths from station 10 to 20.</li></ul>";"Correct: b)";"<b>Explanation:</b> The iterative algorithm for transitive closure builds upon previous results. If B[10][20] is 1 after the 5th iteration, it means a path was found with 5 or fewer hops. It could have been found in an earlier iteration (e.g., a direct route, path of length 1) and its value was simply carried over, or it was just discovered in the 5th iteration.<br><b>Distractor Rationale:</b><ul><li>a) The algorithm finds paths of at most a certain length, not exactly that length.</li><li>c) This algorithm determines reachability, not the shortest path. A shorter path of 2 hops might exist.</li><li>d) The algorithm determines existence of a path, not the number of distinct paths.</li></ul>"
"You are given a directed, weighted graph of a train network where edge weights are travel times. Some weights are negative, representing time gained due to timezone changes. Which shortest-path algorithm would be most appropriate?<ul><li>a) Dijkstra's Algorithm</li><li>b) Bellman-Ford Algorithm</li><li>c) Breadth-First Search (BFS)</li><li>d) Depth-First Search (DFS)</li></ul>";"Correct: b)";"<b>Explanation:</b> Dijkstra's algorithm does not work correctly with negative edge weights. The Bellman-Ford algorithm is specifically designed to handle graphs with negative edge weights, making it the correct choice. BFS and DFS are for unweighted graphs.<br><b>Distractor Rationale:</b><ul><li>a) Dijkstra's algorithm can fail with negative weights because its greedy approach of assuming the shortest path found so far is final can be proven wrong by a later negative edge.</li><li>c) BFS finds the shortest path only in terms of the number of edges (for unweighted graphs).</li><li>d) DFS is not a shortest-path algorithm.</li></ul>"
"What does it mean if a train network graph contains a 'negative cycle' when edge weights represent cost?<ul><li>a) All train tickets are free.</li><li>b) There is a circular route that, if traveled, results in a net profit for the passenger.</li><li>c) It's impossible to travel between certain stations.</li><li>d) All routes in the network are one-way.</li></ul>";"Correct: b)";"<b>Explanation:</b> A negative cycle is a path that starts and ends at the same node, where the sum of the edge weights is negative. In the context of cost, this means a passenger could traverse the loop repeatedly and make money, as the 'cost' is negative. The concept of a shortest path becomes meaningless in such a graph, as one could traverse the cycle infinitely to achieve an infinitely low cost.<br><b>Distractor Rationale:</b><ul><li>a) This is an overstatement; only the cycle has a net negative cost.</li><li>c) A negative cycle doesn't necessarily imply disconnectedness.</li><li>d) A cycle requires paths to return to a node, which is the opposite of a purely one-way network.</li></ul>"
"In a train-node graph, Train A has an edge to Train B, and Train B has an edge to Train C. What does the transitive relationship imply?<ul><li>a) A passenger can plan a journey that involves transferring from Train A to Train B, and subsequently from Train B to Train C.</li><li>b) Train A and Train C share a common station.</li><li>c) Train A, B, and C all run on the same days of the week.</li><li>d) The journey from A to B to C is the fastest possible route.</li></ul>";"Correct: a)";"<b>Explanation:</b> The edges represent valid transfers. The sequence of edges A -> B -> C represents a valid sequence of transfers, forming a multi-hop journey. This is the essence of paths in a train-node graph.<br><b>Distractor Rationale:</b><ul><li>b) This is not necessarily true. A might connect to B at Station X, and B might connect to C at Station Y. A and C may never meet.</li><li>c) This is not guaranteed by the graph's structure.</li><li>d) The existence of the path says nothing about its optimality.</li></ul>"
"You have an adjacency matrix direct[i][j] that is 1 if a direct train exists, 0 otherwise. You compute onehop = direct * direct (matrix multiplication). What does onehop[i][j] > 0 signify?<ul><li>a) There is a path from i to j with at most one hop.</li><li>b) There is a path from i to j with exactly two hops.</li><li>c) There is a path from i to j with exactly one hop.</li><li>d) There is a path from i to j with an unknown number of hops.</li></ul>";"Correct: b)";"<b>Explanation:</b> Matrix multiplication C = A * B is defined as C[i][j] = sum(A[i][k] * B[k][j]) over all k. When multiplying direct by itself, onehop[i][j] will be the sum of direct[i][k] * direct[k][j]. This product is 1 only if both direct[i][k] and direct[k][j] are 1, meaning there is a path from i to k and k to j. The value of onehop[i][j] counts the number of intermediate stations k that form a two-hop path. If the value is greater than 0, at least one such path exists.<br><b>Distractor Rationale:</b><ul><li>a) This is incorrect; matrix multiplication specifically finds paths of length two in this case. It does not include paths of length one.</li><li>c) This is incorrect for the same reason as a).</li><li>d) The number of hops is exactly two.</li></ul>"
"A graph has N nodes. Its adjacency matrix M is multiplied by itself k times, resulting in M^k. What does a non-zero value at (M^k)[i][j] represent?<ul><li>a) The shortest path from i to j has length k.</li><li>b) There are (M^k)[i][j] distinct paths of length exactly k from node i to node j.</li><li>c) There is at least one path from i to j of length at most k.</li><li>d) The longest path from i to j has length k.</li></ul>";"Correct: b)";"<b>Explanation:</b> A well-known property of adjacency matrices is that the (i, j)-th entry of the k-th power of the matrix gives the number of different paths of length exactly k between nodes i and j. This is a direct extension of the two-hop path logic from the previous question.<br><b>Distractor Rationale:</b><ul><li>a) It counts the number of paths, not whether it's the shortest.</li><li>c) It counts paths of exactly length k, not at most length k.</li><li>d) It has no relation to the longest path.</li></ul>"
"To find if station j is reachable from station i (transitive closure), you can compute B = M + M^2 + M^3 + ... + M^(N-1), where M is the adjacency matrix. If B[i][j] > 0, a path exists. What is a more efficient way to compute this reachability matrix B?<ul><li>a) By using repeated squaring for matrix powers.</li><li>b) By using the iterative oneMoreHop (Floyd-Warshall/Warshall) algorithm.</li><li>c) Both a and b are efficient and common methods.</li><li>d) By manually checking every possible path.</li></ul>";"Correct: c)";"<b>Explanation:</b> Both are valid and more efficient than the naive summation. The iterative algorithm (b) builds paths of length h+1 from paths of length h and is conceptually straightforward. Repeated squaring (a) is a common technique to compute M^k quickly and can be adapted to find reachability by modifying the matrix multiplication operation to use logical OR instead of addition, which is very efficient.<br><b>Distractor Rationale:</b><ul><li>a) This is a correct method, but not the only one.</li><li>b) This is a correct method, but not the only one.</li><li>d) This is computationally infeasible for large graphs.</li></ul>"
"Consider a graph of student help, where an edge (i, j) means student i can help student j. The graph is directed and potentially cyclic (e.g., i helps j in Math, j helps i in Physics). What does finding the strongly connected components (SCCs) of this graph reveal?<ul><li>a) The student who can help the most other students.</li><li>b) Groups of students where every student in the group can, through some chain of help, get help from every other student in the same group.</li><li>c) The most difficult subject that no one can help with.</li><li>d) A single chain of students where each can only help the next one in the sequence.</li></ul>";"Correct: b)";"<b>Explanation:</b> A strongly connected component is a subgraph where for every pair of vertices u, v in the subgraph, there is a path from u to v and a path from v to u. In this context, it identifies self-sufficient 'help circles' or groups where knowledge can flow between any two members, possibly through intermediaries within the group.<br><b>Distractor Rationale:</b><ul><li>a) This would be found by looking for the node with the highest out-degree.</li><li>c) This is not information contained within the graph's structure.</li><li>d) This describes a simple path, not a strongly connected component.</li></ul>"
"What is the main purpose of using an 'edge-labeled' graph instead of a simple graph in the context of the trains dataset?<ul><li>a) To make the graph look more visually appealing.</li><li>b) To reduce the number of nodes in the graph.</li><li>c) To store additional information about the relationship between two nodes, such as distance, time, or train number.</li><li>d) To ensure the graph is always symmetric.</li></ul>";"Correct: c)";"<b>Explanation:</b> A simple graph only tells you if a connection exists (0 or 1). An edge-labeled (or weighted) graph allows you to store quantitative or qualitative data about that connection. This is essential for solving problems beyond simple reachability, such as finding the 'best' path based on criteria like time or distance.<br><b>Distractor Rationale:</b><ul><li>a) Visual appeal is not a computational goal.</li><li>b) It does not affect the number of nodes.</li><li>d) Labeling does not determine the symmetry of the graph's underlying connections.</li></ul>"
"If you are creating a matrix to represent a graph with N stations, what will the dimensions of the matrix be?<ul><li>a) N x 1</li><li>b) N x N</li><li>c) 2 x N</li><li>d) It depends on the number of trains.</li></ul>";"Correct: b)";"<b>Explanation:</b> An adjacency matrix represents all possible connections between every node and every other node. For N nodes (stations), this requires N rows and N columns, resulting in an N x N matrix.<br><b>Distractor Rationale:</b><ul><li>a) This is a vector, not a matrix for representing pairwise connections.</li><li>c) Incorrect dimensions.</li><li>d) The matrix size depends on the number of nodes (stations), not the number of edges (trains).</li></ul>"
"In the DirectRoutes procedure, a dictionary stnindex is created. What is its purpose?<ul><li>a) To store the names of all stations that are major hubs.</li><li>b) To map each station's name (a string) to a unique integer index (0 to N-1) for use in the adjacency matrix.</li><li>c) To count how many times each station appears in the dataset.</li><li>d) To store the geographical coordinates of each station.</li></ul>";"Correct: b)";"<b>Explanation:</b> Computer memory, particularly arrays and matrices, are accessed by integer indices. Since the data identifies stations by name (e.g., ""Kolkata""), a mapping is required to translate each unique name into a unique integer that can be used as a row or column index in the matrix.<br><b>Distractor Rationale:</b><ul><li>a) It maps all stations, not just hubs.</li><li>c) It assigns a unique index, it doesn't count occurrences.</li><li>d) It does not store geographical data.</li></ul>"
"When calculating onehopdist, the code initializes onehopdist[i][j] = directdist[i][j]. Why is this step crucial?<ul><li>a) It ensures that direct routes are considered as valid paths of length 'at most one hop'.</li><li>b) It converts all distances to 0.</li><li>c) It doubles all the direct distances.</li><li>d) It sorts the distances in ascending order.</li></ul>";"Correct: a)";"<b>Explanation:</b> The goal is to find the shortest path with at most one hop. This means a direct route (zero hops) is a valid candidate for the shortest path. This initialization step ensures that direct routes are included in the consideration and will be compared against any newly discovered one-hop routes.<br><b>Distractor Rationale:</b><ul><li>b) It copies the distances, it doesn't change them to 0.</li><li>c) It is a direct copy, not a multiplication.</li><li>d) It does not perform any sorting.</li></ul>"
"Which of the following problems can be solved using a simple, unweighted station-node graph?<ul><li>a) Finding the journey with the minimum travel time.</li><li>b) Finding the journey with the fewest number of train changes (hops).</li><li>c) Finding the cheapest journey.</li><li>d) Finding the journey that covers the least distance.</li></ul>";"Correct: b)";"<b>Explanation:</b> An unweighted graph treats every edge as having a uniform 'cost' of 1. Therefore, the shortest path in an unweighted graph is the one with the fewest edges. In a station-node graph, this corresponds to the path with the fewest hops or train changes. The other options require edge weights (time, cost, distance).<br><b>Distractor Rationale:</b><ul><li>a) Requires time as an edge weight.</li><li>c) Requires cost as an edge weight.</li><li>d) Requires distance as an edge weight.</li></ul>"
"In a train network graph where nodes are stations, if the graph is a 'clique' after computing direct routes, what does this mean?<ul><li>a) Every station is connected to every other station by a direct train.</li><li>b) The network forms a single straight line.</li><li>c) There is only one train in the entire network.</li><li>d) No station can be reached from any other station.</li></ul>";"Correct: a)";"<b>Explanation:</b> In graph theory, a clique is a subset of vertices where every two distinct vertices are adjacent. If the entire graph is a clique, it means every node is connected to every other node. In this context, it signifies a very well-connected network where a direct train exists for every possible pair of stations.<br><b>Distractor Rationale:</b><ul><li>b) A straight line (path graph) is sparsely connected; a clique is densely connected.</li><li>c) The number of trains is not determined by the graph being a clique.</li><li>d) This is the opposite of a clique; it describes a graph with no edges.</li></ul>"
"You are modeling train delays. A delay of 60 minutes at Station A causes a knock-on delay for a subsequent train at Station B. Which factor is essential for this propagation?<ul><li>a) The two trains must be the same color.</li><li>b) The two trains must travel on the same physical track segment between A and B.</li><li>c) Both stations must be in the same time zone.</li><li>d) The first train must have more passenger cars than the second.</li></ul>";"Correct: b)";"<b>Explanation:</b> Delays propagate physically. If two trains use the same track segment, one must wait for the other to clear it. This 'shared resource' is the mechanism for delay propagation between stations. Other factors are irrelevant to the physical constraint.<br><b>Distractor Rationale:</b><ul><li>a) Color is irrelevant.</li><li>c) Time zones affect time calculations but don't cause the physical delay propagation.</li><li>d) The number of cars is irrelevant to the track occupancy issue.</li></ul>"
"If you represent a train network as an adjacency matrix M, and M[i][j] stores the travel time, what does M[i][i] = 0 signify?<ul><li>a) It takes 0 minutes to travel from station i to itself.</li><li>b) There is no train that starts and ends at station i.</li><li>c) Station i is closed.</li><li>d) This is an error in the matrix.</li></ul>";"Correct: a)";"<b>Explanation:</b> The diagonal of an adjacency matrix represents the relationship of a node to itself. In a distance or time-weighted graph, the distance/time from a location to itself is always zero. This is a standard convention in graph algorithms.<br><b>Distractor Rationale:</b><ul><li>b) While true, the entry M[i][i]=0 specifically represents the travel time.</li><li>c) A closed station might be represented by removing the node or its edges, not by setting the diagonal to 0.</li><li>d) This is the correct and standard convention, not an error.</li></ul>"
"When would an adjacency list be a more memory-efficient representation for a graph than an adjacency matrix?<ul><li>a) When the graph is very dense (many edges).</li><li>b) When the graph is very sparse (few edges).</li><li>c) When the graph has negative edge weights.</li><li>d) When the number of nodes is very small.</li></ul>";"Correct: b)";"<b>Explanation:</b> An adjacency matrix always allocates memory for every possible edge (N*N). An adjacency list only stores the edges that actually exist. Therefore, for a sparse graph with far fewer edges than the possible maximum, the adjacency list uses significantly less memory.<br><b>Distractor Rationale:</b><ul><li>a) For dense graphs, an adjacency matrix is often more efficient in both space and time for edge lookups.</li><li>c) The choice of representation is independent of the edge weights.</li><li>d) For very small graphs, the difference is negligible, but the principle still holds that lists are better for sparsity.</li></ul>"
"You have a train-node graph where an edge represents a shared station. What does the 'degree' of a train node represent?<ul><li>a) The number of stations the train stops at.</li><li>b) The number of other distinct trains it connects with at one or more stations.</li><li>c) The speed of the train.</li><li>d) The number of days per week the train runs.</li></ul>";"Correct: b)";"<b>Explanation:</b> In any graph, the degree of a node is the number of edges connected to it. In a train-node graph, an edge is a connection to another train. Therefore, the degree of a train node is the count of other trains it has a transfer connection with.<br><b>Distractor Rationale:</b><ul><li>a) This is a property of the train's route, not its connectivity to other trains.</li><li>c) Speed is a property of the train, not its connectivity.</li><li>d) Frequency is a property of the train, not its connectivity.</li></ul>"
"Why is it important to handle the initialization of the min variable correctly in the ijMin procedure?<ul><li>a) To ensure the procedure returns the alphabetically first train name.</li><li>b) To establish a correct baseline for comparison, so the first actual distance found becomes the initial minimum.</li><li>c) To prevent division by zero errors.</li><li>d) To ensure the loop runs exactly N times.</li></ul>";"Correct: b)";"<b>Explanation:</b> The minimum-finding algorithm works by comparing each new value to the 'minimum found so far'. If the initial 'minimum' is not set to a valid first value from the dataset, the comparisons will be incorrect. Initializing it with the distance of the first train in the list ensures all subsequent comparisons are valid.<br><b>Distractor Rationale:</b><ul><li>a) The procedure finds minimum distance, not alphabetical order.</li><li>c) There is no division in this procedure.</li><li>d) The initialization does not affect the number of loop iterations.</li></ul>"
"If a train network graph is disconnected, what does this mean for its adjacency matrix representation after running a transitive closure algorithm?<ul><li>a) The matrix will be empty.</li><li>b) The matrix will contain at least one row that is all zeros.</li><li>c) The matrix will contain at least one row and one column i such that for some j, B[i][j] is 0.</li><li>d) The matrix will be symmetric.</li></ul>";"Correct: c)";"<b>Explanation:</b> A disconnected graph has at least two components, with no path between them. If node i is in component 1 and node j is in component 2, there is no path from i to j. Therefore, the reachability matrix B will have B[i][j] = 0. This implies there exists some row i that is not entirely filled with 1s.<br><b>Distractor Rationale:</b><ul><li>a) The matrix will not be empty; connections within components will be present.</li><li>b) A row being all zeros means that node cannot reach any other node, which is a specific type of disconnectedness (a sink node with no outgoing paths) but not the general definition.</li><li>d) Disconnectedness does not imply symmetry.</li></ul>"
"What is a 'path' in the context of a station-node graph?<ul><li>a) A single direct train route.</li><li>b) A sequence of one or more connected edges, representing a journey that may involve changing trains.</li><li>c) The list of all stations a single train passes through.</li><li>d) The physical railway track.</li></ul>";"Correct: b)";"<b>Explanation:</b> In graph theory, a path is a sequence of connected edges. In a station-node graph, each edge is a train segment. Therefore, a path represents a sequence of train segments that can be taken one after another to travel from a starting station to an ending station.<br><b>Distractor Rationale:</b><ul><li>a) A single direct route is a path of length 1, but a path can be longer.</li><li>c) This describes a route, which corresponds to multiple edges in the graph, but a path can span multiple trains.</li><li>d) A physical track is what the graph represents, not what a path is in the abstract model.</li></ul>"
"You are given a directed graph of a road network. To find all locations that are 'downstream' from a traffic jam at node X (i.e., all nodes reachable from X), which algorithm is most suitable?<ul><li>a) Dijkstra's Algorithm</li><li>b) Bellman-Ford Algorithm</li><li>c) Breadth-First Search (BFS) or Depth-First Search (DFS) starting from node X.</li><li>d) Floyd-Warshall Algorithm</li></ul>";"Correct: c)";"<b>Explanation:</b> This is a reachability problem: which nodes can be reached from a single source X? Both BFS and DFS are standard graph traversal algorithms designed to solve this exact problem efficiently. Dijkstra's, Bellman-Ford, and Floyd-Warshall are for finding shortest paths, which is more information than is required.<br><b>Distractor Rationale:</b><ul><li>a) Overkill; this finds shortest paths, not just reachability.</li><li>b) Overkill and less efficient than BFS/DFS for this task.</li><li>d) Overkill; this finds all-pairs reachability, but we only need it from a single source X.</li></ul>"
"If direct[i][j] is an edge-labeled dictionary containing train numbers, and you want to find the number of distinct direct trains from i to j, what pseudocode would you use?<ul><li>a) count = direct[i][j]</li><li>b) count = length(keys(direct[i][j]))</li><li>c) count = 0; foreach t in direct[i][j] { count = count + 1 }</li><li>d) Both b and c are correct.</li></ul>";"Correct: d)";"<b>Explanation:</b> direct[i][j] is a dictionary where each key is a unique train. length(keys(...)) directly returns the number of keys, which is the number of distinct trains. The foreach loop in option (c) also iterates over all keys and increments a counter, achieving the same result. Both are valid ways to count the elements.<br><b>Distractor Rationale:</b><ul><li>a) This attempts to assign a dictionary to a number, which is a type error.</li></ul>"
"A graph where it's possible to get from any node to any other node is called:<ul><li>a) A strongly connected graph</li><li>b) A complete graph (clique)</li><li>c) A cyclic graph</li><li>d) A weighted graph</li></ul>";"Correct: a)";"<b>Explanation:</b> 'Strongly connected' is the formal term for a directed graph in which there is a path from every node to every other node. This implies that the transitive closure matrix would be entirely filled with 1s.<br><b>Distractor Rationale:</b><ul><li>b) A complete graph means every node has a direct edge to every other node. Strong connectivity only requires a path, which could have multiple hops.</li><li>c) A graph can be cyclic without being strongly connected (e.g., two separate cycles).</li><li>d) Weightedness is a property of the edges, not the overall connectivity.</li></ul>"
"In the pseudocode if (direct[i][k] == 1 and direct[k][j] == 1), what is the role of the intermediate station k?<ul><li>a) It is the final destination of the journey.</li><li>b) It is a transfer point, connecting a route from i to a route to j.</li><li>c) It is the station with the highest number of connections.</li><li>d) It is guaranteed to be halfway between i and j.</li></ul>";"Correct: b)";"<b>Explanation:</b> This conditional statement is the core of pathfinding. It checks for a two-segment path from i to j. The node k is the crucial link or transfer point where the first segment (i to k) ends and the second segment (k to j) begins.<br><b>Distractor Rationale:</b><ul><li>a) j is the final destination.</li><li>c) Its role is purely as an intermediary in this specific path; it says nothing about its overall importance.</li><li>d) There is no guarantee of its position.</li></ul>"
"If a graph is undirected, what property will its adjacency matrix M always have?<ul><li>a) All diagonal entries M[i][i] will be 1.</li><li>b) The matrix will be symmetric (M[i][j] == M[j][i] for all i, j).</li><li>c) The matrix will only contain 0s and 1s.</li><li>d) The matrix will be sparse.</li></ul>";"Correct: b)";"<b>Explanation:</b> An undirected edge between i and j means that travel is possible in both directions. In the matrix representation, this means if there is a connection from i to j (M[i][j] is non-zero), there must also be a connection from j to i (M[j][i] is non-zero and equal if weights are symmetric). This makes the matrix symmetric across its main diagonal.<br><b>Distractor Rationale:</b><ul><li>a) Diagonal entries are typically 0 unless self-loops are explicitly allowed and meaningful.</li><li>c) The graph could be weighted, so the matrix could contain other numbers.</li><li>d) The graph could be dense (a clique).</li></ul>"
"You are creating a graph to model dependencies for a large project (Task A must be done before Task B). What do the nodes and directed edges represent?<ul><li>a) Nodes = Project Managers, Edges = Communication</li><li>b) Nodes = Tasks, Edges = Precedence constraints (A -> B means A must finish before B starts)</li><li>c) Nodes = Days, Edges = Tasks scheduled for that day</li><li>d) Nodes = Tasks, Edges = Team members assigned to the task</li></ul>";"Correct: b)";"<b>Explanation:</b> This is a classic application of directed graphs called a dependency graph or precedence graph. Each node is a task to be completed. A directed edge A -> B represents the constraint that task A is a prerequisite for task B.<br><b>Distractor Rationale:</b><ul><li>a) This models the organizational structure, not the project workflow.</li><li>c) This is a possible but less direct way to model the schedule.</li><li>d) This assigns resources but doesn't capture the critical time-based dependencies between tasks.</li></ul>"
"What is a 'topological sort' of a task dependency graph (a directed acyclic graph)?<ul><li>a) A list of all tasks sorted by their estimated cost.</li><li>b) A linear ordering of tasks such that for every dependency A -> B, task A comes before task B in the ordering.</li><li>c) A list of tasks sorted by the number of dependencies they have.</li><li>d) A list of the most critical tasks that must be done first.</li></ul>";"Correct: b)";"<b>Explanation:</b> A topological sort provides a valid sequence for executing the tasks. It ensures that by the time you get to any task in the sequence, all of its prerequisites have already appeared earlier in the sequence. This is fundamental for project scheduling.<br><b>Distractor Rationale:</b><ul><li>a) This is sorting by a weight, not by dependency.</li><li>c) This is sorting by a node property (in-degree), which is part of the algorithm but not the definition of the output.</li><li>d) While it identifies the starting tasks (those with no prerequisites), it doesn't provide the full valid sequence for all tasks.</li></ul>"
"A topological sort is NOT possible on a graph if and only if:<ul><li>a) The graph is disconnected.</li><li>b) The graph is weighted.</li><li>c) The graph contains at least one cycle.</li><li>d) The graph has more than one node with no incoming edges.</li></ul>";"Correct: c)";"<b>Explanation:</b> A topological sort requires a linear ordering of nodes based on precedence. If a cycle exists (e.g., A -> B -> C -> A), it creates a logical impossibility: A must come before B, B before C, and C before A. No linear ordering can satisfy this. Therefore, a topological sort can only be performed on a Directed Acyclic Graph (DAG).<br><b>Distractor Rationale:</b><ul><li>a) A disconnected graph can be topologically sorted (the sort would be a concatenation of the sorts of its components).</li><li>b) Edge weights are irrelevant to the logical dependencies.</li><li>d) Having multiple starting points is perfectly fine and common in project graphs.</li></ul>"
"In the context of the student scores dataset, you create a directed graph where an edge i -> j means i scored significantly higher than j. What would a long path a -> b -> c -> d in this graph represent?<ul><li>a) A group of four students with identical scores.</li><li>b) A clear hierarchy or ranking of students based on performance.</li><li>c) A cycle of students who all help each other.</li><li>d) The four students who are failing the course.</li></ul>";"Correct: b)";"<b>Explanation:</b> The directed edges represent a 'better than' relationship. A long path strings these relationships together, showing that a is better than b, who is better than c, who is better than d. This reveals a performance hierarchy among that group of students.<br><b>Distractor Rationale:</b><ul><li>a) This is the opposite of what the edges represent.</li><li>c) A path is not a cycle unless it returns to its starting point.</li><li>d) The graph represents relative performance, not absolute scores against a passing threshold.</li></ul>"
"What is an 'adjacency list' representation of a graph?<ul><li>a) A square matrix where M[i,j] indicates an edge.</li><li>b) A list of all the nodes in the graph.</li><li>c) An array or dictionary where each index i corresponds to a node, and the value at that index is a list of the nodes adjacent to i.</li><li>d) A list of all the edges, stored as pairs of nodes.</li></ul>";"Correct: c)";"<b>Explanation:</b> This is the definition of an adjacency list. It maps each node to a list of its direct neighbors. For example, Adj[A] = [B, D] means node A has direct edges to nodes B and D.<br><b>Distractor Rationale:</b><ul><li>a) This describes an adjacency matrix.</li><li>b) This is just a list of vertices, containing no edge information.</li><li>d) This is a valid representation called an 'edge list', but it's different from an adjacency list.</li></ul>"
"You have a graph of a city's water pipe system, with nodes as junctions and edges as pipes. Edge weights represent the maximum water flow capacity. What does finding the 'maximum flow' from a source (reservoir) to a sink (a neighborhood) tell you?<ul><li>a) The shortest path for a water molecule to travel.</li><li>b) The total amount of water stored in the reservoir.</li><li>c) The maximum rate at which water can be delivered to the neighborhood without exceeding the capacity of any pipe.</li><li>d) The number of junctions in the system.</li></ul>";"Correct: c)";"<b>Explanation:</b> The max-flow min-cut theorem is a fundamental concept in graph theory that solves this problem. It finds the greatest possible flow from a source to a sink, respecting the capacity constraints of all edges in the network. It's widely used in logistics, networking, and utility management.<br><b>Distractor Rationale:</b><ul><li>a) This is a shortest path problem, not a flow problem.</li><li>b) This is a property of the source node, not the network's capacity.</li><li>d) This is a simple count of nodes.</li></ul>"
"In a social network graph, what does the 'distance' between two nodes (people) typically represent?<ul><li>a) The geographical distance between them.</li><li>b) The difference in their ages.</li><li>c) The length of the shortest path (number of 'friend of a friend' connections) between them.</li><li>d) The number of friends they have in common.</li></ul>";"Correct: c)";"<b>Explanation:</b> 'Distance' in unweighted graphs is defined as the number of edges in the shortest path between two nodes. In a social network, this translates to the 'degrees of separation'how many intermediate people are needed to connect two individuals.<br><b>Distractor Rationale:</b><ul><li>a) This is geographic data, not graph-theoretic distance.</li><li>b) This is a difference in node attributes.</li><li>d) This is a measure of neighborhood overlap, often used in link prediction, but it is not the definition of graph distance.</li></ul>"
