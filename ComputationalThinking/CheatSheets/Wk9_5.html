<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L9.5: Pseudocodes for real-time examples using graphs</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the active link in the sidebar */
        .sidebar-link.active {
            background-color: #3b82f6; /* bg-blue-600 */
            color: white;
            font-weight: 600;
        }
        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; /* bg-slate-100 */
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* bg-slate-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* bg-slate-500 */
        }
        /* Ensure the main content can scroll independently */
        main {
            height: 100vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div id="app-container" class="relative min-h-screen md:flex">
        <!-- Mobile Header -->
        <div class="bg-white md:hidden flex justify-between items-center p-4 border-b border-slate-200 sticky top-0 z-30">
            <h1 class="text-lg font-bold text-blue-600">Graph Guide</h1>
            <button id="hamburger-btn" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
            </button>
        </div>

        <!-- Sidebar -->
        <aside id="sidebar" class="bg-white text-slate-700 w-64 space-y-2 py-7 px-2 fixed inset-y-0 left-0 transform -translate-x-full md:translate-x-0 transition-transform duration-300 ease-in-out z-40 border-r border-slate-200 flex-shrink-0">
            <div class="px-4 mb-4">
                <h1 class="text-xl font-bold text-blue-600">Learning Guide</h1>
                <p class="text-sm text-slate-500 mt-1">Graphs & Pseudocode</p>
            </div>
            <nav id="sidebar-nav">
                <a href="#introduction" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">Introduction</a>
                <a href="#what-is-a-graph" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">What is a Graph?</a>
                <a href="#representing-graphs" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">Representing Graphs</a>
                <a href="#clique-problem" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">The Clique Problem</a>
                <a href="#interactive-clique-finder" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">Interactive Clique Finder</a>
                <a href="#finding-a-path" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">Finding a Path</a>
                <a href="#pseudocode" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">Pseudocode Examples</a>
                <a href="#quiz" class="sidebar-link block rounded-md px-4 py-2.5 text-sm font-medium hover:bg-blue-500 hover:text-white transition-colors duration-150">Knowledge Check</a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 p-4 sm:p-6 md:p-10 md:ml-64">
            <div class="max-w-4xl mx-auto space-y-12">

                <!-- Introduction Section -->
                <section id="introduction" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">Welcome!</h2>
                    <div class="space-y-4 text-lg text-slate-600">
                        <p>Hello there! Welcome to this guide on graphs. If you've ever wondered how social networks suggest friends, or how GPS finds the best route, you've come to the right place. Many of these real-world problems use graphs to find solutions.</p>
                        <p>We'll break down the key ideas in a simple, friendly way. We'll start with the basics, look at a fun problem called the "clique problem," and even play with an interactive tool. By the end, you'll be able to understand and even write simple instructions (pseudocode) for working with graphs. Let's get started!</p>
                    </div>
                </section>

                <!-- What is a Graph? Section -->
                <section id="what-is-a-graph" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">What is a Graph?</h2>
                    <div class="space-y-4 text-lg text-slate-600">
                        <p>Imagine a drawing with a bunch of dots and lines connecting them. That's basically a graph! In computer science, we use more formal terms:</p>
                        <ul class="list-disc list-inside space-y-2 pl-4">
                            <li>The dots are called <strong class="text-blue-600">vertices</strong> (or nodes). A single dot is a <strong class="text-blue-600">vertex</strong>.</li>
                            <li>The lines connecting the dots are called <strong class="text-blue-600">edges</strong>.</li>
                        </ul>
                        <p>Think of a social network: each person is a vertex, and a "friendship" is an edge connecting two people. In this guide, we'll focus on <strong class="text-blue-600">undirected graphs</strong>, where edges are two-way streets. If Alice is friends with Bob, Bob is also friends with Alice.</p>
                        <p>When two vertices are connected by an edge, we say they are <strong class="text-blue-600">adjacent</strong>. So, if there's an edge between Alice and Bob, they are adjacent.</p>
                    </div>
                </section>

                <!-- Representing Graphs Section -->
                <section id="representing-graphs" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">Representing Graphs</h2>
                    <div class="space-y-4 text-lg text-slate-600">
                        <p>How do we tell a computer about a graph? We can't just show it a drawing. One common way is using an <strong class="text-blue-600">adjacency matrix</strong>. It's just a grid (like a spreadsheet) where we keep track of which vertices are connected.</p>
                        <p>Let's say we have 4 people: 1 (Alice), 2 (Bob), 3 (Charlie), 4 (Dana). We make a 4x4 grid. If there's an edge between two people, we put a '1' in the grid where their row and column meet. Otherwise, we put a '0'.</p>
                        <div class="bg-white p-4 rounded-lg shadow-md overflow-x-auto">
                            <table class="min-w-full text-center">
                                <thead>
                                    <tr>
                                        <th class="p-2"></th>
                                        <th class="p-2 font-bold text-blue-700">1</th>
                                        <th class="p-2 font-bold text-blue-700">2</th>
                                        <th class="p-2 font-bold text-blue-700">3</th>
                                        <th class="p-2 font-bold text-blue-700">4</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="p-2 font-bold text-blue-700">1</td>
                                        <td class="p-2 bg-slate-200">0</td>
                                        <td class="p-2 bg-green-100">1</td>
                                        <td class="p-2 bg-green-100">1</td>
                                        <td class="p-2 bg-red-100">0</td>
                                    </tr>
                                    <tr>
                                        <td class="p-2 font-bold text-blue-700">2</td>
                                        <td class="p-2 bg-green-100">1</td>
                                        <td class="p-2 bg-slate-200">0</td>
                                        <td class="p-2 bg-green-100">1</td>
                                        <td class="p-2 bg-red-100">0</td>
                                    </tr>
                                    <tr>
                                        <td class="p-2 font-bold text-blue-700">3</td>
                                        <td class="p-2 bg-green-100">1</td>
                                        <td class="p-2 bg-green-100">1</td>
                                        <td class="p-2 bg-slate-200">0</td>
                                        <td class="p-2 bg-green-100">1</td>
                                    </tr>
                                    <tr>
                                        <td class="p-2 font-bold text-blue-700">4</td>
                                        <td class="p-2 bg-red-100">0</td>
                                        <td class="p-2 bg-red-100">0</td>
                                        <td class="p-2 bg-green-100">1</td>
                                        <td class="p-2 bg-slate-200">0</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p>This matrix tells us, for example, that vertex 1 is connected to 2 and 3, but not 4.</p>
                    </div>
                </section>

                <!-- The Clique Problem Section -->
                <section id="clique-problem" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">Finding Friends: The Clique Problem</h2>
                    <div class="space-y-4 text-lg text-slate-600">
                        <p>In a social network, a <strong class="text-blue-600">clique</strong> (pronounced "kleek") is a group of people who are all friends with each other. Everyone in the group knows everyone else.</p>
                        <p>For example, if Alice, Bob, and Charlie form a clique, it means:</p>
                        <ul class="list-disc list-inside space-y-2 pl-4">
                            <li>Alice is friends with Bob AND Charlie.</li>
                            <li>Bob is friends with Alice AND Charlie.</li>
                            <li>Charlie is friends with Alice AND Bob.</li>
                        </ul>
                        <p>Identifying cliques is useful in many areas, from social science to network analysis. The "clique problem" is the challenge of finding these tightly-knit groups within a larger graph.</p>
                    </div>
                </section>

                <!-- Interactive Clique Finder Section -->
                <section id="interactive-clique-finder" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">Interactive Clique Finder</h2>
                    <div class="bg-white p-6 rounded-lg shadow-lg">
                        <p class="text-lg text-slate-600 mb-4">Let's try it! Below is a graph of people (nodes). Click on nodes to select them. Then, click the button to check if your selected group forms a clique.</p>
                        <div class="bg-slate-100 rounded-lg p-2">
                           <canvas id="clique-canvas" class="w-full h-80 md:h-96 rounded-md cursor-pointer"></canvas>
                        </div>
                        <div class="mt-4 flex flex-col sm:flex-row items-center justify-between gap-4">
                            <button id="check-clique-btn" class="w-full sm:w-auto bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors duration-200 shadow-md">Check if Clique</button>
                            <button id="reset-clique-btn" class="w-full sm:w-auto bg-slate-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-600 transition-colors duration-200">Reset Selection</button>
                        </div>
                        <div id="clique-result" class="mt-4 p-4 rounded-lg text-center font-semibold text-lg hidden"></div>
                    </div>
                </section>

                <!-- Finding a Path Section -->
                <section id="finding-a-path" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">Finding a Path</h2>
                    <div class="space-y-4 text-lg text-slate-600">
                        <p>Another common task is to see if you can get from one vertex to another by following the edges. This sequence of edges is called a <strong class="text-blue-600">path</strong>.</p>
                        <p>Think of it like a series of connecting flights. Can you get from New York to Los Angeles? A path exists if there's a sequence of flights (edges) that connect airports (vertices) to get you there.</p>
                        <p>The "path existence" problem simply asks: is there *any* path, long or short, between a starting vertex and a destination vertex? We don't need the shortest path, just whether one exists at all.</p>
                    </div>
                </section>

                <!-- Pseudocode Section -->
                <section id="pseudocode" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">Pseudocode Examples</h2>
                    <div class="space-y-8">
                        <div>
                            <h3 class="text-2xl font-semibold text-slate-800 mb-2">1. Checking for Adjacency (A Building Block)</h3>
                            <p class="text-lg text-slate-600 mb-4">Before we can check for complex things like cliques, we need a basic tool: a way to see if two vertices are connected. This function looks up the connection in the adjacency matrix.</p>
                            <div class="bg-slate-800 text-white p-4 rounded-lg shadow-lg font-mono text-sm overflow-x-auto">
                                <pre><code class="language-pseudocode">
FUNCTION areAdjacent(graph, vertex1, vertex2):
  // The graph is represented by an adjacency matrix.
  // We check the grid at the row for vertex1 and column for vertex2.
  IF graph.matrix[vertex1][vertex2] is 1:
    RETURN TRUE
  ELSE:
    RETURN FALSE
                                </code></pre>
                            </div>
                        </div>

                        <div>
                            <h3 class="text-2xl font-semibold text-slate-800 mb-2">2. Checking for a Clique</h3>
                            <p class="text-lg text-slate-600 mb-4">Now, here's how we could write instructions to check if a group of vertices is a clique. It uses our `areAdjacent` function repeatedly.</p>
                            <div class="bg-slate-800 text-white p-4 rounded-lg shadow-lg font-mono text-sm overflow-x-auto">
                                <pre><code class="language-pseudocode">
FUNCTION isClique(graph, group_of_vertices):
  // Loop through every vertex in the group
  FOR each vertex 'v' in group_of_vertices:
    // Loop through every OTHER vertex in the group
    FOR each vertex 'u' in group_of_vertices:
      // We don't need to check a vertex against itself
      IF v is the same as u:
        CONTINUE to next vertex
      
      // Check if there is an edge between v and u
      // This uses the helper function we defined above!
      IF areAdjacent(graph, v, u) is FALSE:
        // If even one pair is not connected, it's not a clique
        RETURN FALSE
  
  // If we finish all loops without finding a missing edge, it's a clique!
  RETURN TRUE
                                </code></pre>
                            </div>
                        </div>

                        <div>
                            <h3 class="text-2xl font-semibold text-slate-800 mb-2">3. Checking if a Path Exists</h3>
                            <p class="text-lg text-slate-600 mb-4">This pseudocode describes a way to find if a path exists between a `startNode` and an `endNode`. It uses a common strategy called Breadth-First Search (BFS).</p>
                            <div class="bg-slate-800 text-white p-4 rounded-lg shadow-lg font-mono text-sm overflow-x-auto">
                                <pre><code class="language-pseudocode">
FUNCTION pathExists(graph, startNode, endNode):
  // A queue to hold nodes we need to visit
  queue = a new Queue
  // A set to remember nodes we've already seen
  visited = a new Set

  // Start by adding the first node to the queue and visited set
  add startNode to queue
  add startNode to visited

  // Keep going as long as there are nodes to visit
  WHILE queue is not empty:
    currentNode = remove first item from queue

    // Did we find our destination?
    IF currentNode is endNode:
      RETURN TRUE // Yes, a path exists!

    // Look at all neighbors of the current node
    FOR each neighbor of currentNode:
      IF neighbor has not been visited:
        add neighbor to visited
        add neighbor to queue

  // If the queue becomes empty and we haven't found the endNode...
  RETURN FALSE // No path exists
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Quiz Section -->
                <section id="quiz" class="scroll-mt-20">
                    <h2 class="text-3xl font-bold text-slate-900 border-b-4 border-blue-500 pb-2 mb-4">Knowledge Check</h2>
                    <div id="quiz-container" class="space-y-8">
                        <!-- Quiz questions will be injected here by JavaScript -->
                    </div>
                </section>

            </div>
        </main>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Mobile Sidebar Logic ---
        const hamburgerBtn = document.getElementById('hamburger-btn');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.querySelector('main');

        hamburgerBtn.addEventListener('click', () => {
            sidebar.classList.toggle('-translate-x-full');
        });

        // Close sidebar when a link is clicked on mobile
        sidebar.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                if (window.innerWidth < 768) { // md breakpoint
                    sidebar.classList.add('-translate-x-full');
                }
            });
        });

        // --- Active Sidebar Link Highlighting ---
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('#sidebar-nav a');

        const observerOptions = {
            root: mainContent, // Use the main content area as the scroll root
            rootMargin: '0px 0px -50% 0px', // Adjust margin to highlight earlier
            threshold: 0
        };

        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                const id = entry.target.getAttribute('id');
                const navLink = document.querySelector(`#sidebar-nav a[href="#${id}"]`);
                if (entry.isIntersecting) {
                    navLinks.forEach(link => link.classList.remove('active'));
                    if(navLink) navLink.classList.add('active');
                }
            });
        }, observerOptions);

        sections.forEach(section => {
            observer.observe(section);
        });

        // --- Interactive Clique Finder Logic ---
        const canvas = document.getElementById('clique-canvas');
        const ctx = canvas.getContext('2d');
        const checkBtn = document.getElementById('check-clique-btn');
        const resetBtn = document.getElementById('reset-clique-btn');
        const resultDiv = document.getElementById('clique-result');

        // Graph data: nodes and adjacency matrix
        const nodes = [
            { id: 0, name: 'A', x: 10, y: 50 },
            { id: 1, name: 'B', x: 40, y: 10 },
            { id: 2, name: 'C', x: 70, y: 50 },
            { id: 3, name: 'D', x: 40, y: 90 },
            { id: 4, name: 'E', x: 90, y: 15 },
            { id: 5, name: 'F', x: 90, y: 85 },
        ];

        const adjacencyMatrix = [
            // A  B  C  D  E  F
            [0, 1, 1, 1, 0, 0], // A
            [1, 0, 1, 0, 0, 0], // B
            [1, 1, 0, 1, 0, 1], // C
            [1, 0, 1, 0, 0, 0], // D
            [0, 0, 0, 0, 0, 1], // E
            [0, 0, 1, 0, 1, 0], // F
        ];

        let selectedNodes = new Set();
        const nodeRadius = 18;

        function drawGraph() {
            // Adjust canvas size to its container
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scaleX = canvas.width / 100;
            const scaleY = canvas.height / 100;

            // Draw edges
            ctx.strokeStyle = '#94a3b8'; // slate-400
            ctx.lineWidth = 2;
            for (let i = 0; i < adjacencyMatrix.length; i++) {
                for (let j = i; j < adjacencyMatrix[i].length; j++) {
                    if (adjacencyMatrix[i][j] === 1) {
                        const startNode = nodes[i];
                        const endNode = nodes[j];
                        ctx.beginPath();
                        ctx.moveTo(startNode.x * scaleX, startNode.y * scaleY);
                        ctx.lineTo(endNode.x * scaleX, endNode.y * scaleY);
                        ctx.stroke();
                    }
                }
            }

            // Draw nodes
            nodes.forEach(node => {
                const x = node.x * scaleX;
                const y = node.y * scaleY;
                
                ctx.beginPath();
                ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
                
                if (selectedNodes.has(node.id)) {
                    ctx.fillStyle = '#3b82f6'; // blue-600
                    ctx.strokeStyle = '#1e40af'; // blue-800
                    ctx.lineWidth = 4;
                } else {
                    ctx.fillStyle = '#f1f5f9'; // slate-100
                    ctx.strokeStyle = '#64748b'; // slate-500
                    ctx.lineWidth = 2;
                }
                
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = selectedNodes.has(node.id) ? 'white' : '#1e293b'; // slate-900
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.name, x, y);
            });
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / 100;
            const scaleY = canvas.height / 100;
            
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            let clickedNode = null;
            nodes.forEach(node => {
                const nodeX = node.x * scaleX;
                const nodeY = node.y * scaleY;
                const distance = Math.sqrt((x - nodeX) ** 2 + (y - nodeY) ** 2);
                if (distance < nodeRadius) {
                    clickedNode = node;
                }
            });

            if (clickedNode) {
                if (selectedNodes.has(clickedNode.id)) {
                    selectedNodes.delete(clickedNode.id);
                } else {
                    selectedNodes.add(clickedNode.id);
                }
                resultDiv.classList.add('hidden');
                drawGraph();
            }
        }

        function checkClique() {
            if (selectedNodes.size < 2) {
                showResult('Please select at least 2 nodes.', 'info');
                return;
            }

            const selectedArray = Array.from(selectedNodes);
            let isClique = true;
            for (let i = 0; i < selectedArray.length; i++) {
                for (let j = i + 1; j < selectedArray.length; j++) {
                    const node1 = selectedArray[i];
                    const node2 = selectedArray[j];
                    if (adjacencyMatrix[node1][node2] === 0) {
                        isClique = false;
                        break;
                    }
                }
                if (!isClique) break;
            }

            if (isClique) {
                showResult('Yes! This is a clique. Well done!', 'success');
            } else {
                showResult('Not a clique. Remember, every node must be connected to every other node in the group.', 'error');
            }
        }
        
        function showResult(message, type) {
            resultDiv.textContent = message;
            resultDiv.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-blue-100', 'text-blue-800');
            if (type === 'success') {
                resultDiv.classList.add('bg-green-100', 'text-green-800');
            } else if (type === 'error') {
                resultDiv.classList.add('bg-red-100', 'text-red-800');
            } else {
                resultDiv.classList.add('bg-blue-100', 'text-blue-800');
            }
        }

        function resetClique() {
            selectedNodes.clear();
            resultDiv.classList.add('hidden');
            drawGraph();
        }

        // Initial setup
        drawGraph();
        window.addEventListener('resize', drawGraph);
        canvas.addEventListener('click', handleCanvasClick);
        checkBtn.addEventListener('click', checkClique);
        resetBtn.addEventListener('click', resetClique);

        // --- Quiz Logic ---
        const quizContainer = document.getElementById('quiz-container');
        const quizData = [
            {
                question: "In a graph representing a social network, what do the vertices typically represent?",
                options: ["Friendships", "People", "Likes", "Events"],
                answer: "People",
                explanation: "Vertices (or nodes) are the individual items in a graph. In a social network, these are the people or user accounts."
            },
            {
                question: "What is a clique in an undirected graph?",
                options: [
                    "A group of vertices where at least one is connected to all others.",
                    "The longest path in the graph.",
                    "A group of vertices where every vertex is adjacent to every other vertex in the group.",
                    "A vertex with the most edges."
                ],
                answer: "A group of vertices where every vertex is adjacent to every other vertex in the group.",
                explanation: "A clique is a fully connected subgroup. Everyone in the clique is directly connected to everyone else."
            },
            {
                question: "If two vertices are connected by an edge, they are said to be:",
                options: ["Adjacent", "A path", "A matrix", "A clique"],
                answer: "Adjacent",
                explanation: "Adjacency is the term for two vertices being direct neighbors, connected by a single edge."
            },
            {
                question: "What does the pseudocode function `isClique` return if it finds even one pair of vertices in the group that are NOT connected?",
                options: ["TRUE", "The pair of vertices", "An error", "FALSE"],
                answer: "FALSE",
                explanation: "The definition of a clique is strict. If even one connection is missing, the entire group fails the test, so the function immediately returns FALSE."
            }
        ];

        function buildQuiz() {
            quizData.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'bg-white p-6 rounded-lg shadow-md';

                const questionText = document.createElement('p');
                questionText.className = 'text-lg font-semibold text-slate-800 mb-4';
                questionText.textContent = `${index + 1}. ${q.question}`;
                questionDiv.appendChild(questionText);

                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'space-y-3';
                questionDiv.appendChild(optionsDiv);

                q.options.forEach(option => {
                    const optionBtn = document.createElement('button');
                    optionBtn.className = 'block w-full text-left p-3 rounded-md bg-slate-100 hover:bg-slate-200 transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-blue-400';
                    optionBtn.textContent = option;
                    optionBtn.addEventListener('click', () => checkAnswer(q, optionBtn, optionsDiv));
                    optionsDiv.appendChild(optionBtn);
                });

                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'mt-4 p-3 rounded-md text-sm hidden';
                questionDiv.appendChild(feedbackDiv);

                quizContainer.appendChild(questionDiv);
            });
        }

        function checkAnswer(questionData, selectedButton, optionsContainer) {
            // Disable all buttons for this question after an answer is selected
            optionsContainer.querySelectorAll('button').forEach(btn => btn.disabled = true);

            const feedbackDiv = selectedButton.parentElement.nextElementSibling;
            const isCorrect = selectedButton.textContent === questionData.answer;

            if (isCorrect) {
                selectedButton.classList.remove('bg-slate-100', 'hover:bg-slate-200');
                selectedButton.classList.add('bg-green-500', 'text-white', 'font-semibold');
                feedbackDiv.classList.remove('hidden');
                feedbackDiv.classList.add('bg-green-100', 'text-green-800');
                feedbackDiv.innerHTML = `<strong class="font-bold">Correct!</strong> ${questionData.explanation}`;
            } else {
                selectedButton.classList.remove('bg-slate-100', 'hover:bg-slate-200');
                selectedButton.classList.add('bg-red-500', 'text-white', 'font-semibold');
                feedbackDiv.classList.remove('hidden');
                feedbackDiv.classList.add('bg-red-100', 'text-red-800');
                feedbackDiv.innerHTML = `<strong class="font-bold">Not quite.</strong> The correct answer is <strong class="underline">${questionData.answer}</strong>. ${questionData.explanation}`;
                
                // Also highlight the correct answer
                optionsContainer.querySelectorAll('button').forEach(btn => {
                    if (btn.textContent === questionData.answer) {
                        btn.classList.remove('bg-slate-100', 'hover:bg-slate-200');
                        btn.classList.add('bg-green-500', 'text-white', 'font-semibold');
                    }
                });
            }
        }

        buildQuiz();
    });
    </script>
</body>
</html>
<!--
Learning Guide Compliance Report

Overall Assessment: Learning Objective Compliance: PASS

Justification Checklist:

✔ What is a graph (vertices, edges)? Covered: Yes - Explained in the 'What is a Graph?' section with simple analogies. Tested in the first quiz question.
✔ What is an undirected graph? Covered: Yes - Mentioned and defined in the 'What is a Graph?' section. The entire guide operates on this assumption.
✔ What does it mean for vertices to be adjacent? Covered: Yes - Defined in the 'What is a Graph?' section and tested in the third quiz question.
✔ How to represent a graph (adjacency matrix)? Covered: Yes - Explained with a clear table example in the 'Representing Graphs' section. The interactive element's logic is based on an adjacency matrix.
✔ What is a "clique"? Covered: Yes - Explained in detail in 'The Clique Problem' section. This is a core theme of the guide.
✔ How to identify a clique? Covered: Yes - This is the primary interactive component. The 'Interactive Clique Finder' allows users to discover this concept through experimentation. The second quiz question also tests this.
✔ Pseudocode for isClique function? Covered: Yes - Provided with line-by-line comments in the 'Pseudocode Examples' section. The final quiz question directly relates to its logic.
✔ What is a path in a graph? Covered: Yes - Explained conceptually in the 'Finding a Path' section.
✔ Pseudocode for pathExists function? Covered: Yes - Provided with detailed comments in the 'Pseudocode Examples' section, explaining the BFS strategy.

-->
